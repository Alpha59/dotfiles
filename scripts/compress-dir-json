#!/usr/bin/env bash
# shellcheck disable=SC1091
#
# Copyright 2023 Jake Ailor
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#==============================================================================
#title           :
#description     :
#author          : AILOR, JAKE
#email           : jakeailor@gmail.com
#date            :
#version         : 1.0.0
#notes           :
#==============================================================================

set -e
set -o pipefail

############################################################
# CHECK INSTALLED PROGRAMS                                 #
############################################################
# TODO: List the required Programs as strings:
# Get the print functions that we need
if [[ -e $HOME/helpers/check-installs ]]; then
    # shellcheck source=$HOME/helpers/check-installs
    $HOME/helpers/check-installs gum; # list of required programs as strings
fi
############################################################
# PRE-PROCESS ARGS                                         #
############################################################
# Pre-process the args to split them
# from -xyz to -x -y -z
# and --output=file.txt to --output file.txt
# TODO: MAKES $STDIN available
if [[ -e $HOME/helpers/pre-process ]]; then
    # shellcheck source=$HOME/helpers/pre-process
    source "$HOME/helpers/pre-process";
fi

if [[ $0 =~ "add-bash-header" ]]; then
    PROGRAM_NAME="$(basename "$1")";
else
    PROGRAM_NAME="$(basename "$0")";
fi
############################################################
# GET CONFIG FILE (yaml)                                         #
############################################################
# Pre-process the args to split them
# from -xyz to -x -y -z
# and --output=file.txt to --output file.txt
if [[ -e $HOME/helpers/config ]]; then
    # shellcheck source=$HOME/helpers/config
    source "$HOME/helpers/config";
fi
############################################################
# CREATES ALL OF THE PRINT FUNCTIONS                       #
############################################################
# Get the print functions that we need
if [[ -e $HOME/helpers/print-functions ]]; then
    # shellcheck source="$HOME/helpers/print-functions"
    source "$HOME/helpers/print-functions";
fi
############################################################
# Help SET VERSION AND USAGE Vars HERE                     #
############################################################
if [[ -f "$HOME/.cheat/$PROGRAM_NAME" ]]; then
    EXAMPLES="$(cat "$HOME/.cheat/$PROGRAM_NAME")";
else
    EXAMPLES="";
fi
############################################################

# TODO: Variables that need to be set should be added here:
VERSION="1.0.0"
USAGE="
$PROGRAM_NAME is a program designed to compress and decompress folder
structures into a JSON file, this is useful for creating a transportable
json file of the structure that can be decompressed later

usage: $PROGRAM_NAME [-v][-v][--help][--version]
usage: $0 [dir] [string]

    dir The directory to be compressed
    string The string to be decompressed
        -d,--decompress Decompress instead of Compressing
        -o,--output directory to send output
        -h,--help Brings up this menu
        -v,--verbose increases verbosity

    OPTIONS:
        compress-dir-json .
            Compresses the current directory to stdout
        compress-dir-json . -o out/
            Compresses the current directory to out/output.json
        echo {} | compress-dir-json -d -o .
            Decompresses the input to the current directory
        compress-dir-json {} -d -o .
            Decompresses the input to the current directory
        echo {} | compress-dir-json -d
            Decompresses the input to stdout
        compress-dir-json -d {}
            Decompresses the input to stdout
";

POSITIONAL_NUMBER_MIN=1;
if [[ -e $HOME/helpers/help ]]; then
    source "$HOME/helpers/help";
fi

############################################################
# Add interactive functionality (default)                  #
############################################################
DEFAULT="true";
INTERACTIVE="false";
if [[ -e $HOME/helpers/interactive ]]; then
    # shellcheck source=$HOME/helpers/traps
    source "$HOME/helpers/interactive";
fi

# interact accepts all gum options with the difference of "default" being the second option.
#
#usage: interact_prompt "Default" "Choose one of the following options:"
#usage: tst=$(interact choose "Default" "Default" "Test" "Test1" "Test2");
#pass "Test Result = $tst";

############################################################
# Catch interuptions and request abortion                  #
############################################################
if [[ -e $HOME/helpers/traps ]]; then
    # shellcheck source=$HOME/helpers/traps
    source "$HOME/helpers/traps";
fi
# Uncomment to force a double Ctrl-C on exit
#trap on_interrupt INT
# Uncomment to force root
#assert_root
# TODO: CLIPBOARD_OUTPUT should be set when appropraite
############################################################
# Process the input options. Add options as needed.        #
############################################################
# Get the options

POSITIONAL_ARGS=()

# TODO: Variables that need to be set are here:
while [[ $# -gt 0 ]]; do
  case $1 in
    -d|--decompress)
      DECOMPRESS=true
      shift # past argument
      ;;
    -o|--out)
      OUTPUT_DIR=$2
      shift # past argument
      shift # past value
      ;;
    --arg-test)
        ARG_TEST="$2"
        shift # past argument
        shift # past value
        ;;
     \?) # Invaid option
        error "Error: Invalid option"
        Help;
        exit 1;
        ;;
    -*)
        error "Unknown option $1"
        exit 1
        ;;
    *)
        POSITIONAL_ARGS+=("$1") # save positional arg
        shift # past argument
        ;;
  esac
done

set -- "${POSITIONAL_ARGS[@]}" # restore positional parameters

if [ $# -lt $POSITIONAL_NUMBER_MIN ]; then
    error "Please specify $POSITIONAL_NUMBER_MIN positional argument ($# were specified)";
    exit 1;
fi

if [[ -n "$ARG_TEST" ]]; then
    echo "ARGUMENT TEST: $ARG_TEST";
    echo "DEFAULT: $DEFAULT";
    echo "INTERACTIVE: $INTERACTIVE";
    echo "VERSION: $VERSION";
    echo "USAGE: $USAGE";
    echo "EXAMPLES: $EXAMPLES";
fi

############################################################
############################################################
# Main program                                             #
############################################################

OUTPUT_DIR="."
DECOMPRESS="false"
#POSITIONAL_ARGS=()
if test ! -t 0; then
    debug "Reading from stdin"
    PIPED_IN=$(cat)
fi

debug "Number of positional arguments: ${POSITIONAL_ARGS[*]}"
debug "Should Decompress: $DECOMPRESS"
debug "Positional ${POSITIONAL_ARGS[*]}";
if [[ "${#POSITIONAL_ARGS[*]}" -lt 2  &&  "$DECOMPRESS" != "true" ]]; then
    INPUT_DIR="${POSITIONAL_ARGS[0]}";
    FILES=""
    if [[ $INPUT_DIR != "" ]]; then
        debug "Looking for files..."
        FILES+=$(find $INPUT_DIR -type f -not -path '*/\.git/*' -not -path '*/package-lock.json');
    else
        INPUT_DIR="/";
    fi
    if [[ $PIPED_IN != "" ]]; then
        FILES+=" $PIPED_IN";
    fi

    json="{}";
    debug "$FILES";
    debug $INPUT_DIR
    for f in $FILES; do
        file=$(echo $f | sed "s|.*$INPUT_DIR/*||g" | sed "s|/|\.|g" | sed "s|-|_|g" | sed "s|^\.*||g");
        if [[ -f "$f" ]]; then
            debug "$f $file"
            encoded=$(cat $f | base64);
            json=$(echo $json | jq ".$file |= \"$encoded\"");
        fi
    done
    if [[ $OUTPUT_DIR == "" ]]; then
        echo $json | jq;
    else
        mkdir -p "$(dirname "$OUTPUT_DIR/output.json")";
        echo $json | jq > $OUTPUT_DIR/output.json
    fi
elif [[ "${#POSITIONAL_ARGS[*]}" -lt 2 && "$DECOMPRESS" == "true" ]]; then
    if [[ "${#POSITIONAL_ARGS[*]}" -eq 1 ]]; then
        debug "Using Positional Argument";
        INPUT=$(cat "${POSITIONAL_ARGS[0]}");
    else
        debug "Using Piped Input";
        INPUT=$PIPED_IN;
    fi
    debug "Decompressing";
    IFS=$'\n' FILE_ARRAY=($(echo "$INPUT" | jq -r '[paths(scalars)] | map(join("/")) | map(sub("/(?<a>(html|md|ts|js|scss|tsx|jpg|png|json|py|yml|yaml|ini|txt|devenv)$)"; ".\(.a)")) | .[] | tostring'));
    IFS=$'\n' FILE_PATHS=($(echo "$INPUT" | jq -r -c '[paths(scalars)]| .[]'));
    debug "${FILE_PATHS[*]}";
    debug "${FILE_ARRAY[*]}";
    debug "${#FILE_ARRAY[*]}";
    for ((i=0;i<"${#FILE_ARRAY[*]}";i++)); do
        debug "$i";
        file=$(echo "${FILE_ARRAY[$i]}" | sed 's/\([^_]\)_\([^_]\)/\1-\2/g');
        decoded=$(echo $INPUT | jq -r --argjson file_path "${FILE_PATHS[$i]}" 'getpath($file_path)' | base64 -d);
        mkdir -p "$(dirname "$OUTPUT_DIR/$file")";
        echo "$decoded" > "$OUTPUT_DIR/$file";
        debug "${FILE_PATHS[$i]}: $decoded -> $file";
    done
    mv "$OUTPUT_DIR/gitignore" "$OUTPUT_DIR/.gitignore";
    mv "$OUTPUT_DIR/babel/config.js" "$OUTPUT_DIR/babel.config.js";
    mv "$OUTPUT_DIR/configuration/webpack/config.js" "$OUTPUT_DIR/configuration/webpack.config.js";
    mv "$OUTPUT_DIR/gitignore" "$OUTPUT_DIR/.gitignore";
    mv "$OUTPUT_DIR/configuration/aws-lambda" "$OUTPUT_DIR/configuration/aws_lambda";
else
    show_help;
fi;
