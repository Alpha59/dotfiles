... ()
{
    local stringToSpread="$@";
    [[ -z "${stringToSpread}" ]] && {
        printf "%s\n" "Usage: ${FUNCNAME} string";
        return $false
    };
    [[ ${#@} -eq 1 ]] && {
        for ((i=0; i<=${#stringToSpread}; i++))
        do
            while [[ -n "${stringToSpread}" ]]; do
                printf "%c\n" "${stringToSpread}";
                stringToSpread=${stringToSpread#*?};
            done;
        done
    }
}
declare -fx ...
___git_complete ()
{
    local wrapper="__git_wrap${2}";
    eval "$wrapper () { __git_func_wrap $2 ; }";
    complete -o bashdefault -o default -o nospace -F $wrapper $1 2> /dev/null || complete -o default -o nospace -F $wrapper $1
}
__app ()
{
    case "${COMP_CWORD}" in
        1)
            COMPREPLY=($(compgen -W "help version list-apps launch action list-actions" -- "${COMP_WORDS[1]}"));
            return 0
        ;;
        2)
            case "${COMP_WORDS[1]}" in
                launch | action | list-actions)
                    COMPREPLY=($(compgen -W "`gapplication list-apps`" -- "${COMP_WORDS[2]}"));
                    return 0
                ;;
                *)
                    COMPREPLY=();
                    return 0
                ;;
            esac
        ;;
    esac;
    case "${COMP_WORDS[1]}" in
        action)
            if [ "${COMP_CWORD}" == 3 ]; then
                COMPREPLY=($(compgen -W "`gapplication list-actions "${COMP_WORDS[2]}"`" -- "${COMP_WORDS[3]}"));
                return 0;
            else
                COMPREPLY=();
                return 0;
            fi
        ;;
        launch)
            COMPREPLY=($(compgen -A file "${COMP_WORDS[COMP_CWORD]}"));
            return 0
        ;;
        *)
            COMPREPLY=();
            return 0
        ;;
    esac
}
__bat_escape_completions ()
{
    [[ $cur == [\"\']* ]] && return 0;
    if ((
		BASH_VERSINFO[0] > 4 || 		BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] > 0
	)); then
        local i;
        for i in ${!COMPREPLY[*]};
        do
            printf -v "COMPREPLY[i]" %q "${COMPREPLY[i]}";
        done;
    else
        compopt -o filenames;
    fi
}
__bat_init_completion ()
{
    COMPREPLY=();
    _get_comp_words_by_ref "$@" cur prev words cword
}
__brew_complete_casks ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local casks;
    casks="$(brew casks)";
    while read -r line; do
        COMPREPLY+=("${line}");
    done < <(compgen -W "${casks}" -- "${cur}")
}
__brew_complete_commands ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local cmds;
    if [[ -n ${__HOMEBREW_COMMANDS} ]]; then
        cmds=${__HOMEBREW_COMMANDS};
    else
        if [[ -n ${HOMEBREW_CACHE:-} && -f ${HOMEBREW_CACHE}/all_commands_list.txt ]]; then
            cmds="$(< "${HOMEBREW_CACHE}/all_commands_list.txt" \grep -v instal$)";
        else
            if [[ -n ${HOMEBREW_REPOSITORY:-} && -f ${HOMEBREW_REPOSITORY}/completions/internal_commands_list.txt ]]; then
                cmds="$(< "${HOMEBREW_REPOSITORY}/completions/internal_commands_list.txt" \grep -v instal$)";
            fi;
        fi;
    fi;
    while read -r line; do
        COMPREPLY+=("${line}");
    done < <(compgen -W "${cmds}" -- "${cur}");
    export __HOMEBREW_COMMANDS=${cmds}
}
__brew_complete_files ()
{
    command -v compopt >&/dev/null && compopt -o default
}
__brew_complete_formulae ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local formulae;
    formulae="$(brew formulae)";
    while read -r line; do
        COMPREPLY+=("${line}");
    done < <(compgen -W "${formulae}" -- "${cur}")
}
__brew_complete_installed_casks ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local installed_casks;
    installed_casks="$(command ls "$(brew --caskroom)" 2>/dev/null)";
    while read -r line; do
        COMPREPLY+=("${line}");
    done < <(compgen -W "${installed_casks}" -- "${cur}")
}
__brew_complete_installed_formulae ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local installed_formulae;
    installed_formulae="$(command ls "${HOMEBREW_CELLAR:-$(brew --cellar)}" 2>/dev/null)";
    while read -r line; do
        COMPREPLY+=("${line}");
    done < <(compgen -W "${installed_formulae}" -- "${cur}")
}
__brew_complete_outdated_casks ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local outdated_casks;
    outdated_casks="$(brew outdated --cask --quiet)";
    while read -r line; do
        COMPREPLY+=("${line}");
    done < <(compgen -W "${outdated_casks}" -- "${cur}")
}
__brew_complete_outdated_formulae ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    local outdated_formulae;
    outdated_formulae="$(brew outdated --formula --quiet)";
    while read -r line; do
        COMPREPLY+=("${line}");
    done < <(compgen -W "${outdated_formulae}" -- "${cur}")
}
__brew_complete_tapped ()
{
    local dir taps taplib;
    taplib=${HOMEBREW_REPOSITORY:-$(brew --repository)}/Library/Taps;
    for dir in "${taplib}"/*/*;
    do
        [[ -d ${dir} ]] || continue;
        dir=${dir#"${taplib}"/};
        dir=${dir/homebrew-/};
        taps+=" ${dir}";
    done;
    __brewcomp "${taps}"
}
__brewcomp ()
{
    local list s sep='
' IFS='
';
    local cur=${COMP_WORDS[COMP_CWORD]};
    for s in $1;
    do
        __brewcomp_words_include "${s}" || list+="${s}${sep}";
    done;
    list=${list%"${sep}"};
    IFS="${sep}";
    while read -r line; do
        COMPREPLY+=("${line}");
    done < <(compgen -W "${list}" -- "${cur}")
}
__brewcomp_words_include ()
{
    local element idx;
    for ((idx = 1; idx < COMP_CWORD; idx++ ))
    do
        element=${COMP_WORDS[idx]};
        [[ -n ${element} && ${element} == "$1" ]] && return 0;
    done;
    return 1
}
__docker_append_to_completions ()
{
    COMPREPLY=(${COMPREPLY[@]/%/"$1"})
}
__docker_complete_capabilities_addable ()
{
    local capabilities=(ALL CAP_AUDIT_CONTROL CAP_AUDIT_READ CAP_BLOCK_SUSPEND CAP_BPF CAP_CHECKPOINT_RESTORE CAP_DAC_READ_SEARCH CAP_IPC_LOCK CAP_IPC_OWNER CAP_LEASE CAP_LINUX_IMMUTABLE CAP_MAC_ADMIN CAP_MAC_OVERRIDE CAP_NET_ADMIN CAP_NET_BROADCAST CAP_PERFMON CAP_SYS_ADMIN CAP_SYS_BOOT CAP_SYSLOG CAP_SYS_MODULE CAP_SYS_NICE CAP_SYS_PACCT CAP_SYS_PTRACE CAP_SYS_RAWIO CAP_SYS_RESOURCE CAP_SYS_TIME CAP_SYS_TTY_CONFIG CAP_WAKE_ALARM RESET);
    COMPREPLY=($( compgen -W "${capabilities[*]} ${capabilities[*]#CAP_}" -- "$cur" ))
}
__docker_complete_capabilities_droppable ()
{
    local capabilities=(ALL CAP_AUDIT_WRITE CAP_CHOWN CAP_DAC_OVERRIDE CAP_FOWNER CAP_FSETID CAP_KILL CAP_MKNOD CAP_NET_BIND_SERVICE CAP_NET_RAW CAP_SETFCAP CAP_SETGID CAP_SETPCAP CAP_SETUID CAP_SYS_CHROOT RESET);
    COMPREPLY=($( compgen -W "${capabilities[*]} ${capabilities[*]#CAP_}" -- "$cur" ))
}
__docker_complete_configs ()
{
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_configs "$@")" -- "$current"))
}
__docker_complete_container_ids ()
{
    local containers=($(__docker_q ps -aq));
    COMPREPLY=($(compgen -W "${containers[*]}" -- "$cur"))
}
__docker_complete_container_names ()
{
    local containers=($(__docker_q ps -aq --no-trunc));
    local names=($(__docker_q inspect --format '{{.Name}}' "${containers[@]}"));
    names=("${names[@]#/}");
    COMPREPLY=($(compgen -W "${names[*]}" -- "$cur"))
}
__docker_complete_containers ()
{
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_containers "$@")" -- "$current"))
}
__docker_complete_containers_all ()
{
    __docker_complete_containers "$@" --all
}
__docker_complete_containers_in_network ()
{
    local containers=($(__docker_q network inspect -f '{{range $i, $c := .Containers}}{{$i}} {{$c.Name}} {{end}}' "$1"));
    COMPREPLY=($(compgen -W "${containers[*]}" -- "$cur"))
}
__docker_complete_containers_removable ()
{
    __docker_complete_containers "$@" --filter status=created --filter status=exited
}
__docker_complete_containers_running ()
{
    __docker_complete_containers "$@" --filter status=running
}
__docker_complete_containers_stoppable ()
{
    __docker_complete_containers "$@" --filter status=running --filter status=paused
}
__docker_complete_containers_stopped ()
{
    __docker_complete_containers "$@" --filter status=exited
}
__docker_complete_containers_unpauseable ()
{
    __docker_complete_containers "$@" --filter status=paused
}
__docker_complete_contexts ()
{
    local contexts=($(__docker_contexts "$@"));
    COMPREPLY=($(compgen -W "${contexts[*]}" -- "$cur"))
}
__docker_complete_detach_keys ()
{
    case "$prev" in
        --detach-keys)
            case "$cur" in
                *,)
                    COMPREPLY=($( compgen -W "${cur}ctrl-" -- "$cur" ))
                ;;
                *)
                    COMPREPLY=($( compgen -W "ctrl-" -- "$cur" ))
                ;;
            esac;
            __docker_nospace;
            return
        ;;
    esac;
    return 1
}
__docker_complete_images ()
{
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_images "$@")" -- "$current"));
    __ltrim_colon_completions "$current"
}
__docker_complete_isolation ()
{
    COMPREPLY=($( compgen -W "default hyperv process" -- "$cur" ))
}
__docker_complete_local_interfaces ()
{
    local additional_interface;
    if [ "$1" = "--add" ]; then
        additional_interface="$2";
        shift 2;
    fi;
    COMPREPLY=($( compgen -W "$(__docker_local_interfaces "$@") $additional_interface" -- "$cur" ))
}
__docker_complete_local_ips ()
{
    __docker_complete_local_interfaces --ip-only
}
__docker_complete_log_driver_options ()
{
    local key=$(__docker_map_key_of_current_option '--log-opt');
    case "$key" in
        awslogs-create-group)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        awslogs-credentials-endpoint)
            COMPREPLY=($( compgen -W "/" -- "${cur##*=}" ));
            __docker_nospace;
            return
        ;;
        compress | fluentd-async-connect)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        fluentd-sub-second-precision)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        gelf-address)
            COMPREPLY=($( compgen -W "tcp udp" -S "://" -- "${cur##*=}" ));
            __docker_nospace;
            return
        ;;
        gelf-compression-level)
            COMPREPLY=($( compgen -W "1 2 3 4 5 6 7 8 9" -- "${cur##*=}" ));
            return
        ;;
        gelf-compression-type)
            COMPREPLY=($( compgen -W "gzip none zlib" -- "${cur##*=}" ));
            return
        ;;
        line-only)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        mode)
            COMPREPLY=($( compgen -W "blocking non-blocking" -- "${cur##*=}" ));
            return
        ;;
        syslog-address)
            COMPREPLY=($( compgen -W "tcp:// tcp+tls:// udp:// unix://" -- "${cur##*=}" ));
            __docker_nospace;
            __ltrim_colon_completions "${cur}";
            return
        ;;
        syslog-facility)
            COMPREPLY=($( compgen -W "
				auth
				authpriv
				cron
				daemon
				ftp
				kern
				local0
				local1
				local2
				local3
				local4
				local5
				local6
				local7
				lpr
				mail
				news
				syslog
				user
				uucp
			" -- "${cur##*=}" ));
            return
        ;;
        syslog-format)
            COMPREPLY=($( compgen -W "rfc3164 rfc5424 rfc5424micro" -- "${cur##*=}" ));
            return
        ;;
        syslog-tls-ca-cert | syslog-tls-cert | syslog-tls-key)
            _filedir;
            return
        ;;
        syslog-tls-skip-verify)
            COMPREPLY=($( compgen -W "true" -- "${cur##*=}" ));
            return
        ;;
        splunk-url)
            COMPREPLY=($( compgen -W "http:// https://" -- "${cur##*=}" ));
            __docker_nospace;
            __ltrim_colon_completions "${cur}";
            return
        ;;
        splunk-gzip | splunk-insecureskipverify | splunk-verify-connection)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        splunk-format)
            COMPREPLY=($( compgen -W "inline json raw" -- "${cur##*=}" ));
            return
        ;;
    esac;
    return 1
}
__docker_complete_log_drivers ()
{
    COMPREPLY=($( compgen -W "
		awslogs
		etwlogs
		fluentd
		gcplogs
		gelf
		journald
		json-file
		local
		logentries
		none
		splunk
		syslog
	" -- "$cur" ))
}
__docker_complete_log_levels ()
{
    COMPREPLY=($( compgen -W "debug info warn error fatal" -- "$cur" ))
}
__docker_complete_log_options ()
{
    local common_options1="max-buffer-size mode";
    local common_options2="env env-regex labels";
    local awslogs_options="$common_options1 awslogs-create-group awslogs-credentials-endpoint awslogs-datetime-format awslogs-group awslogs-multiline-pattern awslogs-region awslogs-stream tag";
    local fluentd_options="$common_options1 $common_options2 fluentd-address fluentd-async fluentd-buffer-limit fluentd-request-ack fluentd-retry-wait fluentd-max-retries fluentd-sub-second-precision tag";
    local gcplogs_options="$common_options1 $common_options2 gcp-log-cmd gcp-meta-id gcp-meta-name gcp-meta-zone gcp-project";
    local gelf_options="$common_options1 $common_options2 gelf-address gelf-compression-level gelf-compression-type gelf-tcp-max-reconnect gelf-tcp-reconnect-delay tag";
    local journald_options="$common_options1 $common_options2 tag";
    local json_file_options="$common_options1 $common_options2 compress max-file max-size";
    local local_options="$common_options1 compress max-file max-size";
    local logentries_options="$common_options1 $common_options2 line-only logentries-token tag";
    local splunk_options="$common_options1 $common_options2 splunk-caname splunk-capath splunk-format splunk-gzip splunk-gzip-level splunk-index splunk-insecureskipverify splunk-source splunk-sourcetype splunk-token splunk-url splunk-verify-connection tag";
    local syslog_options="$common_options1 $common_options2 syslog-address syslog-facility syslog-format syslog-tls-ca-cert syslog-tls-cert syslog-tls-key syslog-tls-skip-verify tag";
    local all_options="$fluentd_options $gcplogs_options $gelf_options $journald_options $logentries_options $json_file_options $syslog_options $splunk_options";
    case $(__docker_value_of_option --log-driver) in
        '')
            COMPREPLY=($( compgen -W "$all_options" -S = -- "$cur" ))
        ;;
        awslogs)
            COMPREPLY=($( compgen -W "$awslogs_options" -S = -- "$cur" ))
        ;;
        fluentd)
            COMPREPLY=($( compgen -W "$fluentd_options" -S = -- "$cur" ))
        ;;
        gcplogs)
            COMPREPLY=($( compgen -W "$gcplogs_options" -S = -- "$cur" ))
        ;;
        gelf)
            COMPREPLY=($( compgen -W "$gelf_options" -S = -- "$cur" ))
        ;;
        journald)
            COMPREPLY=($( compgen -W "$journald_options" -S = -- "$cur" ))
        ;;
        json-file)
            COMPREPLY=($( compgen -W "$json_file_options" -S = -- "$cur" ))
        ;;
        local)
            COMPREPLY=($( compgen -W "$local_options" -S = -- "$cur" ))
        ;;
        logentries)
            COMPREPLY=($( compgen -W "$logentries_options" -S = -- "$cur" ))
        ;;
        syslog)
            COMPREPLY=($( compgen -W "$syslog_options" -S = -- "$cur" ))
        ;;
        splunk)
            COMPREPLY=($( compgen -W "$splunk_options" -S = -- "$cur" ))
        ;;
        *)
            return
        ;;
    esac;
    __docker_nospace
}
__docker_complete_networks ()
{
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_networks "$@")" -- "$current"))
}
__docker_complete_nodes ()
{
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_nodes "$@")" -- "$current"))
}
__docker_complete_plugin ()
{
    local path=$1;
    local completionCommand="__completeNoDesc";
    local resultArray=($path $completionCommand);
    for value in "${words[@]:2}";
    do
        if [ -z "$value" ]; then
            resultArray+=("''");
        else
            resultArray+=("$value");
        fi;
    done;
    local result=$(eval "${resultArray[*]}" 2> /dev/null | grep -v '^:[0-9]*$');
    if [ -z "$result" ]; then
        _filedir;
    else
        COMPREPLY=($(compgen -W "${result}" -- "${current-}"));
    fi
}
__docker_complete_plugins_bundled ()
{
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_plugins_bundled "$@")" -- "$current"))
}
__docker_complete_plugins_installed ()
{
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_plugins_installed "$@")" -- "$current"))
}
__docker_complete_resolved_hostname ()
{
    command -v host > /dev/null 2>&1 || return;
    COMPREPLY=($(host 2>/dev/null "${cur%:}" | awk '/has address/ {print $4}'))
}
__docker_complete_restart ()
{
    case "$prev" in
        --restart)
            case "$cur" in
                on-failure:*)

                ;;
                *)
                    COMPREPLY=($( compgen -W "always no on-failure on-failure: unless-stopped" -- "$cur"))
                ;;
            esac;
            return
        ;;
    esac;
    return 1
}
__docker_complete_runtimes ()
{
    COMPREPLY=($(compgen -W "$(__docker_runtimes)" -- "$cur"))
}
__docker_complete_secrets ()
{
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_secrets "$@")" -- "$current"))
}
__docker_complete_services ()
{
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(__docker_services "$@" --filter "name=$current"))
}
__docker_complete_services_and_tasks ()
{
    COMPREPLY=($(compgen -W "$(__docker_services "$@") $(__docker_tasks)" -- "$cur"))
}
__docker_complete_signals ()
{
    local signals=(SIGCONT SIGHUP SIGINT SIGKILL SIGQUIT SIGSTOP SIGTERM SIGUSR1 SIGUSR2);
    COMPREPLY=($( compgen -W "${signals[*]} ${signals[*]#SIG}" -- "$( echo "$cur" | tr '[:lower:]' '[:upper:]')" ))
}
__docker_complete_stacks ()
{
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_stacks "$@")" -- "$current"))
}
__docker_complete_ulimits ()
{
    local limits="
		as
		chroot
		core
		cpu
		data
		fsize
		locks
		maxlogins
		maxsyslogins
		memlock
		msgqueue
		nice
		nofile
		nproc
		priority
		rss
		rtprio
		sigpending
		stack
	";
    if [ "$1" = "--rm" ]; then
        COMPREPLY=($( compgen -W "$limits" -- "$cur" ));
    else
        COMPREPLY=($( compgen -W "$limits" -S = -- "$cur" ));
        __docker_nospace;
    fi
}
__docker_complete_user_group ()
{
    if [[ $cur == *:* ]]; then
        COMPREPLY=($(compgen -g -- "${cur#*:}"));
    else
        COMPREPLY=($(compgen -u -S : -- "$cur"));
        __docker_nospace;
    fi
}
__docker_complete_volumes ()
{
    local current="$cur";
    if [ "$1" = "--cur" ]; then
        current="$2";
        shift 2;
    fi;
    COMPREPLY=($(compgen -W "$(__docker_volumes "$@")" -- "$current"))
}
__docker_configs ()
{
    local format;
    if [ "$1" = "--id" ]; then
        format='{{.ID}}';
        shift;
    else
        if [ "$1" = "--name" ]; then
            format='{{.Name}}';
            shift;
        else
            if [ "$DOCKER_COMPLETION_SHOW_CONFIG_IDS" = yes ]; then
                format='{{.ID}} {{.Name}}';
            else
                format='{{.Name}}';
            fi;
        fi;
    fi;
    __docker_q config ls --format "$format" "$@"
}
__docker_containers ()
{
    local format;
    if [ "$1" = "--id" ]; then
        format='{{.ID}}';
        shift;
    else
        if [ "$1" = "--name" ]; then
            format='{{.Names}}';
            shift;
        else
            if [ "${DOCKER_COMPLETION_SHOW_CONTAINER_IDS}" = yes ]; then
                format='{{.ID}} {{.Names}}';
            else
                format='{{.Names}}';
            fi;
        fi;
    fi;
    __docker_q ps --format "$format" "$@"
}
__docker_contexts ()
{
    local add=();
    while true; do
        case "$1" in
            --add)
                add+=("$2");
                shift 2
            ;;
            *)
                break
            ;;
        esac;
    done;
    __docker_q context ls -q;
    echo "${add[@]}"
}
__docker_fetch_info ()
{
    if [ -z "$info_fetched" ]; then
        read -r server_experimental server_os <<< "$(__docker_q version -f '{{.Server.Experimental}} {{.Server.Os}}')";
        info_fetched=true;
    fi
}
__docker_images ()
{
    local repo_format='{{.Repository}}';
    local tag_format='{{.Repository}}:{{.Tag}}';
    local id_format='{{.ID}}';
    local all;
    local format;
    if [ "$DOCKER_COMPLETION_SHOW_IMAGE_IDS" = "all" ]; then
        all='--all';
    fi;
    while true; do
        case "$1" in
            --repo)
                format+="$repo_format\n";
                shift
            ;;
            --tag)
                if [ "${DOCKER_COMPLETION_SHOW_TAGS:-yes}" = "yes" ]; then
                    format+="$tag_format\n";
                fi;
                shift
            ;;
            --id)
                if [[ $DOCKER_COMPLETION_SHOW_IMAGE_IDS =~ ^(all|non-intermediate)$ ]]; then
                    format+="$id_format\n";
                fi;
                shift
            ;;
            --force-tag)
                format+="$tag_format\n";
                shift
            ;;
            *)
                break
            ;;
        esac;
    done;
    __docker_q image ls --no-trunc --format "${format%\\n}" $all "$@" | grep -v '<none>$'
}
__docker_local_interfaces ()
{
    command -v ip > /dev/null 2>&1 || return;
    local format;
    if [ "$1" = "--ip-only" ]; then
        format='\1';
        shift;
    else
        format='\1 \2';
    fi;
    ip addr show scope global 2> /dev/null | sed -n "s| \+inet \([0-9.]\+\).* \([^ ]\+\)|$format|p"
}
__docker_map_key_of_current_option ()
{
    local glob="$1";
    local key glob_pos;
    if [ "$cur" = "=" ]; then
        key="$prev";
        glob_pos=$((cword - 2));
    else
        if [[ $cur == *=* ]]; then
            key=${cur%=*};
            glob_pos=$((cword - 1));
        else
            if [ "$prev" = "=" ]; then
                key=${words[$cword - 2]};
                glob_pos=$((cword - 3));
            else
                return;
            fi;
        fi;
    fi;
    [ "${words[$glob_pos]}" = "=" ] && ((glob_pos--));
    [[ ${words[$glob_pos]} == @($glob) ]] && echo "$key"
}
__docker_networks ()
{
    local format;
    if [ "$1" = "--id" ]; then
        format='{{.ID}}';
        shift;
    else
        if [ "$1" = "--name" ]; then
            format='{{.Name}}';
            shift;
        else
            if [ "${DOCKER_COMPLETION_SHOW_NETWORK_IDS}" = yes ]; then
                format='{{.ID}} {{.Name}}';
            else
                format='{{.Name}}';
            fi;
        fi;
    fi;
    __docker_q network ls --format "$format" "$@"
}
__docker_nodes ()
{
    local format;
    if [ "$DOCKER_COMPLETION_SHOW_NODE_IDS" = yes ]; then
        format='{{.ID}} {{.Hostname}}';
    else
        format='{{.Hostname}}';
    fi;
    local add=();
    while true; do
        case "$1" in
            --id)
                format='{{.ID}}';
                shift
            ;;
            --name)
                format='{{.Hostname}}';
                shift
            ;;
            --add)
                add+=("$2");
                shift 2
            ;;
            *)
                break
            ;;
        esac;
    done;
    echo "$(__docker_q node ls --format "$format" "$@")" "${add[@]}"
}
__docker_nospace ()
{
    type compopt >&/dev/null && compopt -o nospace
}
__docker_plugins_bundled ()
{
    local type add=() remove=();
    while true; do
        case "$1" in
            --type)
                type="$2";
                shift 2
            ;;
            --add)
                add+=("$2");
                shift 2
            ;;
            --remove)
                remove+=("$2");
                shift 2
            ;;
            *)
                break
            ;;
        esac;
    done;
    local plugins=($(__docker_q info --format "{{range \$i, \$p := .Plugins.$type}}{{.}} {{end}}"));
    for del in "${remove[@]}";
    do
        plugins=(${plugins[@]/$del/});
    done;
    echo "${plugins[@]}" "${add[@]}"
}
__docker_plugins_installed ()
{
    local format;
    if [ "$DOCKER_COMPLETION_SHOW_PLUGIN_IDS" = yes ]; then
        format='{{.ID}} {{.Name}}';
    else
        format='{{.Name}}';
    fi;
    __docker_q plugin ls --format "$format" "$@"
}
__docker_pos_first_nonflag ()
{
    local argument_flags=$1;
    local counter=$((${subcommand_pos:-${command_pos}} + 1));
    while [ "$counter" -le "$cword" ]; do
        if [ -n "$argument_flags" ] && eval "case '${words[$counter]}' in $argument_flags) true ;; *) false ;; esac"; then
            (( counter++ ));
            [ "${words[$counter]}" = "=" ] && (( counter++ ));
        else
            case "${words[$counter]}" in
                -*)

                ;;
                *)
                    break
                ;;
            esac;
        fi;
        while [ "${words[$counter + 1]}" = "=" ]; do
            counter=$(( counter + 2));
        done;
        (( counter++ ));
    done;
    echo "$counter"
}
__docker_q ()
{
    docker ${host:+--host "$host"} ${config:+--config "$config"} ${context:+--context "$context"} "$@" 2> /dev/null
}
__docker_runtimes ()
{
    __docker_q info | sed -n 's/^Runtimes: \(.*\)/\1/p'
}
__docker_secrets ()
{
    local format;
    if [ "$1" = "--id" ]; then
        format='{{.ID}}';
        shift;
    else
        if [ "$1" = "--name" ]; then
            format='{{.Name}}';
            shift;
        else
            if [ "$DOCKER_COMPLETION_SHOW_SECRET_IDS" = yes ]; then
                format='{{.ID}} {{.Name}}';
            else
                format='{{.Name}}';
            fi;
        fi;
    fi;
    __docker_q secret ls --format "$format" "$@"
}
__docker_server_is_experimental ()
{
    __docker_fetch_info;
    [ "$server_experimental" = "true" ]
}
__docker_server_os_is ()
{
    local expected_os="$1";
    __docker_fetch_info;
    [ "$server_os" = "$expected_os" ]
}
__docker_services ()
{
    local format='{{.Name}}';
    [ "${DOCKER_COMPLETION_SHOW_SERVICE_IDS}" = yes ] && format='{{.ID}} {{.Name}}';
    if [ "$1" = "--id" ]; then
        format='{{.ID}}';
        shift;
    else
        if [ "$1" = "--name" ]; then
            format='{{.Name}}';
            shift;
        fi;
    fi;
    __docker_q service ls --quiet --format "$format" "$@"
}
__docker_stacks ()
{
    __docker_q stack ls | awk 'NR>1 {print $1}'
}
__docker_subcommands ()
{
    local subcommands="$1";
    local counter=$((command_pos + 1));
    while [ "$counter" -lt "$cword" ]; do
        case "${words[$counter]}" in
            $(__docker_to_extglob "$subcommands"))
                subcommand_pos=$counter;
                local subcommand=${words[$counter]};
                local completions_func=_docker_${command}_${subcommand//-/_};
                declare -F "$completions_func" > /dev/null && "$completions_func";
                return 0
            ;;
        esac;
        (( counter++ ));
    done;
    return 1
}
__docker_tasks ()
{
    __docker_q service ps --format '{{.ID}}' ""
}
__docker_to_alternatives ()
{
    local parts=($1);
    local IFS='|';
    echo "${parts[*]}"
}
__docker_to_extglob ()
{
    local extglob=$( __docker_to_alternatives "$1" );
    echo "@($extglob)"
}
__docker_value_of_option ()
{
    local option_extglob=$(__docker_to_extglob "$1");
    local counter=$((command_pos + 1));
    while [ "$counter" -lt "$cword" ]; do
        case ${words[$counter]} in
            $option_extglob)
                echo "${words[$counter + 1]}";
                break
            ;;
        esac;
        (( counter++ ));
    done
}
__docker_volumes ()
{
    __docker_q volume ls -q "$@"
}
__expand_tilde_by_ref ()
{
    if [ "${!1:0:1}" = "~" ]; then
        if [ "${!1}" != "${!1//\/}" ]; then
            eval $1="${!1/%\/*}"/'${!1#*/}';
        else
            eval $1="${!1}";
        fi;
    fi
}
__gdbus ()
{
    local IFS='
';
    local cur=`_get_cword :`;
    local suggestions=$(gdbus complete "${COMP_LINE}" ${COMP_POINT});
    COMPREPLY=($(compgen -W "$suggestions" -- "$cur"));
    case "$cur" in
        *:*)
            case "$COMP_WORDBREAKS" in
                *:*)
                    local colon_word=${cur%${cur##*:}};
                    local i=${#COMPREPLY[*]};
                    while [ $((--i)) -ge 0 ]; do
                        COMPREPLY[$i]=${COMPREPLY[$i]#"$colon_word"};
                    done
                ;;
            esac
        ;;
    esac
}
__get_cword_at_cursor_by_ref ()
{
    local cword words=();
    __reassemble_comp_words_by_ref "$1" words cword;
    local i cur2;
    local cur="$COMP_LINE";
    local index="$COMP_POINT";
    for ((i = 0; i <= cword; ++i ))
    do
        while [[ "${#cur}" -ge ${#words[i]} && "${cur:0:${#words[i]}}" != "${words[i]}" ]]; do
            cur="${cur:1}";
            ((index--));
        done;
        if [[ "$i" -lt "$cword" ]]; then
            local old_size="${#cur}";
            cur="${cur#${words[i]}}";
            local new_size="${#cur}";
            index=$(( index - old_size + new_size ));
        fi;
    done;
    if [[ "${words[cword]:0:${#cur}}" != "$cur" ]]; then
        cur2=${words[cword]};
    else
        cur2=${cur:0:$index};
    fi;
    local "$2" "$3" "$4" && _upvars -a${#words[@]} $2 "${words[@]}" -v $3 "$cword" -v $4 "$cur2"
}
__gio ()
{
    if (( ${COMP_CWORD} == 1 )); then
        COMPREPLY=($(compgen -W "help version cat copy info launch list mime mkdir monitor mount move open rename remove save set trash tree" -- "${COMP_WORDS[1]}"));
        compopt +o nospace;
        return 0;
    fi;
    __gio_location
}
__gio_has_common_prefix ()
{
    local i;
    for ((i = 1; i < ${#COMPREPLY[@]}; i++ ))
    do
        if [[ "${COMPREPLY[i-1]:${#cur}:1}" != "${COMPREPLY[i]:${#cur}:1}" ]]; then
            return 1;
        fi;
    done;
    return 0
}
__gio_location ()
{
    local cur;
    _get_comp_words_by_ref -n : cur;
    local dir="";
    if [[ $cur =~ "/"$ ]]; then
        dir="$cur";
    else
        if [[ $cur =~ "/" ]]; then
            dir=${cur%$(basename "$cur")};
        fi;
    fi;
    local mounts=();
    local mount;
    while IFS='
' read mount; do
        [[ "$mount" =~ ^"file:" ]] && continue;
        [[ "$mount" =~ ^"$cur" && "$mount" != "$cur" ]] && mounts+=("$mount");
    done < <(gio mount -li | sed -n -r 's/^ *(default_location|activation_root)=(.*)$/\2/p' | sort -u);
    local -a tmp="( ${dir} )";
    local unescaped_dir="${tmp[0]}";
    local files=();
    local names=();
    local name size type;
    while IFS='	' read name size type; do
        local escaped_name="$(printf "%q" "$name")";
        if [[ "$type" == "(directory)" ]]; then
            escaped_name="$escaped_name/";
        else
            escaped_name="$escaped_name ";
        fi;
        local path="$dir$escaped_name";
        if [[ "$path" =~ ^"$cur" ]]; then
            files+=("$path");
            names+=("$escaped_name");
        fi;
    done < <(gio list -hl "$unescaped_dir" 2> /dev/null);
    COMPREPLY=("${files[@]}" "${mounts[@]}");
    if ! __gio_has_common_prefix; then
        COMPREPLY=("${mounts[@]} ${names[@]}");
        COMPREPLY+=(" ");
        return 0;
    fi;
    __ltrim_colon_completions "$cur"
}
__git ()
{
    git ${__git_C_args:+"${__git_C_args[@]}"} ${__git_dir:+--git-dir="$__git_dir"} "$@" 2> /dev/null
}
__git_aliased_command ()
{
    local cur=$1 last list= word cmdline;
    while [[ -n "$cur" ]]; do
        if [[ "$list" == *" $cur "* ]]; then
            return;
        fi;
        cmdline=$(__git config --get "alias.$cur");
        list=" $cur $list";
        last=$cur;
        cur=;
        for word in $cmdline;
        do
            case "$word" in
                \!gitk | gitk)
                    cur="gitk";
                    break
                ;;
                \!*)
                    : shell command alias
                ;;
                -*)
                    : option
                ;;
                *=*)
                    : setting env
                ;;
                git)
                    : git itself
                ;;
                \(\))
                    : skip parens of shell function definition
                ;;
                {)
                    : skip start of shell helper function
                ;;
                :)
                    : skip null command
                ;;
                \'*)
                    : skip opening quote after sh -c
                ;;
                *)
                    cur="$word";
                    break
                ;;
            esac;
        done;
    done;
    cur=$last;
    if [[ "$cur" != "$1" ]]; then
        echo "$cur";
    fi
}
__git_checkout_default_dwim_mode ()
{
    local last_option dwim_opt="--dwim";
    if [ "${GIT_COMPLETION_CHECKOUT_NO_GUESS-}" = "1" ]; then
        dwim_opt="";
    fi;
    if [ -n "$(__git_find_on_cmdline "--no-track")" ]; then
        dwim_opt="";
    fi;
    if [ "$(__git config --type=bool checkout.guess)" = "false" ]; then
        dwim_opt="";
    fi;
    last_option="$(__git_find_last_on_cmdline "--guess --no-guess")";
    case "$last_option" in
        --guess)
            dwim_opt="--dwim"
        ;;
        --no-guess)
            dwim_opt=""
        ;;
    esac;
    echo "$dwim_opt"
}
__git_complete ()
{
    local func;
    if __git_have_func $2; then
        func=$2;
    else
        if __git_have_func __$2_main; then
            func=__$2_main;
        else
            if __git_have_func _$2; then
                func=_$2;
            else
                echo "ERROR: could not find function '$2'" 1>&2;
                return 1;
            fi;
        fi;
    fi;
    ___git_complete $1 $func
}
__git_complete_command ()
{
    local command="$1";
    local completion_func="_git_${command//-/_}";
    if ! __git_have_func $completion_func && __git_have_func _completion_loader; then
        _completion_loader "git-$command";
    fi;
    if __git_have_func $completion_func; then
        $completion_func;
        return 0;
    else
        if __git_support_parseopt_helper "$command"; then
            __git_complete_common "$command";
            return 0;
        else
            return 1;
        fi;
    fi
}
__git_complete_common ()
{
    local command="$1";
    case "$cur" in
        --*)
            __gitcomp_builtin "$command"
        ;;
    esac
}
__git_complete_config_variable_name ()
{
    local cur_="$cur" sfx;
    while test $# != 0; do
        case "$1" in
            --cur=*)
                cur_="${1##--cur=}"
            ;;
            --sfx=*)
                sfx="${1##--sfx=}"
            ;;
            *)
                return 1
            ;;
        esac;
        shift;
    done;
    case "$cur_" in
        branch.*.*)
            local pfx="${cur_%.*}.";
            cur_="${cur_##*.}";
            __gitcomp "remote pushRemote merge mergeOptions rebase" "$pfx" "$cur_" "$sfx";
            return
        ;;
        branch.*)
            local pfx="${cur_%.*}.";
            cur_="${cur_#*.}";
            __gitcomp_direct "$(__git_heads "$pfx" "$cur_" ".")";
            __gitcomp_nl_append 'autoSetupMerge
autoSetupRebase
' "$pfx" "$cur_" "${sfx- }";
            return
        ;;
        guitool.*.*)
            local pfx="${cur_%.*}.";
            cur_="${cur_##*.}";
            __gitcomp "
			argPrompt cmd confirm needsFile noConsole noRescan
			prompt revPrompt revUnmerged title
			" "$pfx" "$cur_" "$sfx";
            return
        ;;
        difftool.*.*)
            local pfx="${cur_%.*}.";
            cur_="${cur_##*.}";
            __gitcomp "cmd path" "$pfx" "$cur_" "$sfx";
            return
        ;;
        man.*.*)
            local pfx="${cur_%.*}.";
            cur_="${cur_##*.}";
            __gitcomp "cmd path" "$pfx" "$cur_" "$sfx";
            return
        ;;
        mergetool.*.*)
            local pfx="${cur_%.*}.";
            cur_="${cur_##*.}";
            __gitcomp "cmd path trustExitCode" "$pfx" "$cur_" "$sfx";
            return
        ;;
        pager.*)
            local pfx="${cur_%.*}.";
            cur_="${cur_#*.}";
            __git_compute_all_commands;
            __gitcomp_nl "$__git_all_commands" "$pfx" "$cur_" "${sfx- }";
            return
        ;;
        remote.*.*)
            local pfx="${cur_%.*}.";
            cur_="${cur_##*.}";
            __gitcomp "
			url proxy fetch push mirror skipDefaultUpdate
			receivepack uploadpack tagOpt pushurl
			" "$pfx" "$cur_" "$sfx";
            return
        ;;
        remote.*)
            local pfx="${cur_%.*}.";
            cur_="${cur_#*.}";
            __gitcomp_nl "$(__git_remotes)" "$pfx" "$cur_" ".";
            __gitcomp_nl_append "pushDefault" "$pfx" "$cur_" "${sfx- }";
            return
        ;;
        url.*.*)
            local pfx="${cur_%.*}.";
            cur_="${cur_##*.}";
            __gitcomp "insteadOf pushInsteadOf" "$pfx" "$cur_" "$sfx";
            return
        ;;
        *.*)
            __git_compute_config_vars;
            __gitcomp "$__git_config_vars" "" "$cur_" "$sfx"
        ;;
        *)
            __git_compute_config_sections;
            __gitcomp "$__git_config_sections" "" "$cur_" "."
        ;;
    esac
}
__git_complete_config_variable_name_and_value ()
{
    local cur_="$cur";
    while test $# != 0; do
        case "$1" in
            --cur=*)
                cur_="${1##--cur=}"
            ;;
            *)
                return 1
            ;;
        esac;
        shift;
    done;
    case "$cur_" in
        *=*)
            __git_complete_config_variable_value --varname="${cur_%%=*}" --cur="${cur_#*=}"
        ;;
        *)
            __git_complete_config_variable_name --cur="$cur_" --sfx='='
        ;;
    esac
}
__git_complete_config_variable_value ()
{
    local varname="$prev" cur_="$cur";
    while test $# != 0; do
        case "$1" in
            --varname=*)
                varname="${1##--varname=}"
            ;;
            --cur=*)
                cur_="${1##--cur=}"
            ;;
            *)
                return 1
            ;;
        esac;
        shift;
    done;
    if [ "${BASH_VERSINFO[0]:-0}" -ge 4 ]; then
        varname="${varname,,}";
    else
        varname="$(echo "$varname" |tr A-Z a-z)";
    fi;
    case "$varname" in
        branch.*.remote | branch.*.pushremote)
            __gitcomp_nl "$(__git_remotes)" "" "$cur_";
            return
        ;;
        branch.*.merge)
            __git_complete_refs --cur="$cur_";
            return
        ;;
        branch.*.rebase)
            __gitcomp "false true merges interactive" "" "$cur_";
            return
        ;;
        remote.pushdefault)
            __gitcomp_nl "$(__git_remotes)" "" "$cur_";
            return
        ;;
        remote.*.fetch)
            local remote="${varname#remote.}";
            remote="${remote%.fetch}";
            if [ -z "$cur_" ]; then
                __gitcomp_nl "refs/heads/" "" "" "";
                return;
            fi;
            __gitcomp_nl "$(__git_refs_remotes "$remote")" "" "$cur_";
            return
        ;;
        remote.*.push)
            local remote="${varname#remote.}";
            remote="${remote%.push}";
            __gitcomp_nl "$(__git for-each-ref 			--format='%(refname):%(refname)' refs/heads)" "" "$cur_";
            return
        ;;
        pull.twohead | pull.octopus)
            __git_compute_merge_strategies;
            __gitcomp "$__git_merge_strategies" "" "$cur_";
            return
        ;;
        color.pager)
            __gitcomp "false true" "" "$cur_";
            return
        ;;
        color.*.*)
            __gitcomp "
			normal black red green yellow blue magenta cyan white
			bold dim ul blink reverse
			" "" "$cur_";
            return
        ;;
        color.*)
            __gitcomp "false true always never auto" "" "$cur_";
            return
        ;;
        diff.submodule)
            __gitcomp "$__git_diff_submodule_formats" "" "$cur_";
            return
        ;;
        help.format)
            __gitcomp "man info web html" "" "$cur_";
            return
        ;;
        log.date)
            __gitcomp "$__git_log_date_formats" "" "$cur_";
            return
        ;;
        sendemail.aliasfiletype)
            __gitcomp "mutt mailrc pine elm gnus" "" "$cur_";
            return
        ;;
        sendemail.confirm)
            __gitcomp "$__git_send_email_confirm_options" "" "$cur_";
            return
        ;;
        sendemail.suppresscc)
            __gitcomp "$__git_send_email_suppresscc_options" "" "$cur_";
            return
        ;;
        sendemail.transferencoding)
            __gitcomp "7bit 8bit quoted-printable base64" "" "$cur_";
            return
        ;;
        *.*)
            return
        ;;
    esac
}
__git_complete_fetch_refspecs ()
{
    local i remote="$1" pfx="${2-}" cur_="${3-$cur}" sfx="${4- }";
    __gitcomp_direct "$(
		for i in $(__git_refs "$remote" "" "" "$cur_") ; do
			echo "$pfx$i:$i$sfx"
		done
		)"
}
__git_complete_file ()
{
    __git_complete_revlist_file
}
__git_complete_force_with_lease ()
{
    local cur_=$1;
    case "$cur_" in
        --*=)

        ;;
        *:*)
            __git_complete_refs --cur="${cur_#*:}"
        ;;
        *)
            __git_complete_refs --cur="$cur_"
        ;;
    esac
}
__git_complete_index_file ()
{
    local dequoted_word pfx="" cur_;
    __git_dequote "$cur";
    case "$dequoted_word" in
        ?*/*)
            pfx="${dequoted_word%/*}/";
            cur_="${dequoted_word##*/}"
        ;;
        *)
            cur_="$dequoted_word"
        ;;
    esac;
    __gitcomp_file_direct "$(__git_index_files "$1" "$pfx" "$cur_")"
}
__git_complete_refs ()
{
    local remote= dwim= pfx= cur_="$cur" sfx=" " mode="refs";
    while test $# != 0; do
        case "$1" in
            --remote=*)
                remote="${1##--remote=}"
            ;;
            --dwim)
                dwim="yes"
            ;;
            --track)
                dwim="yes"
            ;;
            --pfx=*)
                pfx="${1##--pfx=}"
            ;;
            --cur=*)
                cur_="${1##--cur=}"
            ;;
            --sfx=*)
                sfx="${1##--sfx=}"
            ;;
            --mode=*)
                mode="${1##--mode=}"
            ;;
            *)
                return 1
            ;;
        esac;
        shift;
    done;
    case "$mode" in
        refs)
            __gitcomp_direct "$(__git_refs "$remote" "" "$pfx" "$cur_" "$sfx")"
        ;;
        heads)
            __gitcomp_direct "$(__git_heads "$pfx" "$cur_" "$sfx")"
        ;;
        remote-heads)
            __gitcomp_direct "$(__git_remote_heads "$pfx" "$cur_" "$sfx")"
        ;;
        *)
            return 1
        ;;
    esac;
    if [ "$dwim" = "yes" ]; then
        __gitcomp_direct_append "$(__git_dwim_remote_heads "$pfx" "$cur_" "$sfx")";
    fi
}
__git_complete_remote_or_refspec ()
{
    local cur_="$cur" cmd="${words[__git_cmd_idx]}";
    local i c=$((__git_cmd_idx+1)) remote="" pfx="" lhs=1 no_complete_refspec=0;
    if [ "$cmd" = "remote" ]; then
        ((c++));
    fi;
    while [ $c -lt $cword ]; do
        i="${words[c]}";
        case "$i" in
            --mirror)
                [ "$cmd" = "push" ] && no_complete_refspec=1
            ;;
            -d | --delete)
                [ "$cmd" = "push" ] && lhs=0
            ;;
            --all)
                case "$cmd" in
                    push)
                        no_complete_refspec=1
                    ;;
                    fetch)
                        return
                    ;;
                    *)

                    ;;
                esac
            ;;
            --multiple)
                no_complete_refspec=1;
                break
            ;;
            -*)

            ;;
            *)
                remote="$i";
                break
            ;;
        esac;
        ((c++));
    done;
    if [ -z "$remote" ]; then
        __gitcomp_nl "$(__git_remotes)";
        return;
    fi;
    if [ $no_complete_refspec = 1 ]; then
        return;
    fi;
    [ "$remote" = "." ] && remote=;
    case "$cur_" in
        *:*)
            case "$COMP_WORDBREAKS" in
                *:*)
                    : great
                ;;
                *)
                    pfx="${cur_%%:*}:"
                ;;
            esac;
            cur_="${cur_#*:}";
            lhs=0
        ;;
        +*)
            pfx="+";
            cur_="${cur_#+}"
        ;;
    esac;
    case "$cmd" in
        fetch)
            if [ $lhs = 1 ]; then
                __git_complete_fetch_refspecs "$remote" "$pfx" "$cur_";
            else
                __git_complete_refs --pfx="$pfx" --cur="$cur_";
            fi
        ;;
        pull | remote)
            if [ $lhs = 1 ]; then
                __git_complete_refs --remote="$remote" --pfx="$pfx" --cur="$cur_";
            else
                __git_complete_refs --pfx="$pfx" --cur="$cur_";
            fi
        ;;
        push)
            if [ $lhs = 1 ]; then
                __git_complete_refs --pfx="$pfx" --cur="$cur_";
            else
                __git_complete_refs --remote="$remote" --pfx="$pfx" --cur="$cur_";
            fi
        ;;
    esac
}
__git_complete_revlist ()
{
    __git_complete_revlist_file
}
__git_complete_revlist_file ()
{
    local dequoted_word pfx ls ref cur_="$cur";
    case "$cur_" in
        *..?*:*)
            return
        ;;
        ?*:*)
            ref="${cur_%%:*}";
            cur_="${cur_#*:}";
            __git_dequote "$cur_";
            case "$dequoted_word" in
                ?*/*)
                    pfx="${dequoted_word%/*}";
                    cur_="${dequoted_word##*/}";
                    ls="$ref:$pfx";
                    pfx="$pfx/"
                ;;
                *)
                    cur_="$dequoted_word";
                    ls="$ref"
                ;;
            esac;
            case "$COMP_WORDBREAKS" in
                *:*)
                    : great
                ;;
                *)
                    pfx="$ref:$pfx"
                ;;
            esac;
            __gitcomp_file "$(__git ls-tree "$ls" 				| sed 's/^.*	//
				       s/$//')" "$pfx" "$cur_"
        ;;
        *...*)
            pfx="${cur_%...*}...";
            cur_="${cur_#*...}";
            __git_complete_refs --pfx="$pfx" --cur="$cur_"
        ;;
        *..*)
            pfx="${cur_%..*}..";
            cur_="${cur_#*..}";
            __git_complete_refs --pfx="$pfx" --cur="$cur_"
        ;;
        *)
            __git_complete_refs
        ;;
    esac
}
__git_complete_strategy ()
{
    __git_compute_merge_strategies;
    case "$prev" in
        -s | --strategy)
            __gitcomp "$__git_merge_strategies";
            return 0
        ;;
        -X)
            __gitcomp "$__git_merge_strategy_options";
            return 0
        ;;
    esac;
    case "$cur" in
        --strategy=*)
            __gitcomp "$__git_merge_strategies" "" "${cur##--strategy=}";
            return 0
        ;;
        --strategy-option=*)
            __gitcomp "$__git_merge_strategy_options" "" "${cur##--strategy-option=}";
            return 0
        ;;
    esac;
    return 1
}
__git_complete_symbol ()
{
    local tags=tags pfx="" cur_="${cur-}" sfx=" ";
    while test $# != 0; do
        case "$1" in
            --tags=*)
                tags="${1##--tags=}"
            ;;
            --pfx=*)
                pfx="${1##--pfx=}"
            ;;
            --cur=*)
                cur_="${1##--cur=}"
            ;;
            --sfx=*)
                sfx="${1##--sfx=}"
            ;;
            *)
                return 1
            ;;
        esac;
        shift;
    done;
    if test -r "$tags"; then
        __gitcomp_direct "$(__git_match_ctag "$cur_" "$tags" "$pfx" "$sfx")";
    fi
}
__git_complete_worktree_paths ()
{
    local IFS='
';
    __gitcomp_nl "$(git worktree list --porcelain |
		sed -n -e '2,$ s/^worktree //p')"
}
__git_compute_all_commands ()
{
    test -n "$__git_all_commands" || __git_all_commands=$(__git --list-cmds=main,others,alias,nohelpers)
}
__git_compute_config_sections ()
{
    test -n "$__git_config_sections" || __git_config_sections="$(git help --config-sections-for-completion)"
}
__git_compute_config_vars ()
{
    test -n "$__git_config_vars" || __git_config_vars="$(git help --config-for-completion)"
}
__git_compute_merge_strategies ()
{
    test -n "$__git_merge_strategies" || __git_merge_strategies=$(__git_list_merge_strategies)
}
__git_config_get_set_variables ()
{
    local prevword word config_file= c=$cword;
    while [ $c -gt "$__git_cmd_idx" ]; do
        word="${words[c]}";
        case "$word" in
            --system | --global | --local | --file=*)
                config_file="$word";
                break
            ;;
            -f | --file)
                config_file="$word $prevword";
                break
            ;;
        esac;
        prevword=$word;
        c=$((--c));
    done;
    __git config $config_file --name-only --list
}
__git_count_arguments ()
{
    local word i c=0;
    for ((i=$__git_cmd_idx; i < ${#words[@]}; i++))
    do
        word="${words[i]}";
        case "$word" in
            --)
                ((c = 0))
            ;;
            "$1")
                ((c = 0))
            ;;
            ?*)
                ((c++))
            ;;
        esac;
    done;
    printf "%d" $c
}
__git_dequote ()
{
    local rest="$1" len ch;
    dequoted_word="";
    while test -n "$rest"; do
        len=${#dequoted_word};
        dequoted_word="$dequoted_word${rest%%[\\\'\"]*}";
        rest="${rest:$((${#dequoted_word}-$len))}";
        case "${rest:0:1}" in
            \\)
                ch="${rest:1:1}";
                case "$ch" in
                    '
')

                    ;;
                    *)
                        dequoted_word="$dequoted_word$ch"
                    ;;
                esac;
                rest="${rest:2}"
            ;;
            \')
                rest="${rest:1}";
                len=${#dequoted_word};
                dequoted_word="$dequoted_word${rest%%\'*}";
                rest="${rest:$((${#dequoted_word}-$len+1))}"
            ;;
            \")
                rest="${rest:1}";
                while test -n "$rest"; do
                    len=${#dequoted_word};
                    dequoted_word="$dequoted_word${rest%%[\\\"]*}";
                    rest="${rest:$((${#dequoted_word}-$len))}";
                    case "${rest:0:1}" in
                        \\)
                            ch="${rest:1:1}";
                            case "$ch" in
                                \" | \\ | \$ | \`)
                                    dequoted_word="$dequoted_word$ch"
                                ;;
                                '
')

                                ;;
                                *)
                                    dequoted_word="$dequoted_word\\$ch"
                                ;;
                            esac;
                            rest="${rest:2}"
                        ;;
                        \")
                            rest="${rest:1}";
                            break
                        ;;
                    esac;
                done
            ;;
        esac;
    done
}
__git_dwim_remote_heads ()
{
    local pfx="${1-}" cur_="${2-}" sfx="${3-}";
    local fer_pfx="${pfx//\%/%%}";
    __git for-each-ref --format="$fer_pfx%(refname:strip=3)$sfx" --sort="refname:strip=3" ${GIT_COMPLETION_IGNORE_CASE+--ignore-case} "refs/remotes/*/$cur_*" "refs/remotes/*/$cur_*/**" | uniq -u
}
__git_eread ()
{
    test -r "$1" && IFS='
' read "$2" < "$1"
}
__git_find_last_on_cmdline ()
{
    local word c=$cword show_idx;
    while test $# -gt 1; do
        case "$1" in
            --show-idx)
                show_idx=y
            ;;
            *)
                return 1
            ;;
        esac;
        shift;
    done;
    local wordlist="$1";
    while [ $c -gt "$__git_cmd_idx" ]; do
        ((c--));
        for word in $wordlist;
        do
            if [ "$word" = "${words[c]}" ]; then
                if [ -n "$show_idx" ]; then
                    echo "$c $word";
                else
                    echo "$word";
                fi;
                return;
            fi;
        done;
    done
}
__git_find_on_cmdline ()
{
    local word c="$__git_cmd_idx" show_idx;
    while test $# -gt 1; do
        case "$1" in
            --show-idx)
                show_idx=y
            ;;
            *)
                return 1
            ;;
        esac;
        shift;
    done;
    local wordlist="$1";
    while [ $c -lt $cword ]; do
        for word in $wordlist;
        do
            if [ "$word" = "${words[c]}" ]; then
                if [ -n "${show_idx-}" ]; then
                    echo "$c $word";
                else
                    echo "$word";
                fi;
                return;
            fi;
        done;
        ((c++));
    done
}
__git_find_repo_path ()
{
    if [ -n "${__git_repo_path-}" ]; then
        return;
    fi;
    if [ -n "${__git_C_args-}" ]; then
        __git_repo_path="$(git "${__git_C_args[@]}" 			${__git_dir:+--git-dir="$__git_dir"} 			rev-parse --absolute-git-dir 2>/dev/null)";
    else
        if [ -n "${__git_dir-}" ]; then
            test -d "$__git_dir" && __git_repo_path="$__git_dir";
        else
            if [ -n "${GIT_DIR-}" ]; then
                test -d "$GIT_DIR" && __git_repo_path="$GIT_DIR";
            else
                if [ -d .git ]; then
                    __git_repo_path=.git;
                else
                    __git_repo_path="$(git rev-parse --git-dir 2>/dev/null)";
                fi;
            fi;
        fi;
    fi
}
__git_func_wrap ()
{
    local cur words cword prev;
    local __git_cmd_idx=0;
    _get_comp_words_by_ref -n =: cur words cword prev;
    $1
}
__git_get_config_variables ()
{
    local section="$1" i IFS='
';
    for i in $(__git config --name-only --get-regexp "^$section\..*");
    do
        echo "${i#$section.}";
    done
}
__git_get_option_value ()
{
    local c short_opt long_opt val;
    local result= values config_key word;
    short_opt="$1";
    long_opt="$2";
    values="$3";
    config_key="$4";
    ((c = $cword - 1));
    while [ $c -ge 0 ]; do
        word="${words[c]}";
        for val in $values;
        do
            if [ "$short_opt$val" = "$word" ] || [ "$long_opt$val" = "$word" ]; then
                result="$val";
                break 2;
            fi;
        done;
        ((c--));
    done;
    if [ -n "$config_key" ] && [ -z "$result" ]; then
        result="$(__git config "$config_key")";
    fi;
    echo "$result"
}
__git_has_doubledash ()
{
    local c=1;
    while [ $c -lt $cword ]; do
        if [ "--" = "${words[c]}" ]; then
            return 0;
        fi;
        ((c++));
    done;
    return 1
}
__git_have_func ()
{
    declare -f -- "$1" > /dev/null 2>&1
}
__git_heads ()
{
    local pfx="${1-}" cur_="${2-}" sfx="${3-}";
    __git for-each-ref --format="${pfx//\%/%%}%(refname:strip=2)$sfx" ${GIT_COMPLETION_IGNORE_CASE+--ignore-case} "refs/heads/$cur_*" "refs/heads/$cur_*/**"
}
__git_index_files ()
{
    local root="$2" match="$3";
    __git_ls_files_helper "$root" "$1" "${match:-?}" | awk -F / -v pfx="${2//\\/\\\\}" '{
		paths[$1] = 1
	}
	END {
		for (p in paths) {
			if (substr(p, 1, 1) != "\"") {
				# No special characters, easy!
				print pfx p
				continue
			}

			# The path is quoted.
			p = dequote(p)
			if (p == "")
				continue

			# Even when a directory name itself does not contain
			# any special characters, it will still be quoted if
			# any of its (stripped) trailing path components do.
			# Because of this we may have seen the same directory
			# both quoted and unquoted.
			if (p in paths)
				# We have seen the same directory unquoted,
				# skip it.
				continue
			else
				print pfx p
		}
	}
	function dequote(p,    bs_idx, out, esc, esc_idx, dec) {
		# Skip opening double quote.
		p = substr(p, 2)

		# Interpret backslash escape sequences.
		while ((bs_idx = index(p, "\\")) != 0) {
			out = out substr(p, 1, bs_idx - 1)
			esc = substr(p, bs_idx + 1, 1)
			p = substr(p, bs_idx + 2)

			if ((esc_idx = index("abtvfr\"\\", esc)) != 0) {
				# C-style one-character escape sequence.
				out = out substr("\a\b\t\v\f\r\"\\",
						 esc_idx, 1)
			} else if (esc == "n") {
				# Uh-oh, a newline character.
				# We cannot reliably put a pathname
				# containing a newline into COMPREPLY,
				# and the newline would create a mess.
				# Skip this path.
				return ""
			} else {
				# Must be a \nnn octal value, then.
				dec = esc             * 64 + \
				      substr(p, 1, 1) * 8  + \
				      substr(p, 2, 1)
				out = out sprintf("%c", dec)
				p = substr(p, 3)
			}
		}
		# Drop closing double quote, if there is one.
		# (There is not any if this is a directory, as it was
		# already stripped with the trailing path components.)
		if (substr(p, length(p), 1) == "\"")
			out = out substr(p, 1, length(p) - 1)
		else
			out = out p

		return out
	}'
}
__git_is_configured_remote ()
{
    local remote;
    for remote in $(__git_remotes);
    do
        if [ "$remote" = "$1" ]; then
            return 0;
        fi;
    done;
    return 1
}
__git_list_merge_strategies ()
{
    LANG=C LC_ALL=C git merge -s help 2>&1 | sed -n -e '/[Aa]vailable strategies are: /,/^$/{
		s/\.$//
		s/.*://
		s/^[ 	]*//
		s/[ 	]*$//
		p
	}'
}
__git_ls_files_helper ()
{
    if [ "$2" = "--committable" ]; then
        __git -C "$1" -c core.quotePath=false diff-index --name-only --relative HEAD -- "${3//\\/\\\\}*";
    else
        __git -C "$1" -c core.quotePath=false ls-files --exclude-standard $2 -- "${3//\\/\\\\}*";
    fi
}
__git_main ()
{
    local i c=1 command __git_dir __git_repo_path;
    local __git_C_args C_args_count=0;
    local __git_cmd_idx;
    while [ $c -lt $cword ]; do
        i="${words[c]}";
        case "$i" in
            --git-dir=*)
                __git_dir="${i#--git-dir=}"
            ;;
            --git-dir)
                ((c++));
                __git_dir="${words[c]}"
            ;;
            --bare)
                __git_dir="."
            ;;
            --help)
                command="help";
                break
            ;;
            -c | --work-tree | --namespace)
                ((c++))
            ;;
            -C)
                __git_C_args[C_args_count++]=-C;
                ((c++));
                __git_C_args[C_args_count++]="${words[c]}"
            ;;
            -*)

            ;;
            *)
                command="$i";
                __git_cmd_idx="$c";
                break
            ;;
        esac;
        ((c++));
    done;
    if [ -z "${command-}" ]; then
        case "$prev" in
            --git-dir | -C | --work-tree)
                return
            ;;
            -c)
                __git_complete_config_variable_name_and_value;
                return
            ;;
            --namespace)
                return
            ;;
        esac;
        case "$cur" in
            --*)
                __gitcomp "
			--paginate
			--no-pager
			--git-dir=
			--bare
			--version
			--exec-path
			--exec-path=
			--html-path
			--man-path
			--info-path
			--work-tree=
			--namespace=
			--no-replace-objects
			--help
			"
            ;;
            *)
                if test -n "${GIT_TESTING_PORCELAIN_COMMAND_LIST-}"; then
                    __gitcomp "$GIT_TESTING_PORCELAIN_COMMAND_LIST";
                else
                    local list_cmds=list-mainporcelain,others,nohelpers,alias,list-complete,config;
                    if test "${GIT_COMPLETION_SHOW_ALL_COMMANDS-}" = "1"; then
                        list_cmds=builtins,$list_cmds;
                    fi;
                    __gitcomp "$(__git --list-cmds=$list_cmds)";
                fi
            ;;
        esac;
        return;
    fi;
    __git_complete_command "$command" && return;
    local expansion=$(__git_aliased_command "$command");
    if [ -n "$expansion" ]; then
        words[1]=$expansion;
        __git_complete_command "$expansion";
    fi
}
__git_match_ctag ()
{
    awk -v pfx="${3-}" -v sfx="${4-}" "
		/^${1//\//\\/}/ { print pfx \$1 sfx }
		" "$2"
}
__git_pretty_aliases ()
{
    __git_get_config_variables "pretty"
}
__git_ps1 ()
{
    local exit=$?;
    local pcmode=no;
    local detached=no;
    local ps1pc_start='\u@\h:\w ';
    local ps1pc_end='\$ ';
    local printf_format=' (%s)';
    case "$#" in
        2 | 3)
            pcmode=yes;
            ps1pc_start="$1";
            ps1pc_end="$2";
            printf_format="${3:-$printf_format}";
            PS1="$ps1pc_start$ps1pc_end"
        ;;
        0 | 1)
            printf_format="${1:-$printf_format}"
        ;;
        *)
            return $exit
        ;;
    esac;
    local ps1_expanded=yes;
    [ -z "${ZSH_VERSION-}" ] || [[ -o PROMPT_SUBST ]] || ps1_expanded=no;
    [ -z "${BASH_VERSION-}" ] || shopt -q promptvars || ps1_expanded=no;
    local repo_info rev_parse_exit_code;
    repo_info="$(git rev-parse --git-dir --is-inside-git-dir 		--is-bare-repository --is-inside-work-tree 		--short HEAD 2>/dev/null)";
    rev_parse_exit_code="$?";
    if [ -z "$repo_info" ]; then
        return $exit;
    fi;
    local short_sha="";
    if [ "$rev_parse_exit_code" = "0" ]; then
        short_sha="${repo_info##*
}";
        repo_info="${repo_info%
*}";
    fi;
    local inside_worktree="${repo_info##*
}";
    repo_info="${repo_info%
*}";
    local bare_repo="${repo_info##*
}";
    repo_info="${repo_info%
*}";
    local inside_gitdir="${repo_info##*
}";
    local g="${repo_info%
*}";
    if [ "true" = "$inside_worktree" ] && [ -n "${GIT_PS1_HIDE_IF_PWD_IGNORED-}" ] && [ "$(git config --bool bash.hideIfPwdIgnored)" != "false" ] && git check-ignore -q .; then
        return $exit;
    fi;
    local sparse="";
    if [ -z "${GIT_PS1_COMPRESSSPARSESTATE-}" ] && [ -z "${GIT_PS1_OMITSPARSESTATE-}" ] && [ "$(git config --bool core.sparseCheckout)" = "true" ]; then
        sparse="|SPARSE";
    fi;
    local r="";
    local b="";
    local step="";
    local total="";
    if [ -d "$g/rebase-merge" ]; then
        __git_eread "$g/rebase-merge/head-name" b;
        __git_eread "$g/rebase-merge/msgnum" step;
        __git_eread "$g/rebase-merge/end" total;
        r="|REBASE";
    else
        if [ -d "$g/rebase-apply" ]; then
            __git_eread "$g/rebase-apply/next" step;
            __git_eread "$g/rebase-apply/last" total;
            if [ -f "$g/rebase-apply/rebasing" ]; then
                __git_eread "$g/rebase-apply/head-name" b;
                r="|REBASE";
            else
                if [ -f "$g/rebase-apply/applying" ]; then
                    r="|AM";
                else
                    r="|AM/REBASE";
                fi;
            fi;
        else
            if [ -f "$g/MERGE_HEAD" ]; then
                r="|MERGING";
            else
                if __git_sequencer_status; then
                    :;
                else
                    if [ -f "$g/BISECT_LOG" ]; then
                        r="|BISECTING";
                    fi;
                fi;
            fi;
        fi;
        if [ -n "$b" ]; then
            :;
        else
            if [ -h "$g/HEAD" ]; then
                b="$(git symbolic-ref HEAD 2>/dev/null)";
            else
                local head="";
                if ! __git_eread "$g/HEAD" head; then
                    return $exit;
                fi;
                b="${head#ref: }";
                if [ "$head" = "$b" ]; then
                    detached=yes;
                    b="$(
				case "${GIT_PS1_DESCRIBE_STYLE-}" in
				(contains)
					git describe --contains HEAD ;;
				(branch)
					git describe --contains --all HEAD ;;
				(tag)
					git describe --tags HEAD ;;
				(describe)
					git describe HEAD ;;
				(* | default)
					git describe --tags --exact-match HEAD ;;
				esac 2>/dev/null)" || b="$short_sha...";
                    b="($b)";
                fi;
            fi;
        fi;
    fi;
    if [ -n "$step" ] && [ -n "$total" ]; then
        r="$r $step/$total";
    fi;
    local conflict="";
    if [[ "${GIT_PS1_SHOWCONFLICTSTATE}" == "yes" ]] && [[ -n $(git ls-files --unmerged 2>/dev/null) ]]; then
        conflict="|CONFLICT";
    fi;
    local w="";
    local i="";
    local s="";
    local u="";
    local h="";
    local c="";
    local p="";
    local upstream="";
    if [ "true" = "$inside_gitdir" ]; then
        if [ "true" = "$bare_repo" ]; then
            c="BARE:";
        else
            b="GIT_DIR!";
        fi;
    else
        if [ "true" = "$inside_worktree" ]; then
            if [ -n "${GIT_PS1_SHOWDIRTYSTATE-}" ] && [ "$(git config --bool bash.showDirtyState)" != "false" ]; then
                git diff --no-ext-diff --quiet || w="*";
                git diff --no-ext-diff --cached --quiet || i="+";
                if [ -z "$short_sha" ] && [ -z "$i" ]; then
                    i="#";
                fi;
            fi;
            if [ -n "${GIT_PS1_SHOWSTASHSTATE-}" ] && git rev-parse --verify --quiet refs/stash > /dev/null; then
                s="$";
            fi;
            if [ -n "${GIT_PS1_SHOWUNTRACKEDFILES-}" ] && [ "$(git config --bool bash.showUntrackedFiles)" != "false" ] && git ls-files --others --exclude-standard --directory --no-empty-directory --error-unmatch -- ':/*' > /dev/null 2> /dev/null; then
                u="%${ZSH_VERSION+%}";
            fi;
            if [ -n "${GIT_PS1_COMPRESSSPARSESTATE-}" ] && [ "$(git config --bool core.sparseCheckout)" = "true" ]; then
                h="?";
            fi;
            if [ -n "${GIT_PS1_SHOWUPSTREAM-}" ]; then
                __git_ps1_show_upstream;
            fi;
        fi;
    fi;
    local z="${GIT_PS1_STATESEPARATOR-" "}";
    b=${b##refs/heads/};
    if [ $pcmode = yes ] && [ $ps1_expanded = yes ]; then
        __git_ps1_branch_name=$b;
        b="\${__git_ps1_branch_name}";
    fi;
    if [ -n "${GIT_PS1_SHOWCOLORHINTS-}" ]; then
        if [ $pcmode = yes ] || [ -n "${ZSH_VERSION-}" ]; then
            __git_ps1_colorize_gitstring;
        fi;
    fi;
    local f="$h$w$i$s$u$p";
    local gitstring="$c$b${f:+$z$f}${sparse}$r${upstream}${conflict}";
    if [ $pcmode = yes ]; then
        if [ "${__git_printf_supports_v-}" != yes ]; then
            gitstring=$(printf -- "$printf_format" "$gitstring");
        else
            printf -v gitstring -- "$printf_format" "$gitstring";
        fi;
        PS1="$ps1pc_start$gitstring$ps1pc_end";
    else
        printf -- "$printf_format" "$gitstring";
    fi;
    return $exit
}
__git_ps1_colorize_gitstring ()
{
    if [[ -n ${ZSH_VERSION-} ]]; then
        local c_red='%F{red}';
        local c_green='%F{green}';
        local c_lblue='%F{blue}';
        local c_clear='%f';
    else
        local c_red='\[\e[31m\]';
        local c_green='\[\e[32m\]';
        local c_lblue='\[\e[1;34m\]';
        local c_clear='\[\e[0m\]';
    fi;
    local bad_color=$c_red;
    local ok_color=$c_green;
    local flags_color="$c_lblue";
    local branch_color="";
    if [ $detached = no ]; then
        branch_color="$ok_color";
    else
        branch_color="$bad_color";
    fi;
    if [ -n "$c" ]; then
        c="$branch_color$c$c_clear";
    fi;
    b="$branch_color$b$c_clear";
    if [ -n "$w" ]; then
        w="$bad_color$w$c_clear";
    fi;
    if [ -n "$i" ]; then
        i="$ok_color$i$c_clear";
    fi;
    if [ -n "$s" ]; then
        s="$flags_color$s$c_clear";
    fi;
    if [ -n "$u" ]; then
        u="$bad_color$u$c_clear";
    fi
}
__git_ps1_show_upstream ()
{
    local key value;
    local svn_remote svn_url_pattern count n;
    local upstream_type=git legacy="" verbose="" name="";
    svn_remote=();
    local output="$(git config -z --get-regexp '^(svn-remote\..*\.url|bash\.showupstream)$' 2>/dev/null | tr '\0\n' '\n ')";
    while read -r key value; do
        case "$key" in
            bash.showupstream)
                GIT_PS1_SHOWUPSTREAM="$value";
                if [[ -z "${GIT_PS1_SHOWUPSTREAM}" ]]; then
                    p="";
                    return;
                fi
            ;;
            svn-remote.*.url)
                svn_remote[$((${#svn_remote[@]} + 1))]="$value";
                svn_url_pattern="$svn_url_pattern\\|$value";
                upstream_type=svn+git
            ;;
        esac;
    done <<< "$output";
    local option;
    for option in ${GIT_PS1_SHOWUPSTREAM};
    do
        case "$option" in
            git | svn)
                upstream_type="$option"
            ;;
            verbose)
                verbose=1
            ;;
            legacy)
                legacy=1
            ;;
            name)
                name=1
            ;;
        esac;
    done;
    case "$upstream_type" in
        git)
            upstream_type="@{upstream}"
        ;;
        svn*)
            local -a svn_upstream;
            svn_upstream=($(git log --first-parent -1 					--grep="^git-svn-id: \(${svn_url_pattern#??}\)" 2>/dev/null));
            if [[ 0 -ne ${#svn_upstream[@]} ]]; then
                svn_upstream=${svn_upstream[${#svn_upstream[@]} - 2]};
                svn_upstream=${svn_upstream%@*};
                local n_stop="${#svn_remote[@]}";
                for ((n=1; n <= n_stop; n++))
                do
                    svn_upstream=${svn_upstream#${svn_remote[$n]}};
                done;
                if [[ -z "$svn_upstream" ]]; then
                    upstream_type=${GIT_SVN_ID:-git-svn};
                else
                    upstream_type=${svn_upstream#/};
                fi;
            else
                if [[ "svn+git" = "$upstream_type" ]]; then
                    upstream_type="@{upstream}";
                fi;
            fi
        ;;
    esac;
    if [[ -z "$legacy" ]]; then
        count="$(git rev-list --count --left-right 				"$upstream_type"...HEAD 2>/dev/null)";
    else
        local commits;
        if commits="$(git rev-list --left-right "$upstream_type"...HEAD 2>/dev/null)"; then
            local commit behind=0 ahead=0;
            for commit in $commits;
            do
                case "$commit" in
                    "<"*)
                        ((behind++))
                    ;;
                    *)
                        ((ahead++))
                    ;;
                esac;
            done;
            count="$behind	$ahead";
        else
            count="";
        fi;
    fi;
    if [[ -z "$verbose" ]]; then
        case "$count" in
            "")
                p=""
            ;;
            "0	0")
                p="="
            ;;
            "0	"*)
                p=">"
            ;;
            *"	0")
                p="<"
            ;;
            *)
                p="<>"
            ;;
        esac;
    else
        case "$count" in
            "")
                upstream=""
            ;;
            "0	0")
                upstream="|u="
            ;;
            "0	"*)
                upstream="|u+${count#0	}"
            ;;
            *"	0")
                upstream="|u-${count%	0}"
            ;;
            *)
                upstream="|u+${count#*	}-${count%	*}"
            ;;
        esac;
        if [[ -n "$count" && -n "$name" ]]; then
            __git_ps1_upstream_name=$(git rev-parse 				--abbrev-ref "$upstream_type" 2>/dev/null);
            if [ $pcmode = yes ] && [ $ps1_expanded = yes ]; then
                upstream="$upstream \${__git_ps1_upstream_name}";
            else
                upstream="$upstream ${__git_ps1_upstream_name}";
                unset __git_ps1_upstream_name;
            fi;
        fi;
    fi
}
__git_reassemble_comp_words_by_ref ()
{
    local exclude i j first;
    exclude="${1//[^$COMP_WORDBREAKS]}";
    cword_=$COMP_CWORD;
    if [ -z "$exclude" ]; then
        words_=("${COMP_WORDS[@]}");
        return;
    fi;
    for ((i=0, j=0; i < ${#COMP_WORDS[@]}; i++, j++))
    do
        first=t;
        while [ $i -gt 0 ] && [ -n "${COMP_WORDS[$i]}" ] && [ "${COMP_WORDS[$i]//[^$exclude]}" = "${COMP_WORDS[$i]}" ]; do
            if [ $j -ge 2 ] && [ -n "$first" ]; then
                ((j--));
            fi;
            first=;
            words_[$j]=${words_[j]}${COMP_WORDS[i]};
            if [ $i = $COMP_CWORD ]; then
                cword_=$j;
            fi;
            if (($i < ${#COMP_WORDS[@]} - 1)); then
                ((i++));
            else
                return;
            fi;
        done;
        words_[$j]=${words_[j]}${COMP_WORDS[i]};
        if [ $i = $COMP_CWORD ]; then
            cword_=$j;
        fi;
    done
}
__git_refs ()
{
    local i hash dir track="${2-}";
    local list_refs_from=path remote="${1-}";
    local format refs;
    local pfx="${3-}" cur_="${4-$cur}" sfx="${5-}";
    local match="${4-}";
    local umatch="${4-}";
    local fer_pfx="${pfx//\%/%%}";
    __git_find_repo_path;
    dir="$__git_repo_path";
    if [ -z "$remote" ]; then
        if [ -z "$dir" ]; then
            return;
        fi;
    else
        if __git_is_configured_remote "$remote"; then
            list_refs_from=remote;
        else
            if [ -d "$remote/.git" ]; then
                dir="$remote/.git";
            else
                if [ -d "$remote" ]; then
                    dir="$remote";
                else
                    list_refs_from=url;
                fi;
            fi;
        fi;
    fi;
    if test "${GIT_COMPLETION_IGNORE_CASE:+1}" = "1"; then
        umatch=$(echo "$match" | tr a-z A-Z 2>/dev/null || echo "$match");
    fi;
    if [ "$list_refs_from" = path ]; then
        if [[ "$cur_" == ^* ]]; then
            pfx="$pfx^";
            fer_pfx="$fer_pfx^";
            cur_=${cur_#^};
            match=${match#^};
            umatch=${umatch#^};
        fi;
        case "$cur_" in
            refs | refs/*)
                format="refname";
                refs=("$match*" "$match*/**");
                track=""
            ;;
            *)
                for i in HEAD FETCH_HEAD ORIG_HEAD MERGE_HEAD REBASE_HEAD CHERRY_PICK_HEAD;
                do
                    case "$i" in
                        $match* | $umatch*)
                            if [ -e "$dir/$i" ]; then
                                echo "$pfx$i$sfx";
                            fi
                        ;;
                    esac;
                done;
                format="refname:strip=2";
                refs=("refs/tags/$match*" "refs/tags/$match*/**" "refs/heads/$match*" "refs/heads/$match*/**" "refs/remotes/$match*" "refs/remotes/$match*/**")
            ;;
        esac;
        __git_dir="$dir" __git for-each-ref --format="$fer_pfx%($format)$sfx" ${GIT_COMPLETION_IGNORE_CASE+--ignore-case} "${refs[@]}";
        if [ -n "$track" ]; then
            __git_dwim_remote_heads "$pfx" "$match" "$sfx";
        fi;
        return;
    fi;
    case "$cur_" in
        refs | refs/*)
            __git ls-remote "$remote" "$match*" | while read -r hash i; do
                case "$i" in
                    *^{})

                    ;;
                    *)
                        echo "$pfx$i$sfx"
                    ;;
                esac;
            done
        ;;
        *)
            if [ "$list_refs_from" = remote ]; then
                case "HEAD" in
                    $match* | $umatch*)
                        echo "${pfx}HEAD$sfx"
                    ;;
                esac;
                __git for-each-ref --format="$fer_pfx%(refname:strip=3)$sfx" ${GIT_COMPLETION_IGNORE_CASE+--ignore-case} "refs/remotes/$remote/$match*" "refs/remotes/$remote/$match*/**";
            else
                local query_symref;
                case "HEAD" in
                    $match* | $umatch*)
                        query_symref="HEAD"
                    ;;
                esac;
                __git ls-remote "$remote" $query_symref "refs/tags/$match*" "refs/heads/$match*" "refs/remotes/$match*" | while read -r hash i; do
                    case "$i" in
                        *^{})

                        ;;
                        refs/*)
                            echo "$pfx${i#refs/*/}$sfx"
                        ;;
                        *)
                            echo "$pfx$i$sfx"
                        ;;
                    esac;
                done;
            fi
        ;;
    esac
}
__git_refs2 ()
{
    local i;
    for i in $(__git_refs "$1");
    do
        echo "$i:$i";
    done
}
__git_refs_remotes ()
{
    local i hash;
    __git ls-remote "$1" 'refs/heads/*' | while read -r hash i; do
        echo "$i:refs/remotes/$1/${i#refs/heads/}";
    done
}
__git_remote_heads ()
{
    local pfx="${1-}" cur_="${2-}" sfx="${3-}";
    __git for-each-ref --format="${pfx//\%/%%}%(refname:strip=2)$sfx" ${GIT_COMPLETION_IGNORE_CASE+--ignore-case} "refs/remotes/$cur_*" "refs/remotes/$cur_*/**"
}
__git_remotes ()
{
    __git_find_repo_path;
    test -d "$__git_repo_path/remotes" && ls -1 "$__git_repo_path/remotes";
    __git remote
}
__git_sequencer_status ()
{
    local todo;
    if test -f "$g/CHERRY_PICK_HEAD"; then
        r="|CHERRY-PICKING";
        return 0;
    else
        if test -f "$g/REVERT_HEAD"; then
            r="|REVERTING";
            return 0;
        else
            if __git_eread "$g/sequencer/todo" todo; then
                case "$todo" in
                    p[\ \	] | pick[\ \	]*)
                        r="|CHERRY-PICKING";
                        return 0
                    ;;
                    revert[\ \	]*)
                        r="|REVERTING";
                        return 0
                    ;;
                esac;
            fi;
        fi;
    fi;
    return 1
}
__git_support_parseopt_helper ()
{
    test -n "$__git_cmds_with_parseopt_helper" || __git_cmds_with_parseopt_helper="$(__git --list-cmds=parseopt)";
    case " $__git_cmds_with_parseopt_helper " in
        *" $1 "*)
            return 0
        ;;
        *)
            return 1
        ;;
    esac
}
__git_tags ()
{
    local pfx="${1-}" cur_="${2-}" sfx="${3-}";
    __git for-each-ref --format="${pfx//\%/%%}%(refname:strip=2)$sfx" ${GIT_COMPLETION_IGNORE_CASE+--ignore-case} "refs/tags/$cur_*" "refs/tags/$cur_*/**"
}
__git_wrap__git_main ()
{
    __git_func_wrap __git_main
}
__git_wrap__gitk_main ()
{
    __git_func_wrap __gitk_main
}
__gitcomp ()
{
    local cur_="${3-$cur}";
    case "$cur_" in
        *=)

        ;;
        --no-*)
            local c i=0 IFS='
';
            for c in $1;
            do
                if [[ $c == "--" ]]; then
                    continue;
                fi;
                c="$c${4-}";
                if [[ $c == "$cur_"* ]]; then
                    case $c in
                        --*= | *.)

                        ;;
                        *)
                            c="$c "
                        ;;
                    esac;
                    COMPREPLY[i++]="${2-}$c";
                fi;
            done
        ;;
        *)
            local c i=0 IFS='
';
            for c in $1;
            do
                if [[ $c == "--" ]]; then
                    c="--no-...${4-}";
                    if [[ $c == "$cur_"* ]]; then
                        COMPREPLY[i++]="${2-}$c ";
                    fi;
                    break;
                fi;
                c="$c${4-}";
                if [[ $c == "$cur_"* ]]; then
                    case $c in
                        *= | *.)

                        ;;
                        *)
                            c="$c "
                        ;;
                    esac;
                    COMPREPLY[i++]="${2-}$c";
                fi;
            done
        ;;
    esac
}
__gitcomp_builtin ()
{
    local cmd="$1";
    local incl="${2-}";
    local excl="${3-}";
    local var=__gitcomp_builtin_"${cmd//-/_}";
    local options;
    eval "options=\${$var-}";
    if [ -z "$options" ]; then
        local completion_helper;
        if [ "${GIT_COMPLETION_SHOW_ALL-}" = "1" ]; then
            completion_helper="--git-completion-helper-all";
        else
            completion_helper="--git-completion-helper";
        fi;
        options=" $incl $(__git ${cmd/_/ } $completion_helper) " || return;
        for i in $excl;
        do
            options="${options/ $i / }";
        done;
        eval "$var=\"$options\"";
    fi;
    __gitcomp "$options"
}
__gitcomp_direct ()
{
    local IFS='
';
    COMPREPLY=($1)
}
__gitcomp_direct_append ()
{
    local IFS='
';
    COMPREPLY+=($1)
}
__gitcomp_directories ()
{
    local _tmp_dir _tmp_completions _found=0;
    [[ "$cur" =~ .*/ ]];
    _tmp_dir=$BASH_REMATCH;
    while IFS= read -r -d '' c; do
        if [[ $c == "$cur"* ]]; then
            COMPREPLY+=("$c/");
            _found=1;
        fi;
    done < <(git ls-tree -z -d --name-only HEAD $_tmp_dir);
    if [[ $_found == 0 ]] && [[ "$cur" =~ /$ ]]; then
        __gitcomp_direct_append "$cur ";
    fi
}
__gitcomp_file ()
{
    local IFS='
';
    __gitcompadd "$1" "${2-}" "${3-$cur}" "";
    compopt -o filenames +o nospace 2> /dev/null || compgen -f /non-existing-dir/ > /dev/null || true
}
__gitcomp_file_direct ()
{
    local IFS='
';
    COMPREPLY=($1);
    compopt -o filenames +o nospace 2> /dev/null || compgen -f /non-existing-dir/ > /dev/null || true
}
__gitcomp_nl ()
{
    COMPREPLY=();
    __gitcomp_nl_append "$@"
}
__gitcomp_nl_append ()
{
    local IFS='
';
    __gitcompappend "$1" "${2-}" "${3-$cur}" "${4- }"
}
__gitcompadd ()
{
    COMPREPLY=();
    __gitcompappend "$@"
}
__gitcompappend ()
{
    local x i=${#COMPREPLY[@]};
    for x in $1;
    do
        if [[ "$x" == "$3"* ]]; then
            COMPREPLY[i++]="$2$x$4";
        fi;
    done
}
__gitdir ()
{
    if [ -z "${1-}" ]; then
        __git_find_repo_path || return 1;
        echo "$__git_repo_path";
    else
        if [ -d "$1/.git" ]; then
            echo "$1/.git";
        else
            echo "$1";
        fi;
    fi
}
__gitk_main ()
{
    __git_has_doubledash && return;
    local __git_repo_path;
    __git_find_repo_path;
    local merge="";
    if [ -f "$__git_repo_path/MERGE_HEAD" ]; then
        merge="--merge";
    fi;
    case "$cur" in
        --*)
            __gitcomp "
			$__git_log_common_options
			$__git_log_gitk_options
			$merge
			";
            return
        ;;
    esac;
    __git_complete_revlist
}
__gresource ()
{
    local choices coffset section;
    if [ ${COMP_CWORD} -gt 2 ]; then
        if [ ${COMP_WORDS[1]} = --section ]; then
            section=${COMP_WORDS[2]};
            coffset=2;
        else
            coffset=0;
        fi;
    else
        coffset=0;
    fi;
    case "$((${COMP_CWORD}-$coffset))" in
        1)
            choices='--section
help
sections
list
details
extract '
        ;;
        2)
            case "${COMP_WORDS[$(($coffset+1))]}" in
                --section)
                    return 0
                ;;
                help)
                    choices='sections
list
details
extract'
                ;;
                sections | list | details | extract)
                    COMPREPLY=($(compgen -f -- ${COMP_WORDS[${COMP_CWORD}]}));
                    return 0
                ;;
            esac
        ;;
        3)
            case "${COMP_WORDS[$(($coffset+1))]}" in
                list | details | extract)
                    choices="$(gresource list ${COMP_WORDS[$(($coffset+2))]} 2> /dev/null | sed -e 's.$. .')"
                ;;
            esac
        ;;
    esac;
    local IFS='
';
    COMPREPLY=($(compgen -W "${choices}" -- "${COMP_WORDS[${COMP_CWORD}]}"))
}
__gsettings ()
{
    local choices coffset schemadir;
    if [ ${COMP_CWORD} -gt 2 ]; then
        if [ ${COMP_WORDS[1]} = --schemadir ]; then
            schemadir=$(eval "echo --schemadir ${COMP_WORDS[2]}");
            coffset=2;
        else
            coffset=0;
        fi;
    else
        coffset=0;
    fi;
    case "$((${COMP_CWORD}-$coffset))" in
        1)
            choices='--schemadir
--version
help
list-schemas
list-relocatable-schemas
list-keys
list-children
list-recursively
get
range
set
reset
reset-recursively
writable
monitor
describe '
        ;;
        2)
            case "${COMP_WORDS[$(($coffset+1))]}" in
                --schemadir)
                    COMPREPLY=($(compgen -o dirnames -- ${COMP_WORDS[${COMP_CWORD}]}));
                    return 0
                ;;
                help)
                    choices='list-schemas
list-relocatable-schemas
list-keys
list-children
list-recursively
get
range
set
reset
reset-recursively
writable
monitor'
                ;;
                list-keys | list-children | list-recursively | reset-recursively)
                    choices="$(gsettings $schemadir list-schemas 2> /dev/null)"'
'"$(gsettings $schemadir list-relocatable-schemas 2> /dev/null | sed -e 's.$.:/.')"
                ;;
                list-schemas)
                    COMPREPLY=($(compgen -W "--print-paths" -- ${COMP_WORDS[${COMP_CWORD}]}));
                    return 0
                ;;
                get | range | set | reset | writable | monitor | describe)
                    choices="$(gsettings $schemadir list-schemas 2> /dev/null | sed -e 's.$. .')"'
'"$(gsettings $schemadir list-relocatable-schemas 2> /dev/null | sed -e 's.$.:/.')"
                ;;
            esac
        ;;
        3)
            case "${COMP_WORDS[$(($coffset+1))]}" in
                set)
                    choices="$(gsettings $schemadir list-keys ${COMP_WORDS[$(($coffset+2))]} 2> /dev/null | sed -e 's.$. .')"
                ;;
                get | range | reset | writable | monitor | describe)
                    choices="$(gsettings $schemadir list-keys ${COMP_WORDS[$(($coffset+2))]} 2> /dev/null)"
                ;;
            esac
        ;;
        4)
            case "${COMP_WORDS[$(($coffset+2))]}" in
                set)
                    range=($(gsettings $schemadir range ${COMP_WORDS[$(($coffset+2))]} ${COMP_WORDS[$(($coffset+3))]} 2> /dev/null));
                    case "${range[0]}" in
                        enum)
                            unset range[0]
                        ;;
                        *)
                            unset range
                        ;;
                    esac;
                    local IFS='
';
                    choices="${range[*]}"
                ;;
            esac
        ;;
    esac;
    local IFS='
';
    COMPREPLY=($(compgen -W "${choices}" -- "${COMP_WORDS[${COMP_CWORD}]}"))
}
__gum_contains_word ()
{
    local w word=$1;
    shift;
    for w in "$@";
    do
        [[ $w = "$word" ]] && return;
    done;
    return 1
}
__gum_debug ()
{
    if [[ -n ${BASH_COMP_DEBUG_FILE:-} ]]; then
        echo "$*" >> "${BASH_COMP_DEBUG_FILE}";
    fi
}
__gum_handle_command ()
{
    __gum_debug "${FUNCNAME[0]}: c is $c words[c] is ${words[c]}";
    local next_command;
    if [[ -n ${last_command} ]]; then
        next_command="_${last_command}_${words[c]//:/__}";
    else
        if [[ $c -eq 0 ]]; then
            next_command="_gum_root_command";
        else
            next_command="_${words[c]//:/__}";
        fi;
    fi;
    c=$((c+1));
    __gum_debug "${FUNCNAME[0]}: looking for ${next_command}";
    declare -F "$next_command" > /dev/null && $next_command
}
__gum_handle_filename_extension_flag ()
{
    local ext="$1";
    _filedir "@(${ext})"
}
__gum_handle_flag ()
{
    __gum_debug "${FUNCNAME[0]}: c is $c words[c] is ${words[c]}";
    local flagname=${words[c]};
    local flagvalue="";
    if [[ ${words[c]} == *"="* ]]; then
        flagvalue=${flagname#*=};
        flagname=${flagname%=*};
        flagname="${flagname}=";
    fi;
    __gum_debug "${FUNCNAME[0]}: looking for ${flagname}";
    if __gum_contains_word "${flagname}" "${must_have_one_flag[@]}"; then
        must_have_one_flag=();
    fi;
    if __gum_contains_word "${flagname}" "${local_nonpersistent_flags[@]}"; then
        commands=();
    fi;
    if [[ -z "${BASH_VERSION:-}" || "${BASH_VERSINFO[0]:-}" -gt 3 ]]; then
        if [ -n "${flagvalue}" ]; then
            flaghash[${flagname}]=${flagvalue};
        else
            if [ -n "${words[ $((c+1)) ]}" ]; then
                flaghash[${flagname}]=${words[ $((c+1)) ]};
            else
                flaghash[${flagname}]="true";
            fi;
        fi;
    fi;
    if [[ ${words[c]} != *"="* ]] && __gum_contains_word "${words[c]}" "${two_word_flags[@]}"; then
        __gum_debug "${FUNCNAME[0]}: found a flag ${words[c]}, skip the next argument";
        c=$((c+1));
        if [[ $c -eq $cword ]]; then
            commands=();
        fi;
    fi;
    c=$((c+1))
}
__gum_handle_go_custom_completion ()
{
    __gum_debug "${FUNCNAME[0]}: cur is ${cur}, words[*] is ${words[*]}, #words[@] is ${#words[@]}";
    local shellCompDirectiveError=1;
    local shellCompDirectiveNoSpace=2;
    local shellCompDirectiveNoFileComp=4;
    local shellCompDirectiveFilterFileExt=8;
    local shellCompDirectiveFilterDirs=16;
    local out requestComp lastParam lastChar comp directive args;
    args=("${words[@]:1}");
    requestComp="GUM_ACTIVE_HELP=0 ${words[0]} completion completeNoDesc ${args[*]}";
    lastParam=${words[$((${#words[@]}-1))]};
    lastChar=${lastParam:$((${#lastParam}-1)):1};
    __gum_debug "${FUNCNAME[0]}: lastParam ${lastParam}, lastChar ${lastChar}";
    if [ -z "${cur}" ] && [ "${lastChar}" != "=" ]; then
        __gum_debug "${FUNCNAME[0]}: Adding extra empty parameter";
        requestComp="${requestComp} \"\"";
    fi;
    __gum_debug "${FUNCNAME[0]}: calling ${requestComp}";
    out=$(eval "${requestComp}" 2>/dev/null);
    directive=${out##*:};
    out=${out%:*};
    if [ "${directive}" = "${out}" ]; then
        directive=0;
    fi;
    __gum_debug "${FUNCNAME[0]}: the completion directive is: ${directive}";
    __gum_debug "${FUNCNAME[0]}: the completions are: ${out}";
    if [ $((directive & shellCompDirectiveError)) -ne 0 ]; then
        __gum_debug "${FUNCNAME[0]}: received error from custom completion go code";
        return;
    else
        if [ $((directive & shellCompDirectiveNoSpace)) -ne 0 ]; then
            if [[ $(type -t compopt) = "builtin" ]]; then
                __gum_debug "${FUNCNAME[0]}: activating no space";
                compopt -o nospace;
            fi;
        fi;
        if [ $((directive & shellCompDirectiveNoFileComp)) -ne 0 ]; then
            if [[ $(type -t compopt) = "builtin" ]]; then
                __gum_debug "${FUNCNAME[0]}: activating no file completion";
                compopt +o default;
            fi;
        fi;
    fi;
    if [ $((directive & shellCompDirectiveFilterFileExt)) -ne 0 ]; then
        local fullFilter filter filteringCmd;
        for filter in ${out};
        do
            fullFilter+="$filter|";
        done;
        filteringCmd="_filedir $fullFilter";
        __gum_debug "File filtering command: $filteringCmd";
        $filteringCmd;
    else
        if [ $((directive & shellCompDirectiveFilterDirs)) -ne 0 ]; then
            local subdir;
            subdir=$(printf "%s" "${out}");
            if [ -n "$subdir" ]; then
                __gum_debug "Listing directories in $subdir";
                __gum_handle_subdirs_in_dir_flag "$subdir";
            else
                __gum_debug "Listing directories in .";
                _filedir -d;
            fi;
        else
            while IFS='' read -r comp; do
                COMPREPLY+=("$comp");
            done < <(compgen -W "${out}" -- "$cur");
        fi;
    fi
}
__gum_handle_noun ()
{
    __gum_debug "${FUNCNAME[0]}: c is $c words[c] is ${words[c]}";
    if __gum_contains_word "${words[c]}" "${must_have_one_noun[@]}"; then
        must_have_one_noun=();
    else
        if __gum_contains_word "${words[c]}" "${noun_aliases[@]}"; then
            must_have_one_noun=();
        fi;
    fi;
    nouns+=("${words[c]}");
    c=$((c+1))
}
__gum_handle_reply ()
{
    __gum_debug "${FUNCNAME[0]}";
    local comp;
    case $cur in
        -*)
            if [[ $(type -t compopt) = "builtin" ]]; then
                compopt -o nospace;
            fi;
            local allflags;
            if [ ${#must_have_one_flag[@]} -ne 0 ]; then
                allflags=("${must_have_one_flag[@]}");
            else
                allflags=("${flags[*]} ${two_word_flags[*]}");
            fi;
            while IFS='' read -r comp; do
                COMPREPLY+=("$comp");
            done < <(compgen -W "${allflags[*]}" -- "$cur");
            if [[ $(type -t compopt) = "builtin" ]]; then
                [[ "${COMPREPLY[0]}" == *= ]] || compopt +o nospace;
            fi;
            if [[ $cur == *=* ]]; then
                if [[ $(type -t compopt) = "builtin" ]]; then
                    compopt +o nospace;
                fi;
                local index flag;
                flag="${cur%=*}";
                __gum_index_of_word "${flag}" "${flags_with_completion[@]}";
                COMPREPLY=();
                if [[ ${index} -ge 0 ]]; then
                    PREFIX="";
                    cur="${cur#*=}";
                    ${flags_completion[${index}]};
                    if [ -n "${ZSH_VERSION:-}" ]; then
                        eval "COMPREPLY=( \"\${COMPREPLY[@]/#/${flag}=}\" )";
                    fi;
                fi;
            fi;
            if [[ -z "${flag_parsing_disabled}" ]]; then
                return 0;
            fi
        ;;
    esac;
    local index;
    __gum_index_of_word "${prev}" "${flags_with_completion[@]}";
    if [[ ${index} -ge 0 ]]; then
        ${flags_completion[${index}]};
        return;
    fi;
    if [[ ${cur} != "${words[cword]}" ]]; then
        return;
    fi;
    local completions;
    completions=("${commands[@]}");
    if [[ ${#must_have_one_noun[@]} -ne 0 ]]; then
        completions+=("${must_have_one_noun[@]}");
    else
        if [[ -n "${has_completion_function}" ]]; then
            __gum_handle_go_custom_completion;
        fi;
    fi;
    if [[ ${#must_have_one_flag[@]} -ne 0 ]]; then
        completions+=("${must_have_one_flag[@]}");
    fi;
    while IFS='' read -r comp; do
        COMPREPLY+=("$comp");
    done < <(compgen -W "${completions[*]}" -- "$cur");
    if [[ ${#COMPREPLY[@]} -eq 0 && ${#noun_aliases[@]} -gt 0 && ${#must_have_one_noun[@]} -ne 0 ]]; then
        while IFS='' read -r comp; do
            COMPREPLY+=("$comp");
        done < <(compgen -W "${noun_aliases[*]}" -- "$cur");
    fi;
    if [[ ${#COMPREPLY[@]} -eq 0 ]]; then
        if declare -F __gum_custom_func > /dev/null; then
            __gum_custom_func;
        else
            declare -F __custom_func > /dev/null && __custom_func;
        fi;
    fi;
    if declare -F __ltrim_colon_completions > /dev/null; then
        __ltrim_colon_completions "$cur";
    fi;
    if [[ "${#COMPREPLY[@]}" -eq "1" ]] && [[ $(type -t compopt) = "builtin" ]] && [[ "${COMPREPLY[0]}" == --*= ]]; then
        compopt -o nospace;
    fi
}
__gum_handle_subdirs_in_dir_flag ()
{
    local dir="$1";
    pushd "${dir}" > /dev/null 2>&1 && _filedir -d && popd > /dev/null 2>&1 || return
}
__gum_handle_word ()
{
    if [[ $c -ge $cword ]]; then
        __gum_handle_reply;
        return;
    fi;
    __gum_debug "${FUNCNAME[0]}: c is $c words[c] is ${words[c]}";
    if [[ "${words[c]}" == -* ]]; then
        __gum_handle_flag;
    else
        if __gum_contains_word "${words[c]}" "${commands[@]}"; then
            __gum_handle_command;
        else
            if [[ $c -eq 0 ]]; then
                __gum_handle_command;
            else
                if __gum_contains_word "${words[c]}" "${command_aliases[@]}"; then
                    if [[ -z "${BASH_VERSION:-}" || "${BASH_VERSINFO[0]:-}" -gt 3 ]]; then
                        words[c]=${aliashash[${words[c]}]};
                        __gum_handle_command;
                    else
                        __gum_handle_noun;
                    fi;
                else
                    __gum_handle_noun;
                fi;
            fi;
        fi;
    fi;
    __gum_handle_word
}
__gum_index_of_word ()
{
    local w word=$1;
    shift;
    index=0;
    for w in "$@";
    do
        [[ $w = "$word" ]] && return;
        index=$((index+1));
    done;
    index=-1
}
__gum_init_completion ()
{
    COMPREPLY=();
    _get_comp_words_by_ref "$@" cur prev words cword
}
__linux_fstab_unescape ()
{
    eval $1="'${!1//\'/\047}'";
    eval $1="'${!1/%\\/\\\\}'";
    eval "$1=$'${!1}'"
}
__ltrim_colon_completions ()
{
    if [[ "$1" == *:* && ( ${BASH_VERSINFO[0]} -lt 4 || ( ${BASH_VERSINFO[0]} -ge 4 && "$COMP_WORDBREAKS" == *:* ) ) ]]; then
        local colon_word=${1%${1##*:}};
        local i=${#COMPREPLY[*]};
        while [ $((--i)) -ge 0 ]; do
            COMPREPLY[$i]=${COMPREPLY[$i]#"$colon_word"};
        done;
    fi
}
__reassemble_comp_words_by_ref ()
{
    local exclude i j ref;
    if [[ -n $1 ]]; then
        exclude="${1//[^$COMP_WORDBREAKS]}";
    fi;
    eval $3=$COMP_CWORD;
    if [[ -n $exclude ]]; then
        for ((i=0, j=0; i < ${#COMP_WORDS[@]}; i++, j++))
        do
            while [[ $i -gt 0 && -n ${COMP_WORDS[$i]} && ${COMP_WORDS[$i]//[^$exclude]} == ${COMP_WORDS[$i]} ]]; do
                [ $j -ge 2 ] && ((j--));
                ref="$2[$j]";
                eval $2[$j]=\${!ref}\${COMP_WORDS[i]};
                [ $i = $COMP_CWORD ] && eval $3=$j;
                (( $i < ${#COMP_WORDS[@]} - 1)) && ((i++)) || break 2;
            done;
            ref="$2[$j]";
            eval $2[$j]=\${!ref}\${COMP_WORDS[i]};
            [[ $i == $COMP_CWORD ]] && eval $3=$j;
        done;
    else
        eval $2=\( \"\${COMP_WORDS[@]}\" \);
    fi
}
__s_contains_word ()
{
    local w word=$1;
    shift;
    for w in "$@";
    do
        [[ $w = "$word" ]] && return;
    done;
    return 1
}
__s_debug ()
{
    if [[ -n ${BASH_COMP_DEBUG_FILE:-} ]]; then
        echo "$*" >> "${BASH_COMP_DEBUG_FILE}";
    fi
}
__s_handle_command ()
{
    __s_debug "${FUNCNAME[0]}: c is $c words[c] is ${words[c]}";
    local next_command;
    if [[ -n ${last_command} ]]; then
        next_command="_${last_command}_${words[c]//:/__}";
    else
        if [[ $c -eq 0 ]]; then
            next_command="_s_root_command";
        else
            next_command="_${words[c]//:/__}";
        fi;
    fi;
    c=$((c+1));
    __s_debug "${FUNCNAME[0]}: looking for ${next_command}";
    declare -F "$next_command" > /dev/null && $next_command
}
__s_handle_filename_extension_flag ()
{
    local ext="$1";
    _filedir "@(${ext})"
}
__s_handle_flag ()
{
    __s_debug "${FUNCNAME[0]}: c is $c words[c] is ${words[c]}";
    local flagname=${words[c]};
    local flagvalue="";
    if [[ ${words[c]} == *"="* ]]; then
        flagvalue=${flagname#*=};
        flagname=${flagname%=*};
        flagname="${flagname}=";
    fi;
    __s_debug "${FUNCNAME[0]}: looking for ${flagname}";
    if __s_contains_word "${flagname}" "${must_have_one_flag[@]}"; then
        must_have_one_flag=();
    fi;
    if __s_contains_word "${flagname}" "${local_nonpersistent_flags[@]}"; then
        commands=();
    fi;
    if [[ -z "${BASH_VERSION:-}" || "${BASH_VERSINFO[0]:-}" -gt 3 ]]; then
        if [ -n "${flagvalue}" ]; then
            flaghash[${flagname}]=${flagvalue};
        else
            if [ -n "${words[ $((c+1)) ]}" ]; then
                flaghash[${flagname}]=${words[ $((c+1)) ]};
            else
                flaghash[${flagname}]="true";
            fi;
        fi;
    fi;
    if [[ ${words[c]} != *"="* ]] && __s_contains_word "${words[c]}" "${two_word_flags[@]}"; then
        __s_debug "${FUNCNAME[0]}: found a flag ${words[c]}, skip the next argument";
        c=$((c+1));
        if [[ $c -eq $cword ]]; then
            commands=();
        fi;
    fi;
    c=$((c+1))
}
__s_handle_go_custom_completion ()
{
    __s_debug "${FUNCNAME[0]}: cur is ${cur}, words[*] is ${words[*]}, #words[@] is ${#words[@]}";
    local shellCompDirectiveError=1;
    local shellCompDirectiveNoSpace=2;
    local shellCompDirectiveNoFileComp=4;
    local shellCompDirectiveFilterFileExt=8;
    local shellCompDirectiveFilterDirs=16;
    local out requestComp lastParam lastChar comp directive args;
    args=("${words[@]:1}");
    requestComp="${words[0]} __completeNoDesc ${args[*]}";
    lastParam=${words[$((${#words[@]}-1))]};
    lastChar=${lastParam:$((${#lastParam}-1)):1};
    __s_debug "${FUNCNAME[0]}: lastParam ${lastParam}, lastChar ${lastChar}";
    if [ -z "${cur}" ] && [ "${lastChar}" != "=" ]; then
        __s_debug "${FUNCNAME[0]}: Adding extra empty parameter";
        requestComp="${requestComp} \"\"";
    fi;
    __s_debug "${FUNCNAME[0]}: calling ${requestComp}";
    out=$(eval "${requestComp}" 2>/dev/null);
    directive=${out##*:};
    out=${out%:*};
    if [ "${directive}" = "${out}" ]; then
        directive=0;
    fi;
    __s_debug "${FUNCNAME[0]}: the completion directive is: ${directive}";
    __s_debug "${FUNCNAME[0]}: the completions are: ${out[*]}";
    if [ $((directive & shellCompDirectiveError)) -ne 0 ]; then
        __s_debug "${FUNCNAME[0]}: received error from custom completion go code";
        return;
    else
        if [ $((directive & shellCompDirectiveNoSpace)) -ne 0 ]; then
            if [[ $(type -t compopt) = "builtin" ]]; then
                __s_debug "${FUNCNAME[0]}: activating no space";
                compopt -o nospace;
            fi;
        fi;
        if [ $((directive & shellCompDirectiveNoFileComp)) -ne 0 ]; then
            if [[ $(type -t compopt) = "builtin" ]]; then
                __s_debug "${FUNCNAME[0]}: activating no file completion";
                compopt +o default;
            fi;
        fi;
    fi;
    if [ $((directive & shellCompDirectiveFilterFileExt)) -ne 0 ]; then
        local fullFilter filter filteringCmd;
        for filter in ${out[*]};
        do
            fullFilter+="$filter|";
        done;
        filteringCmd="_filedir $fullFilter";
        __s_debug "File filtering command: $filteringCmd";
        $filteringCmd;
    else
        if [ $((directive & shellCompDirectiveFilterDirs)) -ne 0 ]; then
            local subdir;
            subdir=$(printf "%s" "${out[0]}");
            if [ -n "$subdir" ]; then
                __s_debug "Listing directories in $subdir";
                __s_handle_subdirs_in_dir_flag "$subdir";
            else
                __s_debug "Listing directories in .";
                _filedir -d;
            fi;
        else
            while IFS='' read -r comp; do
                COMPREPLY+=("$comp");
            done < <(compgen -W "${out[*]}" -- "$cur");
        fi;
    fi
}
__s_handle_noun ()
{
    __s_debug "${FUNCNAME[0]}: c is $c words[c] is ${words[c]}";
    if __s_contains_word "${words[c]}" "${must_have_one_noun[@]}"; then
        must_have_one_noun=();
    else
        if __s_contains_word "${words[c]}" "${noun_aliases[@]}"; then
            must_have_one_noun=();
        fi;
    fi;
    nouns+=("${words[c]}");
    c=$((c+1))
}
__s_handle_reply ()
{
    __s_debug "${FUNCNAME[0]}";
    local comp;
    case $cur in
        -*)
            if [[ $(type -t compopt) = "builtin" ]]; then
                compopt -o nospace;
            fi;
            local allflags;
            if [ ${#must_have_one_flag[@]} -ne 0 ]; then
                allflags=("${must_have_one_flag[@]}");
            else
                allflags=("${flags[*]} ${two_word_flags[*]}");
            fi;
            while IFS='' read -r comp; do
                COMPREPLY+=("$comp");
            done < <(compgen -W "${allflags[*]}" -- "$cur");
            if [[ $(type -t compopt) = "builtin" ]]; then
                [[ "${COMPREPLY[0]}" == *= ]] || compopt +o nospace;
            fi;
            if [[ $cur == *=* ]]; then
                if [[ $(type -t compopt) = "builtin" ]]; then
                    compopt +o nospace;
                fi;
                local index flag;
                flag="${cur%=*}";
                __s_index_of_word "${flag}" "${flags_with_completion[@]}";
                COMPREPLY=();
                if [[ ${index} -ge 0 ]]; then
                    PREFIX="";
                    cur="${cur#*=}";
                    ${flags_completion[${index}]};
                    if [ -n "${ZSH_VERSION:-}" ]; then
                        eval "COMPREPLY=( \"\${COMPREPLY[@]/#/${flag}=}\" )";
                    fi;
                fi;
            fi;
            if [[ -z "${flag_parsing_disabled}" ]]; then
                return 0;
            fi
        ;;
    esac;
    local index;
    __s_index_of_word "${prev}" "${flags_with_completion[@]}";
    if [[ ${index} -ge 0 ]]; then
        ${flags_completion[${index}]};
        return;
    fi;
    if [[ ${cur} != "${words[cword]}" ]]; then
        return;
    fi;
    local completions;
    completions=("${commands[@]}");
    if [[ ${#must_have_one_noun[@]} -ne 0 ]]; then
        completions+=("${must_have_one_noun[@]}");
    else
        if [[ -n "${has_completion_function}" ]]; then
            __s_handle_go_custom_completion;
        fi;
    fi;
    if [[ ${#must_have_one_flag[@]} -ne 0 ]]; then
        completions+=("${must_have_one_flag[@]}");
    fi;
    while IFS='' read -r comp; do
        COMPREPLY+=("$comp");
    done < <(compgen -W "${completions[*]}" -- "$cur");
    if [[ ${#COMPREPLY[@]} -eq 0 && ${#noun_aliases[@]} -gt 0 && ${#must_have_one_noun[@]} -ne 0 ]]; then
        while IFS='' read -r comp; do
            COMPREPLY+=("$comp");
        done < <(compgen -W "${noun_aliases[*]}" -- "$cur");
    fi;
    if [[ ${#COMPREPLY[@]} -eq 0 ]]; then
        if declare -F __s_custom_func > /dev/null; then
            __s_custom_func;
        else
            declare -F __custom_func > /dev/null && __custom_func;
        fi;
    fi;
    if declare -F __ltrim_colon_completions > /dev/null; then
        __ltrim_colon_completions "$cur";
    fi;
    if [[ "${#COMPREPLY[@]}" -eq "1" ]] && [[ $(type -t compopt) = "builtin" ]] && [[ "${COMPREPLY[0]}" == --*= ]]; then
        compopt -o nospace;
    fi
}
__s_handle_subdirs_in_dir_flag ()
{
    local dir="$1";
    pushd "${dir}" > /dev/null 2>&1 && _filedir -d && popd > /dev/null 2>&1 || return
}
__s_handle_word ()
{
    if [[ $c -ge $cword ]]; then
        __s_handle_reply;
        return;
    fi;
    __s_debug "${FUNCNAME[0]}: c is $c words[c] is ${words[c]}";
    if [[ "${words[c]}" == -* ]]; then
        __s_handle_flag;
    else
        if __s_contains_word "${words[c]}" "${commands[@]}"; then
            __s_handle_command;
        else
            if [[ $c -eq 0 ]]; then
                __s_handle_command;
            else
                if __s_contains_word "${words[c]}" "${command_aliases[@]}"; then
                    if [[ -z "${BASH_VERSION:-}" || "${BASH_VERSINFO[0]:-}" -gt 3 ]]; then
                        words[c]=${aliashash[${words[c]}]};
                        __s_handle_command;
                    else
                        __s_handle_noun;
                    fi;
                else
                    __s_handle_noun;
                fi;
            fi;
        fi;
    fi;
    __s_handle_word
}
__s_index_of_word ()
{
    local w word=$1;
    shift;
    index=0;
    for w in "$@";
    do
        [[ $w = "$word" ]] && return;
        index=$((index+1));
    done;
    index=-1
}
__s_init_completion ()
{
    COMPREPLY=();
    _get_comp_words_by_ref "$@" cur prev words cword
}
__sq_contains_word ()
{
    local w word=$1;
    shift;
    for w in "$@";
    do
        [[ $w = "$word" ]] && return;
    done;
    return 1
}
__sq_debug ()
{
    if [[ -n ${BASH_COMP_DEBUG_FILE:-} ]]; then
        echo "$*" >> "${BASH_COMP_DEBUG_FILE}";
    fi
}
__sq_handle_command ()
{
    __sq_debug "${FUNCNAME[0]}: c is $c words[c] is ${words[c]}";
    local next_command;
    if [[ -n ${last_command} ]]; then
        next_command="_${last_command}_${words[c]//:/__}";
    else
        if [[ $c -eq 0 ]]; then
            next_command="_sq_root_command";
        else
            next_command="_${words[c]//:/__}";
        fi;
    fi;
    c=$((c+1));
    __sq_debug "${FUNCNAME[0]}: looking for ${next_command}";
    declare -F "$next_command" > /dev/null && $next_command
}
__sq_handle_filename_extension_flag ()
{
    local ext="$1";
    _filedir "@(${ext})"
}
__sq_handle_flag ()
{
    __sq_debug "${FUNCNAME[0]}: c is $c words[c] is ${words[c]}";
    local flagname=${words[c]};
    local flagvalue="";
    if [[ ${words[c]} == *"="* ]]; then
        flagvalue=${flagname#*=};
        flagname=${flagname%=*};
        flagname="${flagname}=";
    fi;
    __sq_debug "${FUNCNAME[0]}: looking for ${flagname}";
    if __sq_contains_word "${flagname}" "${must_have_one_flag[@]}"; then
        must_have_one_flag=();
    fi;
    if __sq_contains_word "${flagname}" "${local_nonpersistent_flags[@]}"; then
        commands=();
    fi;
    if [[ -z "${BASH_VERSION:-}" || "${BASH_VERSINFO[0]:-}" -gt 3 ]]; then
        if [ -n "${flagvalue}" ]; then
            flaghash[${flagname}]=${flagvalue};
        else
            if [ -n "${words[ $((c+1)) ]}" ]; then
                flaghash[${flagname}]=${words[ $((c+1)) ]};
            else
                flaghash[${flagname}]="true";
            fi;
        fi;
    fi;
    if [[ ${words[c]} != *"="* ]] && __sq_contains_word "${words[c]}" "${two_word_flags[@]}"; then
        __sq_debug "${FUNCNAME[0]}: found a flag ${words[c]}, skip the next argument";
        c=$((c+1));
        if [[ $c -eq $cword ]]; then
            commands=();
        fi;
    fi;
    c=$((c+1))
}
__sq_handle_go_custom_completion ()
{
    __sq_debug "${FUNCNAME[0]}: cur is ${cur}, words[*] is ${words[*]}, #words[@] is ${#words[@]}";
    local shellCompDirectiveError=1;
    local shellCompDirectiveNoSpace=2;
    local shellCompDirectiveNoFileComp=4;
    local shellCompDirectiveFilterFileExt=8;
    local shellCompDirectiveFilterDirs=16;
    local out requestComp lastParam lastChar comp directive args;
    args=("${words[@]:1}");
    requestComp="SQ_ACTIVE_HELP=0 ${words[0]} __completeNoDesc ${args[*]}";
    lastParam=${words[$((${#words[@]}-1))]};
    lastChar=${lastParam:$((${#lastParam}-1)):1};
    __sq_debug "${FUNCNAME[0]}: lastParam ${lastParam}, lastChar ${lastChar}";
    if [ -z "${cur}" ] && [ "${lastChar}" != "=" ]; then
        __sq_debug "${FUNCNAME[0]}: Adding extra empty parameter";
        requestComp="${requestComp} \"\"";
    fi;
    __sq_debug "${FUNCNAME[0]}: calling ${requestComp}";
    out=$(eval "${requestComp}" 2>/dev/null);
    directive=${out##*:};
    out=${out%:*};
    if [ "${directive}" = "${out}" ]; then
        directive=0;
    fi;
    __sq_debug "${FUNCNAME[0]}: the completion directive is: ${directive}";
    __sq_debug "${FUNCNAME[0]}: the completions are: ${out}";
    if [ $((directive & shellCompDirectiveError)) -ne 0 ]; then
        __sq_debug "${FUNCNAME[0]}: received error from custom completion go code";
        return;
    else
        if [ $((directive & shellCompDirectiveNoSpace)) -ne 0 ]; then
            if [[ $(type -t compopt) = "builtin" ]]; then
                __sq_debug "${FUNCNAME[0]}: activating no space";
                compopt -o nospace;
            fi;
        fi;
        if [ $((directive & shellCompDirectiveNoFileComp)) -ne 0 ]; then
            if [[ $(type -t compopt) = "builtin" ]]; then
                __sq_debug "${FUNCNAME[0]}: activating no file completion";
                compopt +o default;
            fi;
        fi;
    fi;
    if [ $((directive & shellCompDirectiveFilterFileExt)) -ne 0 ]; then
        local fullFilter filter filteringCmd;
        for filter in ${out};
        do
            fullFilter+="$filter|";
        done;
        filteringCmd="_filedir $fullFilter";
        __sq_debug "File filtering command: $filteringCmd";
        $filteringCmd;
    else
        if [ $((directive & shellCompDirectiveFilterDirs)) -ne 0 ]; then
            local subdir;
            subdir=$(printf "%s" "${out}");
            if [ -n "$subdir" ]; then
                __sq_debug "Listing directories in $subdir";
                __sq_handle_subdirs_in_dir_flag "$subdir";
            else
                __sq_debug "Listing directories in .";
                _filedir -d;
            fi;
        else
            while IFS='' read -r comp; do
                COMPREPLY+=("$comp");
            done < <(compgen -W "${out}" -- "$cur");
        fi;
    fi
}
__sq_handle_noun ()
{
    __sq_debug "${FUNCNAME[0]}: c is $c words[c] is ${words[c]}";
    if __sq_contains_word "${words[c]}" "${must_have_one_noun[@]}"; then
        must_have_one_noun=();
    else
        if __sq_contains_word "${words[c]}" "${noun_aliases[@]}"; then
            must_have_one_noun=();
        fi;
    fi;
    nouns+=("${words[c]}");
    c=$((c+1))
}
__sq_handle_reply ()
{
    __sq_debug "${FUNCNAME[0]}";
    local comp;
    case $cur in
        -*)
            if [[ $(type -t compopt) = "builtin" ]]; then
                compopt -o nospace;
            fi;
            local allflags;
            if [ ${#must_have_one_flag[@]} -ne 0 ]; then
                allflags=("${must_have_one_flag[@]}");
            else
                allflags=("${flags[*]} ${two_word_flags[*]}");
            fi;
            while IFS='' read -r comp; do
                COMPREPLY+=("$comp");
            done < <(compgen -W "${allflags[*]}" -- "$cur");
            if [[ $(type -t compopt) = "builtin" ]]; then
                [[ "${COMPREPLY[0]}" == *= ]] || compopt +o nospace;
            fi;
            if [[ $cur == *=* ]]; then
                if [[ $(type -t compopt) = "builtin" ]]; then
                    compopt +o nospace;
                fi;
                local index flag;
                flag="${cur%=*}";
                __sq_index_of_word "${flag}" "${flags_with_completion[@]}";
                COMPREPLY=();
                if [[ ${index} -ge 0 ]]; then
                    PREFIX="";
                    cur="${cur#*=}";
                    ${flags_completion[${index}]};
                    if [ -n "${ZSH_VERSION:-}" ]; then
                        eval "COMPREPLY=( \"\${COMPREPLY[@]/#/${flag}=}\" )";
                    fi;
                fi;
            fi;
            if [[ -z "${flag_parsing_disabled}" ]]; then
                return 0;
            fi
        ;;
    esac;
    local index;
    __sq_index_of_word "${prev}" "${flags_with_completion[@]}";
    if [[ ${index} -ge 0 ]]; then
        ${flags_completion[${index}]};
        return;
    fi;
    if [[ ${cur} != "${words[cword]}" ]]; then
        return;
    fi;
    local completions;
    completions=("${commands[@]}");
    if [[ ${#must_have_one_noun[@]} -ne 0 ]]; then
        completions+=("${must_have_one_noun[@]}");
    else
        if [[ -n "${has_completion_function}" ]]; then
            __sq_handle_go_custom_completion;
        fi;
    fi;
    if [[ ${#must_have_one_flag[@]} -ne 0 ]]; then
        completions+=("${must_have_one_flag[@]}");
    fi;
    while IFS='' read -r comp; do
        COMPREPLY+=("$comp");
    done < <(compgen -W "${completions[*]}" -- "$cur");
    if [[ ${#COMPREPLY[@]} -eq 0 && ${#noun_aliases[@]} -gt 0 && ${#must_have_one_noun[@]} -ne 0 ]]; then
        while IFS='' read -r comp; do
            COMPREPLY+=("$comp");
        done < <(compgen -W "${noun_aliases[*]}" -- "$cur");
    fi;
    if [[ ${#COMPREPLY[@]} -eq 0 ]]; then
        if declare -F __sq_custom_func > /dev/null; then
            __sq_custom_func;
        else
            declare -F __custom_func > /dev/null && __custom_func;
        fi;
    fi;
    if declare -F __ltrim_colon_completions > /dev/null; then
        __ltrim_colon_completions "$cur";
    fi;
    if [[ "${#COMPREPLY[@]}" -eq "1" ]] && [[ $(type -t compopt) = "builtin" ]] && [[ "${COMPREPLY[0]}" == --*= ]]; then
        compopt -o nospace;
    fi
}
__sq_handle_subdirs_in_dir_flag ()
{
    local dir="$1";
    pushd "${dir}" > /dev/null 2>&1 && _filedir -d && popd > /dev/null 2>&1 || return
}
__sq_handle_word ()
{
    if [[ $c -ge $cword ]]; then
        __sq_handle_reply;
        return;
    fi;
    __sq_debug "${FUNCNAME[0]}: c is $c words[c] is ${words[c]}";
    if [[ "${words[c]}" == -* ]]; then
        __sq_handle_flag;
    else
        if __sq_contains_word "${words[c]}" "${commands[@]}"; then
            __sq_handle_command;
        else
            if [[ $c -eq 0 ]]; then
                __sq_handle_command;
            else
                if __sq_contains_word "${words[c]}" "${command_aliases[@]}"; then
                    if [[ -z "${BASH_VERSION:-}" || "${BASH_VERSINFO[0]:-}" -gt 3 ]]; then
                        words[c]=${aliashash[${words[c]}]};
                        __sq_handle_command;
                    else
                        __sq_handle_noun;
                    fi;
                else
                    __sq_handle_noun;
                fi;
            fi;
        fi;
    fi;
    __sq_handle_word
}
__sq_index_of_word ()
{
    local w word=$1;
    shift;
    index=0;
    for w in "$@";
    do
        [[ $w = "$word" ]] && return;
        index=$((index+1));
    done;
    index=-1
}
__sq_init_completion ()
{
    COMPREPLY=();
    _get_comp_words_by_ref "$@" cur prev words cword
}
__start_gum ()
{
    local cur prev words cword split;
    declare -A flaghash 2> /dev/null || :;
    declare -A aliashash 2> /dev/null || :;
    if declare -F _init_completion > /dev/null 2>&1; then
        _init_completion -s || return;
    else
        __gum_init_completion -n "=" || return;
    fi;
    local c=0;
    local flag_parsing_disabled=;
    local flags=();
    local two_word_flags=();
    local local_nonpersistent_flags=();
    local flags_with_completion=();
    local flags_completion=();
    local commands=("gum");
    local command_aliases=();
    local must_have_one_flag=();
    local must_have_one_noun=();
    local has_completion_function="";
    local last_command="";
    local nouns=();
    local noun_aliases=();
    __gum_handle_word
}
__start_s ()
{
    local cur prev words cword split;
    declare -A flaghash 2> /dev/null || :;
    declare -A aliashash 2> /dev/null || :;
    if declare -F _init_completion > /dev/null 2>&1; then
        _init_completion -s || return;
    else
        __s_init_completion -n "=" || return;
    fi;
    local c=0;
    local flag_parsing_disabled=;
    local flags=();
    local two_word_flags=();
    local local_nonpersistent_flags=();
    local flags_with_completion=();
    local flags_completion=();
    local commands=("s");
    local command_aliases=();
    local must_have_one_flag=();
    local must_have_one_noun=();
    local has_completion_function="";
    local last_command="";
    local nouns=();
    local noun_aliases=();
    __s_handle_word
}
__start_sq ()
{
    local cur prev words cword split;
    declare -A flaghash 2> /dev/null || :;
    declare -A aliashash 2> /dev/null || :;
    if declare -F _init_completion > /dev/null 2>&1; then
        _init_completion -s || return;
    else
        __sq_init_completion -n "=" || return;
    fi;
    local c=0;
    local flag_parsing_disabled=;
    local flags=();
    local two_word_flags=();
    local local_nonpersistent_flags=();
    local flags_with_completion=();
    local flags_completion=();
    local commands=("sq");
    local command_aliases=();
    local must_have_one_flag=();
    local must_have_one_noun=();
    local has_completion_function="";
    local last_command="";
    local nouns=();
    local noun_aliases=();
    __sq_handle_word
}
__tmux_init_completion ()
{
    COMPREPLY=();
    _get_comp_words_by_ref cur prev words cword
}
__youtube_dl ()
{
    local cur prev opts fileopts diropts keywords;
    COMPREPLY=();
    cur="${COMP_WORDS[COMP_CWORD]}";
    prev="${COMP_WORDS[COMP_CWORD-1]}";
    opts="--help --version --update --ignore-errors --abort-on-error --dump-user-agent --list-extractors --extractor-descriptions --force-generic-extractor --default-search --ignore-config --config-location --flat-playlist --mark-watched --no-mark-watched --no-color --proxy --socket-timeout --source-address --force-ipv4 --force-ipv6 --geo-verification-proxy --cn-verification-proxy --geo-bypass --no-geo-bypass --geo-bypass-country --geo-bypass-ip-block --playlist-start --playlist-end --playlist-items --match-title --reject-title --max-downloads --min-filesize --max-filesize --date --datebefore --dateafter --min-views --max-views --match-filter --no-playlist --yes-playlist --age-limit --download-archive --include-ads --limit-rate --retries --fragment-retries --skip-unavailable-fragments --abort-on-unavailable-fragment --keep-fragments --buffer-size --no-resize-buffer --http-chunk-size --test --playlist-reverse --playlist-random --xattr-set-filesize --hls-prefer-native --hls-prefer-ffmpeg --hls-use-mpegts --external-downloader --external-downloader-args --batch-file --id --output --output-na-placeholder --autonumber-size --autonumber-start --restrict-filenames --auto-number --title --literal --no-overwrites --continue --no-continue --no-part --no-mtime --write-description --write-info-json --write-annotations --load-info-json --cookies --cache-dir --no-cache-dir --rm-cache-dir --write-thumbnail --write-all-thumbnails --list-thumbnails --quiet --no-warnings --simulate --skip-download --get-url --get-title --get-id --get-thumbnail --get-description --get-duration --get-filename --get-format --dump-json --dump-single-json --print-json --newline --no-progress --console-title --verbose --dump-pages --write-pages --youtube-print-sig-code --print-traffic --call-home --no-call-home --encoding --no-check-certificate --prefer-insecure --user-agent --referer --add-header --bidi-workaround --sleep-interval --max-sleep-interval --format --all-formats --prefer-free-formats --list-formats --youtube-include-dash-manifest --youtube-skip-dash-manifest --merge-output-format --write-sub --write-auto-sub --all-subs --list-subs --sub-format --sub-lang --username --password --twofactor --netrc --video-password --ap-mso --ap-username --ap-password --ap-list-mso --extract-audio --audio-format --audio-quality --recode-video --postprocessor-args --keep-video --no-post-overwrites --embed-subs --embed-thumbnail --add-metadata --metadata-from-title --xattrs --fixup --prefer-avconv --prefer-ffmpeg --ffmpeg-location --exec --convert-subs";
    keywords=":ytfavorites :ytrecommended :ytsubscriptions :ytwatchlater :ythistory";
    fileopts="-a|--batch-file|--download-archive|--cookies|--load-info";
    diropts="--cache-dir";
    if [[ ${prev} =~ ${fileopts} ]]; then
        COMPREPLY=($(compgen -f -- ${cur}));
        return 0;
    else
        if [[ ${prev} =~ ${diropts} ]]; then
            COMPREPLY=($(compgen -d -- ${cur}));
            return 0;
        fi;
    fi;
    if [[ ${cur} =~ : ]]; then
        COMPREPLY=($(compgen -W "${keywords}" -- ${cur}));
        return 0;
    else
        if [[ ${cur} == * ]]; then
            COMPREPLY=($(compgen -W "${opts}" -- ${cur}));
            return 0;
        fi;
    fi
}
__yt_dlp ()
{
    local cur prev opts fileopts diropts keywords;
    COMPREPLY=();
    cur="${COMP_WORDS[COMP_CWORD]}";
    prev="${COMP_WORDS[COMP_CWORD-1]}";
    opts="--help --version --update --no-update --update-to --ignore-errors --no-abort-on-error --abort-on-error --dump-user-agent --list-extractors --extractor-descriptions --use-extractors --force-generic-extractor --default-search --ignore-config --no-config-locations --config-locations --flat-playlist --no-flat-playlist --live-from-start --no-live-from-start --wait-for-video --no-wait-for-video --mark-watched --no-mark-watched --no-colors --compat-options --alias --proxy --socket-timeout --source-address --force-ipv4 --force-ipv6 --enable-file-urls --geo-verification-proxy --cn-verification-proxy --geo-bypass --no-geo-bypass --geo-bypass-country --geo-bypass-ip-block --playlist-start --playlist-end --playlist-items --match-title --reject-title --min-filesize --max-filesize --date --datebefore --dateafter --min-views --max-views --match-filters --no-match-filter --break-match-filters --no-break-match-filters --no-playlist --yes-playlist --age-limit --download-archive --no-download-archive --max-downloads --break-on-existing --break-on-reject --break-per-input --no-break-per-input --skip-playlist-after-errors --include-ads --no-include-ads --concurrent-fragments --limit-rate --throttled-rate --retries --file-access-retries --fragment-retries --retry-sleep --skip-unavailable-fragments --abort-on-unavailable-fragments --keep-fragments --no-keep-fragments --buffer-size --resize-buffer --no-resize-buffer --http-chunk-size --test --playlist-reverse --no-playlist-reverse --playlist-random --lazy-playlist --no-lazy-playlist --xattr-set-filesize --hls-prefer-native --hls-prefer-ffmpeg --hls-use-mpegts --no-hls-use-mpegts --download-sections --downloader --downloader-args --batch-file --no-batch-file --id --paths --output --output-na-placeholder --autonumber-size --autonumber-start --restrict-filenames --no-restrict-filenames --windows-filenames --no-windows-filenames --trim-filenames --no-overwrites --force-overwrites --no-force-overwrites --continue --no-continue --part --no-part --mtime --no-mtime --write-description --no-write-description --write-info-json --no-write-info-json --write-annotations --no-write-annotations --write-playlist-metafiles --no-write-playlist-metafiles --clean-info-json --no-clean-info-json --write-comments --no-write-comments --load-info-json --cookies --no-cookies --cookies-from-browser --no-cookies-from-browser --cache-dir --no-cache-dir --rm-cache-dir --write-thumbnail --no-write-thumbnail --write-all-thumbnails --list-thumbnails --write-link --write-url-link --write-webloc-link --write-desktop-link --quiet --no-warnings --simulate --no-simulate --ignore-no-formats-error --no-ignore-no-formats-error --skip-download --print --print-to-file --get-url --get-title --get-id --get-thumbnail --get-description --get-duration --get-filename --get-format --dump-json --dump-single-json --print-json --force-write-archive --newline --no-progress --progress --console-title --progress-template --verbose --dump-pages --write-pages --load-pages --youtube-print-sig-code --print-traffic --call-home --no-call-home --encoding --legacy-server-connect --no-check-certificates --prefer-insecure --user-agent --referer --add-headers --bidi-workaround --sleep-requests --sleep-interval --max-sleep-interval --sleep-subtitles --format --format-sort --format-sort-force --no-format-sort-force --video-multistreams --no-video-multistreams --audio-multistreams --no-audio-multistreams --all-formats --prefer-free-formats --no-prefer-free-formats --check-formats --check-all-formats --no-check-formats --list-formats --list-formats-as-table --list-formats-old --merge-output-format --allow-unplayable-formats --no-allow-unplayable-formats --write-subs --no-write-subs --write-auto-subs --no-write-auto-subs --all-subs --list-subs --sub-format --sub-langs --username --password --twofactor --netrc --netrc-location --video-password --ap-mso --ap-username --ap-password --ap-list-mso --client-certificate --client-certificate-key --client-certificate-password --extract-audio --audio-format --audio-quality --remux-video --recode-video --postprocessor-args --keep-video --no-keep-video --post-overwrites --no-post-overwrites --embed-subs --no-embed-subs --embed-thumbnail --no-embed-thumbnail --embed-metadata --no-embed-metadata --embed-chapters --no-embed-chapters --embed-info-json --no-embed-info-json --metadata-from-title --parse-metadata --replace-in-metadata --xattrs --concat-playlist --fixup --prefer-avconv --prefer-ffmpeg --ffmpeg-location --exec --no-exec --exec-before-download --no-exec-before-download --convert-subs --convert-thumbnails --split-chapters --no-split-chapters --remove-chapters --no-remove-chapters --force-keyframes-at-cuts --no-force-keyframes-at-cuts --use-postprocessor --sponsorblock-mark --sponsorblock-remove --sponsorblock-chapter-title --no-sponsorblock --sponsorblock-api --sponskrub --no-sponskrub --sponskrub-cut --no-sponskrub-cut --sponskrub-force --no-sponskrub-force --sponskrub-location --sponskrub-args --extractor-retries --allow-dynamic-mpd --ignore-dynamic-mpd --hls-split-discontinuity --no-hls-split-discontinuity --extractor-args --youtube-include-dash-manifest --youtube-skip-dash-manifest --youtube-include-hls-manifest --youtube-skip-hls-manifest";
    keywords=":ytfavorites :ytrecommended :ytsubscriptions :ytwatchlater :ythistory";
    fileopts="-a|--batch-file|--download-archive|--cookies|--load-info";
    diropts="--cache-dir";
    if [[ ${prev} =~ ${fileopts} ]]; then
        COMPREPLY=($(compgen -f -- ${cur}));
        return 0;
    else
        if [[ ${prev} =~ ${diropts} ]]; then
            COMPREPLY=($(compgen -d -- ${cur}));
            return 0;
        fi;
    fi;
    if [[ ${cur} =~ : ]]; then
        COMPREPLY=($(compgen -W "${keywords}" -- ${cur}));
        return 0;
    else
        if [[ ${cur} == * ]]; then
            COMPREPLY=($(compgen -W "${opts}" -- ${cur}));
            return 0;
        fi;
    fi
}
_alias ()
{
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    case $COMP_LINE in
        *[^=])
            COMPREPLY=($( compgen -A alias -- "$cur" ))
        ;;
        *=)
            COMPREPLY=("$( alias ${cur%=} 2>/dev/null | sed                 -e 's|^alias '"$cur"'\(.*\)$|\1|' )")
        ;;
    esac
}
_allowed_groups ()
{
    if _complete_as_root; then
        local IFS='
';
        COMPREPLY=($( compgen -g -- "$1" ));
    else
        local IFS='
 ';
        COMPREPLY=($( compgen -W             "$( id -Gn 2>/dev/null || groups 2>/dev/null )" -- "$1" ));
    fi
}
_allowed_users ()
{
    if _complete_as_root; then
        local IFS='
';
        COMPREPLY=($( compgen -u -- "${1:-$cur}" ));
    else
        local IFS='
 ';
        COMPREPLY=($( compgen -W             "$( id -un 2>/dev/null || whoami 2>/dev/null )" -- "${1:-$cur}" ));
    fi
}
_authoscope ()
{
    local i cur prev opts cmds;
    COMPREPLY=();
    cur="${COMP_WORDS[COMP_CWORD]}";
    prev="${COMP_WORDS[COMP_CWORD-1]}";
    cmd="";
    opts="";
    for i in ${COMP_WORDS[@]};
    do
        case "${i}" in
            authoscope)
                cmd="authoscope"
            ;;
            combo)
                cmd+="__combo"
            ;;
            completions)
                cmd+="__completions"
            ;;
            dict)
                cmd+="__dict"
            ;;
            enum)
                cmd+="__enum"
            ;;
            fsck)
                cmd+="__fsck"
            ;;
            help)
                cmd+="__help"
            ;;
            run)
                cmd+="__run"
            ;;
            *)

            ;;
        esac;
    done;
    case "${cmd}" in
        authoscope)
            opts=" -v -h -V -n -o  --verbose --help --version --workers --output   dict combo enum run fsck completions help";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 1 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                --workers)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -n)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --output)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -o)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        authoscope__combo)
            opts=" -h -V -v  --help --version --verbose  <path> <scripts>... ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        authoscope__completions)
            opts=" -h -V -v  --help --version --verbose  <shell> ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        authoscope__dict)
            opts=" -h -V -v  --help --version --verbose  <users-path> <passwords-path> <scripts>... ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        authoscope__enum)
            opts=" -h -V -v  --help --version --verbose  <users> <scripts>... ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        authoscope__fsck)
            opts=" -q -s -c -h -V -v  --quiet --silent --colon --help --version --verbose  <paths>... ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        authoscope__help)
            opts=" -h -V -v  --help --version --verbose  ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        authoscope__run)
            opts=" -x -h -V -v  --exitcode --help --version --verbose  <script> <user> <password> ";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
    esac
}
_available_interfaces ()
{
    local cmd;
    if [ "${1:-}" = -w ]; then
        cmd="iwconfig";
    else
        if [ "${1:-}" = -a ]; then
            cmd="ifconfig";
        else
            cmd="ifconfig -a";
        fi;
    fi;
    COMPREPLY=($( eval PATH="$PATH:/sbin" $cmd 2>/dev/null |         awk '/^[^ \t]/ { print $1 }' ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]/%[[:punct:]]/}' -- "$cur" ))
}
_bat ()
{
    local cur prev words cword split=false;
    if declare -F _init_completion > /dev/null 2>&1; then
        _init_completion -s || return 0;
    else
        __bat_init_completion -n "=" || return 0;
        _split_longopt && split=true;
    fi;
    if [[ ${words[1]-} == cache ]]; then
        case $prev in
            --source | --target)
                _filedir -d;
                return 0
            ;;
        esac;
        COMPREPLY=($(compgen -W "
			--build
			--clear
			--source
			--target
			--blank
			--help
		" -- "$cur"));
        return 0;
    fi;
    case $prev in
        -l | --language)
            local IFS='
';
            COMPREPLY=($(compgen -W "$(
			"$1" --list-languages | while IFS=: read -r lang _; do
				printf "%s\n" "$lang"
			done
		)" -- "$cur"));
            __bat_escape_completions;
            return 0
        ;;
        -H | --highlight-line | --diff-context | --tabs | --terminal-width | -m | --map-syntax | --ignored-suffix | --list-themes | --line-range | -L | --list-languages | --diagnostic | --acknowledgements | -h | --help | -V | --version | --cache-dir | --config-dir | --config-file | --generate-config-file)
            return 0
        ;;
        --file-name)
            _filedir;
            return 0
        ;;
        --wrap)
            COMPREPLY=($(compgen -W "auto never character" -- "$cur"));
            return 0
        ;;
        --color | --decorations | --paging)
            COMPREPLY=($(compgen -W "auto never always" -- "$cur"));
            return 0
        ;;
        --italic-text)
            COMPREPLY=($(compgen -W "always never" -- "$cur"));
            return 0
        ;;
        --pager)
            COMPREPLY=($(compgen -c -- "$cur"));
            return 0
        ;;
        --theme)
            local IFS='
';
            COMPREPLY=($(compgen -W "$("$1" --list-themes)" -- "$cur"));
            __bat_escape_completions;
            return 0
        ;;
        --style)
            local -a styles=(default full auto plain changes header header-filename header-filesize grid rule numbers snip);
            if declare -F _comp_delimited > /dev/null 2>&1; then
                _comp_delimited , -W '"${styles[@]}"';
            else
                COMPREPLY=($(compgen -W '${styles[@]}' -- "$cur"));
            fi;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ $cur == -* ]]; then
        COMPREPLY=($(compgen -W "
			--show-all
			--plain
			--language
			--highlight-line
			--file-name
			--diff
			--diff-context
			--tabs
			--wrap
			--terminal-width
			--number
			--color
			--italic-text
			--decorations
			--force-colorization
			--paging
			--pager
			--map-syntax
			--ignored-suffix
			--theme
			--list-themes
			--style
			--line-range
			--list-languages
			--diagnostic
			--acknowledgements
			--help
			--version
			--cache-dir
			--config-dir
			--config-file
			--generate-config-file
		" -- "$cur"));
        return 0;
    fi;
    _filedir
}
_brctl ()
{
    local cur command;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    command=${COMP_WORDS[1]};
    case $COMP_CWORD in
        1)
            COMPREPLY=($( compgen -W "addbr delbr addif delif                 setageing setbridgeprio setfd sethello                 setmaxage setpathcost setportprio show                 showmacs showstp stp" -- "$cur" ))
        ;;
        2)
            case $command in
                show)

                ;;
                *)
                    COMPREPLY=($( compgen -W "$(brctl show |                         awk 'NR>1 {print $1}' )" -- "$cur" ))
                ;;
            esac
        ;;
        3)
            case $command in
                addif | delif)
                    _configured_interfaces
                ;;
                stp)
                    COMPREPLY=($( compgen -W 'on off' -- "$cur" ))
                ;;
            esac
        ;;
    esac
}
_brew ()
{
    local i=1 cmd;
    while [[ "${i}" -lt "${COMP_CWORD}" ]]; do
        local s="${COMP_WORDS[i]}";
        case "${s}" in
            --*)
                cmd="${s}";
                break
            ;;
            -*)

            ;;
            *)
                cmd="${s}";
                break
            ;;
        esac;
        (( i++ ));
    done;
    if [[ "${i}" -eq "${COMP_CWORD}" ]]; then
        __brew_complete_commands;
        return;
    fi;
    case "${cmd}" in
        --cache)
            _brew___cache
        ;;
        --caskroom)
            _brew___caskroom
        ;;
        --cellar)
            _brew___cellar
        ;;
        --config)
            _brew___config
        ;;
        --env)
            _brew___env
        ;;
        --prefix)
            _brew___prefix
        ;;
        --repo)
            _brew___repo
        ;;
        --repository)
            _brew___repository
        ;;
        -S)
            _brew__s
        ;;
        abv)
            _brew_abv
        ;;
        analytics)
            _brew_analytics
        ;;
        audit)
            _brew_audit
        ;;
        autoremove)
            _brew_autoremove
        ;;
        bottle)
            _brew_bottle
        ;;
        bump)
            _brew_bump
        ;;
        bump-cask-pr)
            _brew_bump_cask_pr
        ;;
        bump-formula-pr)
            _brew_bump_formula_pr
        ;;
        bump-revision)
            _brew_bump_revision
        ;;
        bump-unversioned-casks)
            _brew_bump_unversioned_casks
        ;;
        cat)
            _brew_cat
        ;;
        cleanup)
            _brew_cleanup
        ;;
        command)
            _brew_command
        ;;
        commands)
            _brew_commands
        ;;
        completions)
            _brew_completions
        ;;
        config)
            _brew_config
        ;;
        contributions)
            _brew_contributions
        ;;
        create)
            _brew_create
        ;;
        deps)
            _brew_deps
        ;;
        desc)
            _brew_desc
        ;;
        determine-test-runners)
            _brew_determine_test_runners
        ;;
        developer)
            _brew_developer
        ;;
        dispatch-build-bottle)
            _brew_dispatch_build_bottle
        ;;
        docs)
            _brew_docs
        ;;
        doctor)
            _brew_doctor
        ;;
        dr)
            _brew_dr
        ;;
        edit)
            _brew_edit
        ;;
        environment)
            _brew_environment
        ;;
        extract)
            _brew_extract
        ;;
        fetch)
            _brew_fetch
        ;;
        formula)
            _brew_formula
        ;;
        generate-cask-api)
            _brew_generate_cask_api
        ;;
        generate-formula-api)
            _brew_generate_formula_api
        ;;
        generate-man-completions)
            _brew_generate_man_completions
        ;;
        gist-logs)
            _brew_gist_logs
        ;;
        home)
            _brew_home
        ;;
        homepage)
            _brew_homepage
        ;;
        info)
            _brew_info
        ;;
        instal)
            _brew_instal
        ;;
        install)
            _brew_install
        ;;
        install-bundler-gems)
            _brew_install_bundler_gems
        ;;
        irb)
            _brew_irb
        ;;
        lc)
            _brew_lc
        ;;
        leaves)
            _brew_leaves
        ;;
        link)
            _brew_link
        ;;
        linkage)
            _brew_linkage
        ;;
        list)
            _brew_list
        ;;
        livecheck)
            _brew_livecheck
        ;;
        ln)
            _brew_ln
        ;;
        log)
            _brew_log
        ;;
        ls)
            _brew_ls
        ;;
        migrate)
            _brew_migrate
        ;;
        missing)
            _brew_missing
        ;;
        nodenv-sync)
            _brew_nodenv_sync
        ;;
        options)
            _brew_options
        ;;
        outdated)
            _brew_outdated
        ;;
        pin)
            _brew_pin
        ;;
        postgresql-upgrade-database)
            _brew_postgresql_upgrade_database
        ;;
        postinstall)
            _brew_postinstall
        ;;
        pr-automerge)
            _brew_pr_automerge
        ;;
        pr-publish)
            _brew_pr_publish
        ;;
        pr-pull)
            _brew_pr_pull
        ;;
        pr-upload)
            _brew_pr_upload
        ;;
        prof)
            _brew_prof
        ;;
        rbenv-sync)
            _brew_rbenv_sync
        ;;
        readall)
            _brew_readall
        ;;
        reinstall)
            _brew_reinstall
        ;;
        release)
            _brew_release
        ;;
        remove)
            _brew_remove
        ;;
        rm)
            _brew_rm
        ;;
        ruby)
            _brew_ruby
        ;;
        search)
            _brew_search
        ;;
        sh)
            _brew_sh
        ;;
        style)
            _brew_style
        ;;
        tap)
            _brew_tap
        ;;
        tap-info)
            _brew_tap_info
        ;;
        tap-new)
            _brew_tap_new
        ;;
        tc)
            _brew_tc
        ;;
        test)
            _brew_test
        ;;
        tests)
            _brew_tests
        ;;
        typecheck)
            _brew_typecheck
        ;;
        unbottled)
            _brew_unbottled
        ;;
        uninstal)
            _brew_uninstal
        ;;
        uninstall)
            _brew_uninstall
        ;;
        unlink)
            _brew_unlink
        ;;
        unpack)
            _brew_unpack
        ;;
        unpin)
            _brew_unpin
        ;;
        untap)
            _brew_untap
        ;;
        up)
            _brew_up
        ;;
        update)
            _brew_update
        ;;
        update-license-data)
            _brew_update_license_data
        ;;
        update-maintainers)
            _brew_update_maintainers
        ;;
        update-python-resources)
            _brew_update_python_resources
        ;;
        update-report)
            _brew_update_report
        ;;
        update-sponsors)
            _brew_update_sponsors
        ;;
        update-test)
            _brew_update_test
        ;;
        upgrade)
            _brew_upgrade
        ;;
        uses)
            _brew_uses
        ;;
        vendor-gems)
            _brew_vendor_gems
        ;;
        *)

        ;;
    esac
}
_brew___cache ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --HEAD
      --bottle-tag
      --build-from-source
      --cask
      --debug
      --force-bottle
      --formula
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae;
    __brew_complete_casks
}
_brew___caskroom ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_casks
}
_brew___cellar ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae
}
_brew___config ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew___env ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --plain
      --quiet
      --shell
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae
}
_brew___prefix ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --installed
      --quiet
      --unbrewed
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae
}
_brew___repo ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_tapped
}
_brew___repository ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_tapped
}
_brew__s ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --archlinux
      --cask
      --closed
      --debian
      --debug
      --desc
      --eval-all
      --fedora
      --fink
      --formula
      --help
      --macports
      --open
      --opensuse
      --pull-request
      --quiet
      --repology
      --ubuntu
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_abv ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --analytics
      --cask
      --category
      --days
      --debug
      --eval-all
      --formula
      --github
      --help
      --installed
      --json
      --quiet
      --variations
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae;
    __brew_complete_casks
}
_brew_analytics ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brewcomp "state on off regenerate-uuid"
}
_brew_audit ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --audit-debug
      --cask
      --debug
      --display-filename
      --eval-all
      --except
      --except-cops
      --fix
      --formula
      --git
      --help
      --installed
      --new
      --no-signing
      --online
      --only
      --only-cops
      --quiet
      --signing
      --skip-style
      --strict
      --tap
      --token-conflicts
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae;
    __brew_complete_casks
}
_brew_autoremove ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --dry-run
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_bottle ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --committer
      --debug
      --force-core-tap
      --help
      --json
      --keep-old
      --merge
      --no-all-checks
      --no-commit
      --no-rebuild
      --only-json-tab
      --quiet
      --root-url
      --root-url-using
      --skip-relocation
      --verbose
      --write
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_installed_formulae;
    __brew_complete_files
}
_brew_bump ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --cask
      --debug
      --formula
      --full-name
      --help
      --limit
      --no-pull-requests
      --open-pr
      --quiet
      --start-with
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae;
    __brew_complete_casks
}
_brew_bump_cask_pr ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --commit
      --debug
      --dry-run
      --force
      --fork-org
      --help
      --message
      --no-audit
      --no-browse
      --no-fork
      --no-style
      --online
      --quiet
      --sha256
      --url
      --verbose
      --version
      --write-only
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_casks
}
_brew_bump_formula_pr ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --commit
      --debug
      --dry-run
      --force
      --fork-org
      --help
      --message
      --mirror
      --no-audit
      --no-browse
      --no-fork
      --online
      --python-exclude-packages
      --python-extra-packages
      --python-package-name
      --quiet
      --revision
      --sha256
      --strict
      --tag
      --url
      --verbose
      --version
      --write-only
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae
}
_brew_bump_revision ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --dry-run
      --help
      --message
      --quiet
      --remove-bottle-block
      --verbose
      --write-only
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae
}
_brew_bump_unversioned_casks ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --dry-run
      --help
      --limit
      --quiet
      --state-file
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_casks;
    __brew_complete_tapped
}
_brew_cat ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --cask
      --debug
      --formula
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae;
    __brew_complete_casks
}
_brew_cleanup ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --dry-run
      --help
      --prune
      --prune-prefix
      --quiet
      --verbose
      -s
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae;
    __brew_complete_casks
}
_brew_command ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_commands
}
_brew_commands ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --include-aliases
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_completions ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brewcomp "state link unlink"
}
_brew_config ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_contributions ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --csv
      --debug
      --from
      --help
      --quiet
      --repositories
      --to
      --user
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_create ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --HEAD
      --autotools
      --cask
      --cmake
      --crystal
      --debug
      --force
      --go
      --help
      --meson
      --no-fetch
      --node
      --perl
      --python
      --quiet
      --ruby
      --rust
      --set-license
      --set-name
      --set-version
      --tap
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_deps ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --annotate
      --cask
      --debug
      --direct
      --dot
      --eval-all
      --for-each
      --formula
      --full-name
      --graph
      --help
      --include-build
      --include-optional
      --include-requirements
      --include-test
      --installed
      --quiet
      --skip-recommended
      --topological
      --tree
      --union
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae;
    __brew_complete_casks
}
_brew_desc ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --cask
      --debug
      --description
      --eval-all
      --formula
      --help
      --name
      --quiet
      --search
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae;
    __brew_complete_casks
}
_brew_determine_test_runners ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --dependents
      --eval-all
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_developer ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brewcomp "state on off"
}
_brew_dispatch_build_bottle ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --issue
      --linux
      --linux-self-hosted
      --linux-wheezy
      --macos
      --quiet
      --tap
      --timeout
      --upload
      --verbose
      --workflow
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae
}
_brew_docs ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_doctor ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --audit-debug
      --debug
      --help
      --list-checks
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brewcomp "${__HOMEBREW_DOCTOR_CHECKS=$(brew doctor --list-checks)}"
}
_brew_dr ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --audit-debug
      --debug
      --help
      --list-checks
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brewcomp "${__HOMEBREW_DOCTOR_CHECKS=$(brew doctor --list-checks)}"
}
_brew_edit ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --cask
      --debug
      --formula
      --help
      --print-path
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae;
    __brew_complete_casks
}
_brew_environment ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --plain
      --quiet
      --shell
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae
}
_brew_extract ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --force
      --help
      --quiet
      --verbose
      --version
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae;
    __brew_complete_tapped
}
_brew_fetch ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --HEAD
      --bottle-tag
      --build-bottle
      --build-from-source
      --cask
      --debug
      --deps
      --force
      --force-bottle
      --formula
      --help
      --no-quarantine
      --quarantine
      --quiet
      --retry
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae;
    __brew_complete_casks
}
_brew_formula ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae
}
_brew_generate_cask_api ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_generate_formula_api ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_generate_man_completions ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_gist_logs ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --new-issue
      --private
      --quiet
      --verbose
      --with-hostname
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae
}
_brew_home ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --cask
      --debug
      --formula
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae;
    __brew_complete_casks
}
_brew_homepage ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --cask
      --debug
      --formula
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae;
    __brew_complete_casks
}
_brew_info ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --analytics
      --cask
      --category
      --days
      --debug
      --eval-all
      --formula
      --github
      --help
      --installed
      --json
      --quiet
      --variations
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae;
    __brew_complete_casks
}
_brew_instal ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --HEAD
      --adopt
      --appdir
      --audio-unit-plugindir
      --binaries
      --bottle-arch
      --build-bottle
      --build-from-source
      --cask
      --cc
      --colorpickerdir
      --debug
      --debug-symbols
      --dictionarydir
      --display-times
      --dry-run
      --fetch-HEAD
      --fontdir
      --force
      --force-bottle
      --formula
      --git
      --help
      --ignore-dependencies
      --include-test
      --input-methoddir
      --interactive
      --internet-plugindir
      --keep-tmp
      --keyboard-layoutdir
      --language
      --mdimporterdir
      --no-binaries
      --no-quarantine
      --only-dependencies
      --overwrite
      --prefpanedir
      --qlplugindir
      --quarantine
      --quiet
      --require-sha
      --screen-saverdir
      --servicedir
      --skip-cask-deps
      --skip-post-install
      --verbose
      --vst-plugindir
      --vst3-plugindir
      --zap
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae;
    __brew_complete_casks
}
_brew_install ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --HEAD
      --adopt
      --appdir
      --audio-unit-plugindir
      --binaries
      --bottle-arch
      --build-bottle
      --build-from-source
      --cask
      --cc
      --colorpickerdir
      --debug
      --debug-symbols
      --dictionarydir
      --display-times
      --dry-run
      --fetch-HEAD
      --fontdir
      --force
      --force-bottle
      --formula
      --git
      --help
      --ignore-dependencies
      --include-test
      --input-methoddir
      --interactive
      --internet-plugindir
      --keep-tmp
      --keyboard-layoutdir
      --language
      --mdimporterdir
      --no-binaries
      --no-quarantine
      --only-dependencies
      --overwrite
      --prefpanedir
      --qlplugindir
      --quarantine
      --quiet
      --require-sha
      --screen-saverdir
      --servicedir
      --skip-cask-deps
      --skip-post-install
      --verbose
      --vst-plugindir
      --vst3-plugindir
      --zap
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae;
    __brew_complete_casks
}
_brew_install_bundler_gems ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --groups
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_irb ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --examples
      --help
      --pry
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_lc ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --cask
      --debug
      --eval-all
      --formula
      --full-name
      --help
      --installed
      --json
      --newer-only
      --quiet
      --resources
      --tap
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae;
    __brew_complete_casks
}
_brew_leaves ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --installed-as-dependency
      --installed-on-request
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_link ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --HEAD
      --debug
      --dry-run
      --force
      --help
      --overwrite
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_installed_formulae
}
_brew_linkage ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --cached
      --debug
      --help
      --quiet
      --reverse
      --strict
      --test
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_installed_formulae
}
_brew_list ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --cask
      --debug
      --formula
      --full-name
      --help
      --multiple
      --pinned
      --quiet
      --verbose
      --versions
      -1
      -l
      -r
      -t
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_installed_formulae;
    __brew_complete_installed_casks
}
_brew_livecheck ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --cask
      --debug
      --eval-all
      --formula
      --full-name
      --help
      --installed
      --json
      --newer-only
      --quiet
      --resources
      --tap
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae;
    __brew_complete_casks
}
_brew_ln ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --HEAD
      --debug
      --dry-run
      --force
      --help
      --overwrite
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_installed_formulae
}
_brew_log ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --cask
      --debug
      --formula
      --help
      --max-count
      --oneline
      --patch
      --quiet
      --stat
      --verbose
      -1
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae;
    __brew_complete_casks
}
_brew_ls ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --cask
      --debug
      --formula
      --full-name
      --help
      --multiple
      --pinned
      --quiet
      --verbose
      --versions
      -1
      -l
      -r
      -t
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_installed_formulae;
    __brew_complete_installed_casks
}
_brew_migrate ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --dry-run
      --force
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_installed_formulae
}
_brew_missing ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --hide
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae
}
_brew_nodenv_sync ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_options ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --command
      --compact
      --debug
      --eval-all
      --help
      --installed
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae
}
_brew_outdated ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --cask
      --debug
      --fetch-HEAD
      --formula
      --greedy
      --greedy-auto-updates
      --greedy-latest
      --help
      --json
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae;
    __brew_complete_casks
}
_brew_pin ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_installed_formulae
}
_brew_postgresql_upgrade_database ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_postinstall ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_installed_formulae
}
_brew_pr_automerge ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --autosquash
      --debug
      --help
      --ignore-failures
      --no-autosquash
      --publish
      --quiet
      --tap
      --verbose
      --with-label
      --without-approval
      --without-labels
      --workflow
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_pr_publish ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --autosquash
      --branch
      --debug
      --help
      --large-runner
      --message
      --no-autosquash
      --quiet
      --tap
      --verbose
      --workflow
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_pr_pull ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --artifact
      --autosquash
      --branch-okay
      --clean
      --committer
      --debug
      --dry-run
      --help
      --ignore-missing-artifacts
      --keep-old
      --message
      --no-autosquash
      --no-cherry-pick
      --no-commit
      --no-upload
      --quiet
      --resolve
      --root-url
      --root-url-using
      --tap
      --verbose
      --warn-on-upload-failure
      --workflows
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_pr_upload ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --committer
      --debug
      --dry-run
      --help
      --keep-old
      --no-commit
      --quiet
      --root-url
      --root-url-using
      --upload-only
      --verbose
      --warn-on-upload-failure
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_prof ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --quiet
      --stackprof
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_commands
}
_brew_rbenv_sync ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_readall ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --aliases
      --debug
      --eval-all
      --help
      --no-simulate
      --quiet
      --syntax
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_tapped
}
_brew_reinstall ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --adopt
      --appdir
      --audio-unit-plugindir
      --binaries
      --build-from-source
      --cask
      --colorpickerdir
      --debug
      --debug-symbols
      --dictionarydir
      --display-times
      --fontdir
      --force
      --force-bottle
      --formula
      --git
      --help
      --input-methoddir
      --interactive
      --internet-plugindir
      --keep-tmp
      --keyboard-layoutdir
      --language
      --mdimporterdir
      --no-binaries
      --no-quarantine
      --prefpanedir
      --qlplugindir
      --quarantine
      --quiet
      --require-sha
      --screen-saverdir
      --servicedir
      --skip-cask-deps
      --verbose
      --vst-plugindir
      --vst3-plugindir
      --zap
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae;
    __brew_complete_casks
}
_brew_release ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --major
      --minor
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_remove ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --cask
      --debug
      --force
      --formula
      --help
      --ignore-dependencies
      --quiet
      --verbose
      --zap
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_installed_formulae;
    __brew_complete_installed_casks
}
_brew_rm ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --cask
      --debug
      --force
      --formula
      --help
      --ignore-dependencies
      --quiet
      --verbose
      --zap
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_installed_formulae;
    __brew_complete_installed_casks
}
_brew_ruby ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --quiet
      --verbose
      -e
      -r
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_files
}
_brew_search ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --archlinux
      --cask
      --closed
      --debian
      --debug
      --desc
      --eval-all
      --fedora
      --fink
      --formula
      --help
      --macports
      --open
      --opensuse
      --pull-request
      --quiet
      --repology
      --ubuntu
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_sh ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --cmd
      --debug
      --env
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_files
}
_brew_style ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --cask
      --debug
      --except-cops
      --fix
      --formula
      --help
      --only-cops
      --quiet
      --reset-cache
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_files;
    __brew_complete_tapped;
    __brew_complete_formulae;
    __brew_complete_casks
}
_brew_tap ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --custom-remote
      --debug
      --eval-all
      --force-auto-update
      --help
      --list-pinned
      --no-force-auto-update
      --quiet
      --repair
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_tapped
}
_brew_tap_info ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --installed
      --json
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_tapped
}
_brew_tap_new ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --branch
      --debug
      --github-packages
      --help
      --no-git
      --pull-label
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_tapped
}
_brew_tc ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --dir
      --file
      --fix
      --help
      --ignore
      --quiet
      --suggest-typed
      --update
      --update-all
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_test ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --HEAD
      --debug
      --force
      --help
      --keep-tmp
      --quiet
      --retry
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_installed_formulae
}
_brew_tests ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --byebug
      --changed
      --coverage
      --debug
      --generic
      --help
      --online
      --only
      --quiet
      --seed
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_to_completion ()
{
    _brew
}
_brew_typecheck ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --dir
      --file
      --fix
      --help
      --ignore
      --quiet
      --suggest-typed
      --update
      --update-all
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_unbottled ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --dependents
      --eval-all
      --help
      --quiet
      --tag
      --total
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae
}
_brew_uninstal ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --cask
      --debug
      --force
      --formula
      --help
      --ignore-dependencies
      --quiet
      --verbose
      --zap
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_installed_formulae;
    __brew_complete_installed_casks
}
_brew_uninstall ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --cask
      --debug
      --force
      --formula
      --help
      --ignore-dependencies
      --quiet
      --verbose
      --zap
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_installed_formulae;
    __brew_complete_installed_casks
}
_brew_unlink ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --dry-run
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_installed_formulae
}
_brew_unpack ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --destdir
      --force
      --git
      --help
      --patch
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae
}
_brew_unpin ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_installed_formulae
}
_brew_untap ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --force
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_tapped
}
_brew_up ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --auto-update
      --debug
      --force
      --help
      --merge
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_update ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --auto-update
      --debug
      --force
      --help
      --merge
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_update_license_data ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_update_maintainers ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_update_python_resources ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --exclude-packages
      --extra-packages
      --help
      --ignore-non-pypi-packages
      --package-name
      --print-only
      --quiet
      --silent
      --verbose
      --version
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae
}
_brew_update_report ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --auto-update
      --debug
      --force
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_update_sponsors ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --quiet
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_update_test ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --before
      --commit
      --debug
      --help
      --keep-tmp
      --quiet
      --to-tag
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac
}
_brew_upgrade ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --appdir
      --audio-unit-plugindir
      --binaries
      --build-from-source
      --cask
      --colorpickerdir
      --debug
      --debug-symbols
      --dictionarydir
      --display-times
      --dry-run
      --fetch-HEAD
      --fontdir
      --force
      --force-bottle
      --formula
      --greedy
      --greedy-auto-updates
      --greedy-latest
      --help
      --ignore-pinned
      --input-methoddir
      --interactive
      --internet-plugindir
      --keep-tmp
      --keyboard-layoutdir
      --language
      --mdimporterdir
      --no-binaries
      --no-quarantine
      --prefpanedir
      --qlplugindir
      --quarantine
      --quiet
      --require-sha
      --screen-saverdir
      --servicedir
      --skip-cask-deps
      --verbose
      --vst-plugindir
      --vst3-plugindir
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_outdated_formulae;
    __brew_complete_outdated_casks
}
_brew_uses ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --cask
      --debug
      --eval-all
      --formula
      --help
      --include-build
      --include-optional
      --include-test
      --installed
      --quiet
      --recursive
      --skip-recommended
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac;
    __brew_complete_formulae
}
_brew_vendor_gems ()
{
    local cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in
        -*)
            __brewcomp "
      --debug
      --help
      --no-commit
      --quiet
      --update
      --verbose
      ";
            return
        ;;
        *)

        ;;
    esac
}
_bzip2 ()
{
    local cur prev xspec helpopts;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    helpopts=`_parse_help ${COMP_WORDS[0]}`;
    case $prev in
        -b | -h | --help | -p)
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W "${helpopts//#/} -2 -3 -4 -5 -6 -7 -8 -9"             -- "$cur" ));
        return 0;
    fi;
    local IFS='
';
    xspec="*.bz2";
    if [[ "$prev" == --* ]]; then
        [[ "$prev" == --decompress || "$prev" == --list || "$prev" == --test ]] && xspec="!"$xspec;
        [[ "$prev" == --compress ]] && xspec=;
    else
        if [[ "$prev" == -* ]]; then
            [[ "$prev" == -*[dt]* ]] && xspec="!"$xspec;
            [[ "$prev" == -*z* ]] && xspec=;
        fi;
    fi;
    _expand || return 0;
    _compopt_o_filenames;
    COMPREPLY=($( compgen -f -X "$xspec" -- "$cur" ) $( compgen -d -- "$cur" ))
}
_cancel ()
{
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    COMPREPLY=($( compgen -W "$( lpstat | cut -d' ' -f1 )" -- "$cur" ))
}
_cd ()
{
    local cur IFS='
' i j k;
    _get_comp_words_by_ref cur;
    if [[ "$cur" == ?(\\)\$* ]]; then
        COMPREPLY=($( compgen -v -P '$' -- "${cur#?(\\)$}" ));
        return 0;
    fi;
    _compopt_o_filenames;
    if [[ -z "${CDPATH:-}" || "$cur" == ?(.)?(.)/* ]]; then
        _filedir -d;
        return 0;
    fi;
    local -r mark_dirs=$(_rl_enabled mark-directories && echo y);
    local -r mark_symdirs=$(_rl_enabled mark-symlinked-directories && echo y);
    for i in ${CDPATH//:/'
'};
    do
        k="${#COMPREPLY[@]}";
        for j in $( compgen -d $i/$cur );
        do
            if [[ ( -n $mark_symdirs && -h $j || -n $mark_dirs && ! -h $j ) && ! -d ${j#$i/} ]]; then
                j="${j}/";
            fi;
            COMPREPLY[k++]=${j#$i/};
        done;
    done;
    _filedir -d;
    if [[ ${#COMPREPLY[@]} -eq 1 ]]; then
        i=${COMPREPLY[0]};
        if [[ "$i" == "$cur" && $i != "*/" ]]; then
            COMPREPLY[0]="${i}/";
        fi;
    fi;
    return 0
}
_cd_devices ()
{
    COMPREPLY=("${COMPREPLY[@]}" $( compgen -f -d -X "!*/?([amrs])cd*" -- "${cur:-/dev/}" ))
}
_cheat ()
{
    local cur prev words cword split;
    _init_completion -s || return;
    if [[ $cur == -* ]]; then
        COMPREPLY=($(compgen -W '$(_parse_help "$1" | sed "s/=//g")' -- "$cur"));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
        return;
    fi;
    case $prev in
        --colorize | -c | --directories | -d | --init | --regex | -r | --search | -s | --tags | -T | --version | -v)

        ;;
        --edit | -e)
            _cheat_complete_cheatsheets
        ;;
        --list | -l)
            _cheat_complete_cheatsheets
        ;;
        --path | -p)
            COMPREPLY=($(compgen -W "$(cheat -d | cut -d':' -f1)" -- "$cur"))
        ;;
        --rm)
            _cheat_complete_cheatsheets
        ;;
        --tag | -t)
            _cheat_complete_tags
        ;;
        *)
            _cheat_complete_cheatsheets
        ;;
    esac;
    $split && return
}
_cheat_complete_cheatsheets ()
{
    if [[ "$CHEAT_USE_FZF" = true ]]; then
        FZF_COMPLETION_TRIGGER='' _fzf_complete "--no-multi" "$@" < <(
      cheat -l | tail -n +2 | cut -d' ' -f1
    );
    else
        COMPREPLY=($(compgen -W "$(cheat -l | tail -n +2 | cut -d' ' -f1)" -- "$cur"));
    fi
}
_cheat_complete_tags ()
{
    if [ "$CHEAT_USE_FZF" = true ]; then
        FZF_COMPLETION_TRIGGER='' _fzf_complete "--no-multi" "$@" < <(cheat -T);
    else
        COMPREPLY=($(compgen -W "$(cheat -T)" -- "$cur"));
    fi
}
_chgrp ()
{
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    cur=${cur//\\\\/};
    _split_longopt && split=true;
    if [[ "$prev" == --reference ]]; then
        _filedir;
        return 0;
    fi;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        local w opts;
        for w in "${COMP_WORDS[@]}";
        do
            [[ "$w" == -@(R|-recursive) ]] && opts="-H -L -P" && break;
        done;
        COMPREPLY=($( compgen -W '-c -h -f -R -v --changes --dereference \
            --no-dereference --silent --quiet --reference --recursive \
            --verbose --help --version $opts' -- "$cur" ));
        return 0;
    fi;
    if [[ $COMP_CWORD -eq 1 && "$cur" != -* || "$prev" == -* ]]; then
        _allowed_groups;
    else
        _filedir || return 0;
    fi;
    return 0
}
_chown ()
{
    local cur prev split=false;
    _get_comp_words_by_ref -n : cur prev;
    _split_longopt && split=true;
    case "$prev" in
        --from)
            _usergroup;
            return 0
        ;;
        --reference)
            _filedir;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        local w opts;
        for w in "${COMP_WORDS[@]}";
        do
            [[ "$w" == -@(R|-recursive) ]] && opts="-H -L -P" && break;
        done;
        COMPREPLY=($( compgen -W '-c -h -f -R -v --changes --dereference \
            --no-dereference --from --silent --quiet --reference --recursive \
            --verbose --help --version $opts' -- "$cur" ));
    else
        local args;
        _count_args :;
        if [[ $args == 1 ]]; then
            _usergroup -u;
        else
            _filedir;
        fi;
    fi
}
_chsh ()
{
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in
        --list-shells | --help | -v | --version)
            return 0
        ;;
        -s | --shell)
            _shells;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* && "$( uname -s )" == @(Linux|GNU|GNU/*) ]]; then
        COMPREPLY=($( compgen -W '--shell --list-shells --help --version'             -- "$cur" ));
    else
        COMPREPLY=($( compgen -u -- "$cur" ));
    fi;
    return 0
}
_cmake ()
{
    local cur prev words cword split=false;
    if type -t _init_completion > /dev/null; then
        _init_completion -n = || return;
    else
        COMPREPLY=();
        cur="${COMP_WORDS[COMP_CWORD]}";
        prev="${COMP_WORDS[COMP_CWORD-1]}";
    fi;
    local prefix=;
    if [[ $cur == -D* ]]; then
        prev=-D;
        prefix=-D;
        cur="${cur#-D}";
    else
        if [[ $cur == -U* ]]; then
            prev=-U;
            prefix=-U;
            cur="${cur#-U}";
        fi;
    fi;
    case "$prev" in
        -D)
            if [[ $cur == *=* ]]; then
                local var type value;
                var="${cur%%[:=]*}";
                value="${cur#*=}";
                if [[ $cur == CMAKE_BUILD_TYPE* ]]; then
                    COMPREPLY=($( compgen -W 'Debug Release RelWithDebInfo
                        MinSizeRel' -- "$value" ));
                    return;
                fi;
                if [[ $cur == *:* ]]; then
                    type="${cur#*:}";
                    type="${type%%=*}";
                else
                    type=$( cmake -LA -N 2>/dev/null | grep "$var:"                         2>/dev/null );
                    type="${type#*:}";
                    type="${type%%=*}";
                fi;
                case "$type" in
                    FILEPATH)
                        cur="$value";
                        _filedir;
                        return
                    ;;
                    PATH)
                        cur="$value";
                        _filedir -d;
                        return
                    ;;
                    BOOL)
                        COMPREPLY=($( compgen -W 'ON OFF TRUE FALSE' --                             "$value" ));
                        return
                    ;;
                    STRING | INTERNAL)
                        return
                    ;;
                esac;
            else
                if [[ $cur == *:* ]]; then
                    local type="${cur#*:}";
                    COMPREPLY=($( compgen -W 'FILEPATH PATH STRING BOOL INTERNAL'                    -S = -- "$type" ));
                    compopt -o nospace;
                else
                    COMPREPLY=($( compgen -W '$( cmake -LA -N 2>/dev/null |
                    tail -n +2 | cut -f1 -d: )' -P "$prefix" -- "$cur" ));
                    compopt -o nospace;
                fi;
            fi;
            return
        ;;
        -U)
            COMPREPLY=($( compgen -W '$( cmake -LA -N | tail -n +2 |
                cut -f1 -d: )' -P "$prefix" -- "$cur" ));
            return
        ;;
    esac;
    _split_longopt && split=true;
    case "$prev" in
        -C | -P | --graphviz | --system-information)
            _filedir;
            return
        ;;
        --build)
            COMPREPLY=($( compgen -W "--preset --list-presets" -- "$cur" ));
            _filedir -d;
            return
        ;;
        --install | --open)
            _filedir -d;
            return
        ;;
        -E)
            COMPREPLY=($( compgen -W "$( cmake -E help |& sed -n                 '/^  [^ ]/{s|^  \([^ ]\{1,\}\) .*$|\1|;p}' 2>/dev/null )"                 -- "$cur" ));
            return
        ;;
        -G)
            local IFS='
';
            local quoted;
            printf -v quoted %q "$cur";
            COMPREPLY=($( compgen -W '$( cmake --help 2>/dev/null | sed -n \
                -e "1,/^Generators/d" \
                -e "/^  *[^ =]/{s|^ *\([^=]*[^ =]\).*$|\1|;s| |\\\\ |g;p}" \
                2>/dev/null )' -- "$quoted" ));
            return
        ;;
        --loglevel)
            COMPREPLY=($(compgen -W 'error warning notice status verbose debug trace' -- $cur ))
        ;;
        --help-command)
            COMPREPLY=($( compgen -W '$( cmake --help-command-list 2>/dev/null|
                grep -v "^cmake version " )' -- "$cur" ));
            return
        ;;
        --help-manual)
            COMPREPLY=($( compgen -W '$( cmake --help-manual-list 2>/dev/null|
                grep -v "^cmake version " | sed -e "s/([0-9])$//" )' -- "$cur" ));
            return
        ;;
        --help-module)
            COMPREPLY=($( compgen -W '$( cmake --help-module-list 2>/dev/null|
                grep -v "^cmake version " )' -- "$cur" ));
            return
        ;;
        --help-policy)
            COMPREPLY=($( compgen -W '$( cmake --help-policy-list 2>/dev/null |
                grep -v "^cmake version " )' -- "$cur" ));
            return
        ;;
        --help-property)
            COMPREPLY=($( compgen -W '$( cmake --help-property-list \
                2>/dev/null | grep -v "^cmake version " )' -- "$cur" ));
            return
        ;;
        --help-variable)
            COMPREPLY=($( compgen -W '$( cmake --help-variable-list \
                2>/dev/null | grep -v "^cmake version " )' -- "$cur" ));
            return
        ;;
        --list-presets)
            local IFS='
';
            local quoted;
            printf -v quoted %q "$cur";
            if [[ ! "${IFS}${COMP_WORDS[*]}${IFS}" =~ "${IFS}--build${IFS}" ]]; then
                COMPREPLY=($( compgen -W "configure${IFS}build${IFS}test${IFS}all" -- "$quoted" ));
            fi;
            return
        ;;
        --preset)
            local IFS='
';
            local quoted;
            printf -v quoted %q "$cur";
            local build_or_configure="configure";
            if [[ "${IFS}${COMP_WORDS[*]}${IFS}" =~ "${IFS}--build${IFS}" ]]; then
                build_or_configure="build";
            fi;
            local presets=$( cmake --list-presets="$build_or_configure" 2>/dev/null |
                grep -o "^  \".*\"" | sed                 -e "s/^  //g"                 -e "s/\"//g"                 -e 's/ /\\\\ /g' );
            COMPREPLY=($( compgen -W "$presets" -- "$quoted" ));
            return
        ;;
    esac;
    $split && return;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W '$( _parse_help "$1" --help )' -- ${cur}));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
        [[ -n $COMPREPLY ]] && return;
    fi;
    _filedir
}
_command ()
{
    local offset i;
    offset=1;
    for ((i=1; i <= COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            offset=$i;
            break;
        fi;
    done;
    _command_offset $offset
}
_command_offset ()
{
    local cur func cline cspec noglob cmd i char_offset word_offset _COMMAND_FUNC _COMMAND_FUNC_ARGS;
    word_offset=$1;
    local first_word=${COMP_WORDS[$word_offset]};
    for ((i=0; i <= ${#COMP_LINE}; i++ ))
    do
        if [[ "${COMP_LINE:$i:${#first_word}}" == "$first_word" ]]; then
            char_offset=$i;
            break;
        fi;
    done;
    COMP_LINE=${COMP_LINE:$char_offset};
    COMP_POINT=$(( COMP_POINT - $char_offset ));
    for ((i=0; i <= COMP_CWORD - $word_offset; i++ ))
    do
        COMP_WORDS[i]=${COMP_WORDS[i+$word_offset]};
    done;
    for ((i; i <= COMP_CWORD; i++ ))
    do
        unset COMP_WORDS[i];
    done;
    COMP_CWORD=$(( $COMP_CWORD - $word_offset ));
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [[ $COMP_CWORD -eq 0 ]]; then
        _compopt_o_filenames;
        COMPREPLY=($( compgen -c -- "$cur" ));
    else
        cmd=${COMP_WORDS[0]};
        if complete -p ${cmd##*/} >&/dev/null; then
            cspec=$( complete -p ${cmd##*/} );
            if [ "${cspec#* -F }" != "$cspec" ]; then
                func=${cspec#*-F };
                func=${func%% *};
                if [[ ${#COMP_WORDS[@]} -ge 2 ]]; then
                    $func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}" "${COMP_WORDS[${#COMP_WORDS[@]}-2]}";
                else
                    $func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}";
                fi;
                if [ "${cspec#*-o }" != "$cspec" ]; then
                    cspec=${cspec#*-o };
                    cspec=${cspec%% *};
                    if [[ "$cspec" != @(dir|file)names ]]; then
                        COMPREPLY=("${COMPREPLY[@]//\\\\:/:}");
                    else
                        _compopt_o_filenames;
                    fi;
                fi;
            else
                if [ -n "$cspec" ]; then
                    cspec=${cspec#complete};
                    cspec=${cspec%%${cmd##*/}};
                    COMPREPLY=($( eval compgen "$cspec" -- "$cur" ));
                fi;
            fi;
        else
            if [ ${#COMPREPLY[@]} -eq 0 ]; then
                _filedir;
            fi;
        fi;
    fi
}
_complete ()
{
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in
        -o)
            COMPREPLY=($( compgen -W 'bashdefault default dirnames filenames \
                nospace plusdirs' -- "$cur" ));
            return 0
        ;;
        -A)
            COMPREPLY=($( compgen -W 'alias arrayvar binding builtin command \
                directory disabled enabled export file function group \
                helptopic hostname job keyword running service setopt shopt \
                signal stopped user variable' -- "$cur" ));
            return 0
        ;;
        -C)
            COMPREPLY=($( compgen -A command -- "$cur" ));
            return 0
        ;;
        -F)
            COMPREPLY=($( compgen -A function -- "$cur" ));
            return 0
        ;;
        -p | -r)
            COMPREPLY=($( complete -p | sed -e 's|.* ||' ));
            COMPREPLY=($( compgen -W '${COMPREPLY[@]}' -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        local opts="-a -b -c -d -e -f -g -j -k -o -s -u -v -A -G -W -P -S -X";
        [[ $1 != compgen ]] && opts="$opts -F -C";
        COMPREPLY=($( compgen -W "$opts" -- "$cur" ));
    else
        COMPREPLY=($( compgen -A command -- "$cur" ));
    fi
}
_complete_as_root ()
{
    [[ $EUID -eq 0 || -n ${root_command:-} ]]
}
_compopt_o_filenames ()
{
    type compopt >&/dev/null && compopt -o filenames 2> /dev/null || compgen -f /non-existing-dir/ > /dev/null
}
_configure ()
{
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in
        --*prefix | --*dir)
            _filedir -d
        ;;
    esac;
    $split && return 0;
    [[ "$cur" != -* ]] && return 0;
    if [ -n "$COMP_CONFIGURE_HINTS" ]; then
        COMPREPLY=($( compgen -W "$( $1 --help 2>&1 |             awk '/^  --[A-Za-z]/ { print $1; \
            if ($2 ~ /--[A-Za-z]/) print $2 }' | sed -e 's/[[,].*//g' )"             -- "$cur" ));
    else
        COMPREPLY=($( compgen -W "$( $1 --help 2>&1 |             awk '/^  --[A-Za-z]/ { print $1; \
            if ($2 ~ /--[A-Za-z]/) print $2 }' | sed -e 's/[[,=].*//g' )"             -- "$cur" ));
    fi
}
_configured_interfaces ()
{
    if [ -f /etc/debian_version ]; then
        COMPREPLY=($( compgen -W "$( sed -ne 's|^iface \([^ ]\{1,\}\).*$|\1|p'            /etc/network/interfaces )" -- "$cur" ));
    else
        if [ -f /etc/SuSE-release ]; then
            COMPREPLY=($( compgen -W "$( printf '%s\n'             /etc/sysconfig/network/ifcfg-* |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
        else
            if [ -f /etc/pld-release ]; then
                COMPREPLY=($( compgen -W "$( command ls -B             /etc/sysconfig/interfaces |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
            else
                COMPREPLY=($( compgen -W "$( printf '%s\n'             /etc/sysconfig/network-scripts/ifcfg-* |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
            fi;
        fi;
    fi
}
_count_args ()
{
    local i cword words;
    __reassemble_comp_words_by_ref "$1" words cword;
    args=1;
    for i in "${words[@]:1:cword-1}";
    do
        [[ "$i" != -* ]] && args=$(($args+1));
    done
}
_cpack ()
{
    local cur prev words cword;
    if type -t _init_completion > /dev/null; then
        _init_completion -n = || return;
    else
        COMPREPLY=();
        cur="${COMP_WORDS[COMP_CWORD]}";
        prev="${COMP_WORDS[COMP_CWORD-1]}";
    fi;
    case "$prev" in
        -G)
            COMPREPLY=($( compgen -W '$( cpack --help 2>/dev/null |
                sed -e "1,/^Generators/d" -e "s|^ *\([^ ]*\) .*$|\1|" \
                2>/dev/null )' -- "$cur" ));
            return
        ;;
        -C)
            COMPREPLY=($( compgen -W 'Debug Release RelWithDebInfo
                MinSizeRel' -- "$cur" ));
            return
        ;;
        -D)
            [[ $cur == *=* ]] && return;
            COMPREPLY=($( compgen -W '$( cpack --help-variable-list \
                2>/dev/null | grep -v "^cpack version " )' -S = -- "$cur" ));
            compopt -o nospace;
            return
        ;;
        -P | -R | --vendor)
            return
        ;;
        -B)
            _filedir -d;
            return
        ;;
        --config)
            _filedir;
            return
        ;;
        --help-command)
            COMPREPLY=($( compgen -W '$( cpack --help-command-list 2>/dev/null|
                grep -v "^cpack version " )' -- "$cur" ));
            return
        ;;
        --help-manual)
            COMPREPLY=($( compgen -W '$( cpack --help-manual-list 2>/dev/null|
                grep -v "^cpack version " | sed -e "s/([0-9])$//" )' -- "$cur" ));
            return
        ;;
        --help-module)
            COMPREPLY=($( compgen -W '$( cpack --help-module-list 2>/dev/null|
                grep -v "^cpack version " )' -- "$cur" ));
            return
        ;;
        --help-policy)
            COMPREPLY=($( compgen -W '$( cpack --help-policy-list 2>/dev/null |
                grep -v "^cpack version " )' -- "$cur" ));
            return
        ;;
        --help-property)
            COMPREPLY=($( compgen -W '$( cpack --help-property-list \
                2>/dev/null | grep -v "^cpack version " )' -- "$cur" ));
            return
        ;;
        --help-variable)
            COMPREPLY=($( compgen -W '$( cpack --help-variable-list \
                2>/dev/null | grep -v "^cpack version " )' -- "$cur" ));
            return
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W '$( _parse_help "$1" --help )' -- ${cur}));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
        [[ -n $COMPREPLY ]] && return;
    fi;
    _filedir
}
_cpio ()
{
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref -n : cur prev;
    _split_longopt && split=true;
    case $prev in
        -H | --format)
            _cpio_format;
            return 0
        ;;
        -E | -F | -I | --file | --pattern-file)
            _filedir;
            return 0
        ;;
        -R | --owner)
            _usergroup;
            return 0
        ;;
        --rsh-command)
            _compopt_o_filenames;
            COMPREPLY=($( compgen -c -- "$cur" ));
            return 0
        ;;
    esac;
    $split && return 0;
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($( compgen -W '-o --create -i --extract -p --pass-through \
                                   -? --help --license --usage --version' -- "$cur" ));
    else
        case ${COMP_WORDS[1]} in
            -o | --create)
                if [[ "$cur" == -* ]]; then
                    COMPREPLY=($( compgen -W '-0 -a -c -v -A -B\
                        -L -V -C -H -M -O -F --file --format\
                        --message --null --reset-access-time\
                        --verbose --dot --append --block-size\
                        --dereference --io-size --quiet\
                        --force-local --rsh-command --help\
                        --version' -- "$cur" ));
                fi
            ;;
            -i | --extract)
                if [[ "$cur" == -* ]]; then
                    COMPREPLY=($( compgen -W '-b -c -d -f -m -n -r\
                        -t -s -u -v -B -S -V -C -E -H -M -R -I\
                        -F --file --make-directories\
                        --nonmatching\
                        --preserve-modification-time\
                        --numeric-uid-gid --rename -t --list\
                        --swap-bytes --swap --dot\
                        --unconditional --verbose --block-size\
                        --swap-halfwords --io-size\
                        --pattern-file --format --owner\
                        --no-preserve-owner --message\
                        --force-local --no-absolute-filenames\
                        --sparse --only-verify-crc --quiet\
                        --rsh-command --help\
                        --to-stdout \
                        --version' -- "$cur" ));
                fi
            ;;
            -p | --pass-through)
                if [[ "$cur" == -* ]]; then
                    COMPREPLY=($( compgen -W '-0 -a -d -l -m -u -v\
                        -L -V -R --null --reset-access-time\
                        --make-directories --link --quiet\
                        --preserve-modification-time\
                        --unconditional --verbose --dot\
                        --dereference --owner\
                        --no-preserve-owner --sparse --help\
                        --version' -- "$cur" ));
                else
                    _filedir -d;
                fi
            ;;
        esac;
    fi
}
_cpio_format ()
{
    COMPREPLY=($( compgen -W 'bin odc newc crc tar ustar hpbin hpodc' -- "$cur" ))
}
_crontab ()
{
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in
        -u)
            _allowed_users;
            return 0
        ;;
    esac;
    local i opts=" -u -l -r -e";
    [ "$(uname -s)" = Linux ] && opts="$opts -i";
    [ -e /etc/selinux ] && opts="$opts -s";
    for ((i=0; i < ${#COMP_WORDS[@]}-1; i++ ))
    do
        case "${COMP_WORDS[i]}" in
            -l)
                opts=${opts// -l -r -e/};
                opts=${opts// -i/};
                opts=${opts// -s/}
            ;;
            -e)
                opts=${opts// -l -r -e/};
                opts=${opts// -i/}
            ;;
            -r)
                opts=${opts// -l -r -e/}
            ;;
            -u)
                opts=${opts// -u/};
                opts=${opts// -i/}
            ;;
            -i | -s)
                opts=${opts// ${COMP_WORDS[i]}/}
            ;;
        esac;
    done;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '$opts' -- "$cur" ));
        return 0;
    fi;
    [[ "${COMP_LINE}" == *\ -@(l|r|e)* ]] || _filedir
}
_cryptsetup_device ()
{
    cur=${cur:=/dev/};
    _filedir
}
_cryptsetup_name ()
{
    COMPREPLY=($( compgen -X control -W '$( command ls /dev/mapper )'         -- "$cur" ))
}
_ctest ()
{
    local cur prev words cword;
    if type -t _init_completion > /dev/null; then
        _init_completion -n = || return;
    else
        COMPREPLY=();
        cur="${COMP_WORDS[COMP_CWORD]}";
        prev="${COMP_WORDS[COMP_CWORD-1]}";
    fi;
    case "$prev" in
        -C | --build-config)
            COMPREPLY=($( compgen -W 'Debug Release RelWithDebInfo
                MinSizeRel' -- "$cur" ));
            return
        ;;
        -j | --parallel)
            COMPREPLY=($( compgen -W "{1..$(( $(_ncpus)*2 ))}" -- "$cur" ));
            return
        ;;
        -O | --output-log | -A | --add-notes | --extra-submit)
            _filedir;
            return
        ;;
        -L | --label-regex | -LE | --label-exclude)
            COMPREPLY=($( compgen -W '$( ctest --print-labels 2>/dev/null |
                grep "^  " 2>/dev/null | cut -d" " -f 3 )' -- "$cur" ));
            return
        ;;
        --track | -I | --tests-information | --max-width | --timeout | --stop-time)
            return
        ;;
        -R | --tests-regex | -E | --exclude-regex)
            COMPREPLY=($( compgen -W '$( ctest -N 2>/dev/null |
                grep "^  Test" 2>/dev/null | cut -d: -f 2 )' -- "$cur" ));
            return
        ;;
        -D | --dashboard)
            if [[ $cur == @(Experimental|Nightly|Continuous)* ]]; then
                local model action;
                action=${cur#@(Experimental|Nightly|Continuous)};
                model=${cur%"$action"};
                COMPREPLY=($( compgen -W 'Start Update Configure Build Test
                    Coverage Submit MemCheck' -P "$model" -- "$action" ));
            else
                COMPREPLY=($( compgen -W 'Experimental Nightly Continuous'                 -- "$cur" ));
                compopt -o nospace;
            fi;
            return
        ;;
        -M | --test-model)
            COMPREPLY=($( compgen -W 'Experimental Nightly Continuous' --                 "$cur" ));
            return
        ;;
        -T | --test-action)
            COMPREPLY=($( compgen -W 'Start Update Configure Build Test
                Coverage Submit MemCheck' -- "$cur" ));
            return
        ;;
        -S | --script | -SP | --script-new-process)
            _filedir '@(cmake|ctest)';
            return
        ;;
        --interactive-debug-mode)
            COMPREPLY=($( compgen -W '0 1' -- "$cur" ));
            return
        ;;
        --help-command)
            COMPREPLY=($( compgen -W '$( ctest --help-command-list 2>/dev/null|
                grep -v "^ctest version " )' -- "$cur" ));
            return
        ;;
        --help-manual)
            COMPREPLY=($( compgen -W '$( ctest --help-manual-list 2>/dev/null|
                grep -v "^ctest version " | sed -e "s/([0-9])$//" )' -- "$cur" ));
            return
        ;;
        --help-module)
            COMPREPLY=($( compgen -W '$( ctest --help-module-list 2>/dev/null|
                grep -v "^ctest version " )' -- "$cur" ));
            return
        ;;
        --help-policy)
            COMPREPLY=($( compgen -W '$( ctest --help-policy-list 2>/dev/null |
                grep -v "^ctest version " )' -- "$cur" ));
            return
        ;;
        --help-property)
            COMPREPLY=($( compgen -W '$( ctest --help-property-list \
                2>/dev/null | grep -v "^ctest version " )' -- "$cur" ));
            return
        ;;
        --help-variable)
            COMPREPLY=($( compgen -W '$( ctest --help-variable-list \
                2>/dev/null | grep -v "^ctest version " )' -- "$cur" ));
            return
        ;;
        --preset)
            local IFS='
';
            local quoted;
            printf -v quoted %q "$cur";
            COMPREPLY=($( compgen -W '$( ctest --list-presets 2>/dev/null |
                grep -o "^  \".*\"" | sed \
                -e "s/^  //g" \
                -e "s/\"//g" \
                -e "s/ /\\\\ /g" )' -- "$quoted" ));
            return
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W '$( _parse_help "$1" --help )' -- ${cur}));
        [[ $COMPREPLY == *= ]] && compopt -o nospace;
        [[ -n $COMPREPLY ]] && return;
    fi;
    _filedir
}
_dd ()
{
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref -n = cur;
    case $cur in
        if=* | of=*)
            cur=${cur#*=};
            _filedir;
            return 0
        ;;
        conv=*)
            cur=${cur#*=};
            COMPREPLY=($( compgen -W 'ascii ebcdic ibm block unblock lcase
                notrunc ucase swab noerror sync' -- "$cur" ));
            return 0
        ;;
    esac;
    _expand || return 0;
    COMPREPLY=($( compgen -W '--help --version' -- "$cur" ) $( compgen -W 'bs cbs conv count ibs if obs of seek skip'                            -S '=' -- "$cur" ))
}
_docker ()
{
    local previous_extglob_setting=$(shopt -p extglob);
    shopt -s extglob;
    local management_commands=(builder config container context image manifest network node plugin secret service stack swarm system trust volume);
    local top_level_commands=(build login logout run search version);
    local legacy_commands=(attach commit cp create diff events exec export history images import info inspect kill load logs pause port ps pull push rename restart rm rmi save start stats stop tag top unpause update wait);
    local known_plugin_commands=();
    local plugin_name="";
    for plugin_path in ${DOCKER_PLUGINS_PATH//:/ };
    do
        plugin_name=$(basename "$plugin_path" | sed 's/ *$//');
        plugin_name=${plugin_name#docker-};
        plugin_name=${plugin_name%%.*};
        eval "_docker_${plugin_name}() { __docker_complete_plugin \"${plugin_path}\"; }";
        known_plugin_commands+=(${plugin_name});
    done;
    local experimental_server_commands=(checkpoint);
    local commands=(${management_commands[*]} ${top_level_commands[*]} ${known_plugin_commands[*]});
    [ -z "$DOCKER_HIDE_LEGACY_COMMANDS" ] && commands+=(${legacy_commands[*]});
    local global_boolean_options="
		--debug -D
		--tls
		--tlsverify
	";
    local global_options_with_args="
		--config
		--context -c
		--host -H
		--log-level -l
		--tlscacert
		--tlscert
		--tlskey
	";
    local info_fetched server_experimental server_os;
    local host config context;
    COMPREPLY=();
    local cur prev words cword;
    _get_comp_words_by_ref -n : cur prev words cword;
    local command='docker' command_pos=0 subcommand_pos;
    local counter=1;
    while [ "$counter" -lt "$cword" ]; do
        case "${words[$counter]}" in
            docker)
                return 0
            ;;
            --host | -H)
                (( counter++ ));
                host="${words[$counter]}"
            ;;
            --config)
                (( counter++ ));
                config="${words[$counter]}"
            ;;
            --context | -c)
                (( counter++ ));
                context="${words[$counter]}"
            ;;
            $(__docker_to_extglob "$global_options_with_args"))
                (( counter++ ))
            ;;
            -*)

            ;;
            =)
                (( counter++ ))
            ;;
            *)
                command="${words[$counter]}";
                command_pos=$counter;
                break
            ;;
        esac;
        (( counter++ ));
    done;
    local binary="${words[0]}";
    if [[ $binary == ?(*/)dockerd ]]; then
        command=daemon;
        command_pos=0;
    fi;
    local completions_func=_docker_${command//-/_};
    declare -F $completions_func > /dev/null && $completions_func;
    eval "$previous_extglob_setting";
    return 0
}
_docker_attach ()
{
    _docker_container_attach
}
_docker_build ()
{
    _docker_image_build
}
_docker_builder ()
{
    local subcommands="
		build
		prune
	";
    __docker_subcommands "$subcommands" && return;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_builder_build ()
{
    _docker_image_build
}
_docker_builder_prune ()
{
    case "$prev" in
        --filter)
            COMPREPLY=($( compgen -S = -W "description id inuse parent private shared type until unused-for" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --keep-storage)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--all -a --filter --force -f --help --keep-storage" -- "$cur" ))
        ;;
    esac
}
_docker_checkpoint ()
{
    local subcommands="
		create
		ls
		rm
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_checkpoint_create ()
{
    case "$prev" in
        --checkpoint-dir)
            _filedir -d;
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--checkpoint-dir --help --leave-running" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--checkpoint-dir');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_running;
            fi
        ;;
    esac
}
_docker_checkpoint_ls ()
{
    case "$prev" in
        --checkpoint-dir)
            _filedir -d;
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--checkpoint-dir --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--checkpoint-dir');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_checkpoint_rm ()
{
    case "$prev" in
        --checkpoint-dir)
            _filedir -d;
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--checkpoint-dir --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--checkpoint-dir');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_all;
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    COMPREPLY=($( compgen -W "$(__docker_q checkpoint ls "$prev" | sed 1d)" -- "$cur" ));
                fi;
            fi
        ;;
    esac
}
_docker_commit ()
{
    _docker_container_commit
}
_docker_config ()
{
    local subcommands="
		create
		inspect
		ls
		rm
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_config_create ()
{
    case "$prev" in
        --label | -l)
            return
        ;;
        --template-driver)
            COMPREPLY=($( compgen -W "golang" -- "$cur" ));
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help --label -l --template-driver" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--label|-l|--template-driver');
            if [ "$cword" -eq "$((counter + 1))" ]; then
                _filedir;
            fi
        ;;
    esac
}
_docker_config_inspect ()
{
    case "$prev" in
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--format -f --help --pretty" -- "$cur" ))
        ;;
        *)
            __docker_complete_configs
        ;;
    esac
}
_docker_config_list ()
{
    _docker_config_ls
}
_docker_config_ls ()
{
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in
        id)
            __docker_complete_configs --cur "${cur##*=}" --id;
            return
        ;;
        name)
            __docker_complete_configs --cur "${cur##*=}" --name;
            return
        ;;
    esac;
    case "$prev" in
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "id label name" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--format --filter -f --help --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_config_remove ()
{
    _docker_config_rm
}
_docker_config_rm ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_configs
        ;;
    esac
}
_docker_container ()
{
    local subcommands="
		attach
		commit
		cp
		create
		diff
		exec
		export
		inspect
		kill
		logs
		ls
		pause
		port
		prune
		rename
		restart
		rm
		run
		start
		stats
		stop
		top
		unpause
		update
		wait
	";
    local aliases="
		list
		ps
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_container_attach ()
{
    __docker_complete_detach_keys && return;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--detach-keys --help --no-stdin --sig-proxy=false" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--detach-keys');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_running;
            fi
        ;;
    esac
}
_docker_container_commit ()
{
    case "$prev" in
        --author | -a | --change | -c | --message | -m)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--author -a --change -c --help --message -m --pause=false -p=false" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--author|-a|--change|-c|--message|-m');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_all;
                return;
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    __docker_complete_images --repo --tag;
                    return;
                fi;
            fi
        ;;
    esac
}
_docker_container_cp ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--archive -a --follow-link -L --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                case "$cur" in
                    *:)
                        return
                    ;;
                    *)
                        _filedir;
                        local files=(${COMPREPLY[@]});
                        __docker_complete_containers_all;
                        COMPREPLY=($( compgen -W "${COMPREPLY[*]}" -S ':' ));
                        local containers=(${COMPREPLY[@]});
                        COMPREPLY=($( compgen -W "${files[*]} ${containers[*]}" -- "$cur" ));
                        if [[ "${COMPREPLY[*]}" = *: ]]; then
                            __docker_nospace;
                        fi;
                        return
                    ;;
                esac;
            fi;
            (( counter++ ));
            if [ "$cword" -eq "$counter" ]; then
                if [ -e "$prev" ]; then
                    __docker_complete_containers_all;
                    COMPREPLY=($( compgen -W "${COMPREPLY[*]}" -S ':' ));
                    __docker_nospace;
                else
                    _filedir;
                fi;
                return;
            fi
        ;;
    esac
}
_docker_container_create ()
{
    _docker_container_run_and_create
}
_docker_container_diff ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_container_exec ()
{
    __docker_complete_detach_keys && return;
    case "$prev" in
        --env | -e)
            COMPREPLY=($( compgen -e -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --env-file)
            _filedir;
            return
        ;;
        --user | -u)
            __docker_complete_user_group;
            return
        ;;
        --workdir | -w)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--detach -d --detach-keys --env -e --env-file --help --interactive -i --privileged -t --tty -u --user --workdir -w" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_running
        ;;
    esac
}
_docker_container_export ()
{
    case "$prev" in
        --output | -o)
            _filedir;
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help --output -o" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_container_inspect ()
{
    _docker_inspect --type container
}
_docker_container_kill ()
{
    case "$prev" in
        --signal | -s)
            __docker_complete_signals;
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help --signal -s" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_running
        ;;
    esac
}
_docker_container_list ()
{
    _docker_container_ls
}
_docker_container_logs ()
{
    case "$prev" in
        --since | --tail | -n | --until)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--details --follow -f --help --since --tail -n --timestamps -t --until" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--since|--tail|-n|--until');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_container_ls ()
{
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in
        ancestor)
            __docker_complete_images --cur "${cur##*=}" --repo --tag --id;
            return
        ;;
        before)
            __docker_complete_containers_all --cur "${cur##*=}";
            return
        ;;
        expose | publish)
            return
        ;;
        id)
            __docker_complete_containers_all --cur "${cur##*=}" --id;
            return
        ;;
        health)
            COMPREPLY=($( compgen -W "healthy starting none unhealthy" -- "${cur##*=}" ));
            return
        ;;
        is-task)
            COMPREPLY=($( compgen -W "true false" -- "${cur##*=}" ));
            return
        ;;
        name)
            __docker_complete_containers_all --cur "${cur##*=}" --name;
            return
        ;;
        network)
            __docker_complete_networks --cur "${cur##*=}";
            return
        ;;
        since)
            __docker_complete_containers_all --cur "${cur##*=}";
            return
        ;;
        status)
            COMPREPLY=($( compgen -W "created dead exited paused restarting running removing" -- "${cur##*=}" ));
            return
        ;;
        volume)
            __docker_complete_volumes --cur "${cur##*=}";
            return
        ;;
    esac;
    case "$prev" in
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "ancestor before exited expose health id is-task label name network publish since status volume" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format | --last | -n)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--all -a --filter -f --format --help --last -n --latest -l --no-trunc --quiet -q --size -s" -- "$cur" ))
        ;;
    esac
}
_docker_container_pause ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_running
        ;;
    esac
}
_docker_container_port ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_container_prune ()
{
    case "$prev" in
        --filter)
            COMPREPLY=($( compgen -W "label label! until" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--force -f --filter --help" -- "$cur" ))
        ;;
    esac
}
_docker_container_ps ()
{
    _docker_container_ls
}
_docker_container_rename ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_all;
            fi
        ;;
    esac
}
_docker_container_restart ()
{
    case "$prev" in
        --time | -t)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help --time -t" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_all
        ;;
    esac
}
_docker_container_rm ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--force -f --help --link -l --volumes -v" -- "$cur" ))
        ;;
        *)
            for arg in "${COMP_WORDS[@]}";
            do
                case "$arg" in
                    --force | -f)
                        __docker_complete_containers_all;
                        return
                    ;;
                esac;
            done;
            __docker_complete_containers_removable
        ;;
    esac
}
_docker_container_run ()
{
    _docker_container_run_and_create
}
_docker_container_run_and_create ()
{
    local options_with_args="
		--add-host
		--attach -a
		--blkio-weight
		--blkio-weight-device
		--cap-add
		--cap-drop
		--cgroupns
		--cgroup-parent
		--cidfile
		--cpu-period
		--cpu-quota
		--cpu-rt-period
		--cpu-rt-runtime
		--cpuset-cpus
		--cpus
		--cpuset-mems
		--cpu-shares -c
		--device
		--device-cgroup-rule
		--device-read-bps
		--device-read-iops
		--device-write-bps
		--device-write-iops
		--dns
		--dns-option
		--dns-search
		--domainname
		--entrypoint
		--env -e
		--env-file
		--expose
		--gpus
		--group-add
		--health-cmd
		--health-interval
		--health-retries
		--health-start-period
		--health-timeout
		--hostname -h
		--ip
		--ip6
		--ipc
		--kernel-memory
		--label-file
		--label -l
		--link
		--link-local-ip
		--log-driver
		--log-opt
		--mac-address
		--memory -m
		--memory-swap
		--memory-swappiness
		--memory-reservation
		--mount
		--name
		--network
		--network-alias
		--oom-score-adj
		--pid
		--pids-limit
		--platform
		--publish -p
		--pull
		--restart
		--runtime
		--security-opt
		--shm-size
		--stop-signal
		--stop-timeout
		--storage-opt
		--tmpfs
		--sysctl
		--ulimit
		--user -u
		--userns
		--uts
		--volume-driver
		--volumes-from
		--volume -v
		--workdir -w
	";
    __docker_server_os_is windows && options_with_args+="
		--cpu-count
		--cpu-percent
		--io-maxbandwidth
		--io-maxiops
		--isolation
	";
    local boolean_options="
		--disable-content-trust=false
		--help
		--init
		--interactive -i
		--no-healthcheck
		--oom-kill-disable
		--privileged
		--publish-all -P
		--quiet -q
		--read-only
		--tty -t
	";
    if [ "$command" = "run" ] || [ "$subcommand" = "run" ]; then
        options_with_args="$options_with_args
			--detach-keys
		";
        boolean_options="$boolean_options
			--detach -d
			--rm
			--sig-proxy=false
		";
        __docker_complete_detach_keys && return;
    fi;
    local all_options="$options_with_args $boolean_options";
    __docker_complete_log_driver_options && return;
    __docker_complete_restart && return;
    local key=$(__docker_map_key_of_current_option '--security-opt');
    case "$key" in
        label)
            [[ $cur == *: ]] && return;
            COMPREPLY=($( compgen -W "user: role: type: level: disable" -- "${cur##*=}"));
            if [ "${COMPREPLY[*]}" != "disable" ]; then
                __docker_nospace;
            fi;
            return
        ;;
        seccomp)
            local cur=${cur##*=};
            _filedir;
            COMPREPLY+=($( compgen -W "unconfined" -- "$cur" ));
            return
        ;;
    esac;
    case "$prev" in
        --add-host)
            case "$cur" in
                *:)
                    __docker_complete_resolved_hostname;
                    return
                ;;
            esac
        ;;
        --attach | -a)
            COMPREPLY=($( compgen -W 'stdin stdout stderr' -- "$cur" ));
            return
        ;;
        --cap-add)
            __docker_complete_capabilities_addable;
            return
        ;;
        --cap-drop)
            __docker_complete_capabilities_droppable;
            return
        ;;
        --cidfile | --env-file | --label-file)
            _filedir;
            return
        ;;
        --cgroupns)
            COMPREPLY=($( compgen -W "host private" -- "$cur" ));
            return
        ;;
        --device | --tmpfs | --volume | -v)
            case "$cur" in
                *:*)

                ;;
                '')
                    COMPREPLY=($( compgen -W '/' -- "$cur" ));
                    __docker_nospace
                ;;
                /*)
                    _filedir;
                    __docker_nospace
                ;;
            esac;
            return
        ;;
        --env | -e)
            COMPREPLY=($( compgen -e -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --ipc)
            case "$cur" in
                *:*)
                    cur="${cur#*:}";
                    __docker_complete_containers_running
                ;;
                *)
                    COMPREPLY=($( compgen -W 'none host private shareable container:' -- "$cur" ));
                    if [ "${COMPREPLY[*]}" = "container:" ]; then
                        __docker_nospace;
                    fi
                ;;
            esac;
            return
        ;;
        --isolation)
            if __docker_server_os_is windows; then
                __docker_complete_isolation;
                return;
            fi
        ;;
        --link)
            case "$cur" in
                *:*)

                ;;
                *)
                    __docker_complete_containers_running;
                    COMPREPLY=($( compgen -W "${COMPREPLY[*]}" -S ':' ));
                    __docker_nospace
                ;;
            esac;
            return
        ;;
        --log-driver)
            __docker_complete_log_drivers;
            return
        ;;
        --log-opt)
            __docker_complete_log_options;
            return
        ;;
        --network)
            case "$cur" in
                container:*)
                    __docker_complete_containers_all --cur "${cur#*:}"
                ;;
                *)
                    COMPREPLY=($( compgen -W "$(__docker_plugins_bundled --type Network) $(__docker_networks) container:" -- "$cur"));
                    if [ "${COMPREPLY[*]}" = "container:" ]; then
                        __docker_nospace;
                    fi
                ;;
            esac;
            return
        ;;
        --pid)
            case "$cur" in
                *:*)
                    __docker_complete_containers_running --cur "${cur#*:}"
                ;;
                *)
                    COMPREPLY=($( compgen -W 'host container:' -- "$cur" ));
                    if [ "${COMPREPLY[*]}" = "container:" ]; then
                        __docker_nospace;
                    fi
                ;;
            esac;
            return
        ;;
        --pull)
            COMPREPLY=($( compgen -W 'always missing never' -- "$cur" ));
            return
        ;;
        --runtime)
            __docker_complete_runtimes;
            return
        ;;
        --security-opt)
            COMPREPLY=($( compgen -W "apparmor= label= no-new-privileges seccomp= systempaths=unconfined" -- "$cur"));
            if [[ ${COMPREPLY[*]} = *= ]]; then
                __docker_nospace;
            fi;
            return
        ;;
        --stop-signal)
            __docker_complete_signals;
            return
        ;;
        --storage-opt)
            COMPREPLY=($( compgen -W "size" -S = -- "$cur"));
            __docker_nospace;
            return
        ;;
        --ulimit)
            __docker_complete_ulimits;
            return
        ;;
        --user | -u)
            __docker_complete_user_group;
            return
        ;;
        --userns)
            COMPREPLY=($( compgen -W "host" -- "$cur" ));
            return
        ;;
        --volume-driver)
            __docker_complete_plugins_bundled --type Volume;
            return
        ;;
        --volumes-from)
            __docker_complete_containers_all;
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "$all_options" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag "$( __docker_to_alternatives "$options_with_args" )" );
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_images --repo --tag --id;
            fi
        ;;
    esac
}
_docker_container_start ()
{
    __docker_complete_detach_keys && return;
    case "$prev" in
        --checkpoint)
            if __docker_server_is_experimental; then
                return;
            fi
        ;;
        --checkpoint-dir)
            if __docker_server_is_experimental; then
                _filedir -d;
                return;
            fi
        ;;
    esac;
    case "$cur" in
        -*)
            local options="--attach -a --detach-keys --help --interactive -i";
            __docker_server_is_experimental && options+=" --checkpoint --checkpoint-dir";
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_stopped
        ;;
    esac
}
_docker_container_stats ()
{
    case "$prev" in
        --format)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--all -a --format --help --no-stream --no-trunc" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_running
        ;;
    esac
}
_docker_container_stop ()
{
    case "$prev" in
        --time | -t)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help --time -t" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_stoppable
        ;;
    esac
}
_docker_container_top ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_running;
            fi
        ;;
    esac
}
_docker_container_unpause ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_containers_unpauseable;
            fi
        ;;
    esac
}
_docker_container_update ()
{
    local options_with_args="
		--blkio-weight
		--cpu-period
		--cpu-quota
		--cpu-rt-period
		--cpu-rt-runtime
		--cpus
		--cpuset-cpus
		--cpuset-mems
		--cpu-shares -c
		--kernel-memory
		--memory -m
		--memory-reservation
		--memory-swap
		--pids-limit
		--restart
	";
    local boolean_options="
		--help
	";
    local all_options="$options_with_args $boolean_options";
    __docker_complete_restart && return;
    case "$prev" in
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "$all_options" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_all
        ;;
    esac
}
_docker_container_wait ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_containers_all
        ;;
    esac
}
_docker_context ()
{
    local subcommands="
		create
		export
		import
		inspect
		ls
		rm
		update
		use
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_context_create ()
{
    case "$prev" in
        --description | --docker)
            return
        ;;
        --from)
            __docker_complete_contexts;
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--description --docker --from --help" -- "$cur" ))
        ;;
    esac
}
_docker_context_export ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_contexts;
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    _filedir;
                fi;
            fi
        ;;
    esac
}
_docker_context_import ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                :;
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    _filedir;
                fi;
            fi
        ;;
    esac
}
_docker_context_inspect ()
{
    case "$prev" in
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--format -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_contexts
        ;;
    esac
}
_docker_context_list ()
{
    _docker_context_ls
}
_docker_context_ls ()
{
    case "$prev" in
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--format -f --help --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_context_remove ()
{
    _docker_context_rm
}
_docker_context_rm ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_contexts
        ;;
    esac
}
_docker_context_update ()
{
    case "$prev" in
        --description | --docker)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--description --docker --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_contexts;
            fi
        ;;
    esac
}
_docker_context_use ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_contexts --add default;
            fi
        ;;
    esac
}
_docker_cp ()
{
    _docker_container_cp
}
_docker_create ()
{
    _docker_container_create
}
_docker_daemon ()
{
    local boolean_options="
		$global_boolean_options
		--experimental
		--help
		--icc=false
		--init
		--ip-forward=false
		--ip-masq=false
		--iptables=false
		--ip6tables
		--ipv6
		--live-restore
		--no-new-privileges
		--raw-logs
		--selinux-enabled
		--userland-proxy=false
		--validate
		--version -v
	";
    local options_with_args="
		$global_options_with_args
		--add-runtime
		--allow-nondistributable-artifacts
		--api-cors-header
		--authorization-plugin
		--bip
		--bridge -b
		--cgroup-parent
		--config-file
		--containerd
		--containerd-namespace
		--containerd-plugins-namespace
		--cpu-rt-period
		--cpu-rt-runtime
		--data-root
		--default-address-pool
		--default-gateway
		--default-gateway-v6
		--default-runtime
		--default-shm-size
		--default-ulimit
		--dns
		--dns-search
		--dns-opt
		--exec-opt
		--exec-root
		--fixed-cidr
		--fixed-cidr-v6
		--group -G
		--init-path
		--insecure-registry
		--ip
		--label
		--log-driver
		--log-opt
		--max-concurrent-downloads
		--max-concurrent-uploads
		--max-download-attempts
		--metrics-addr
		--mtu
		--network-control-plane-mtu
		--node-generic-resource
		--oom-score-adjust
		--pidfile -p
		--registry-mirror
		--seccomp-profile
		--shutdown-timeout
		--storage-driver -s
		--storage-opt
		--swarm-default-advertise-addr
		--userland-proxy-path
		--userns-remap
	";
    __docker_complete_log_driver_options && return;
    local key=$(__docker_map_key_of_current_option '--storage-opt');
    case "$key" in
        dm.blkdiscard | dm.override_udev_sync_check | dm.use_deferred_removal | dm.use_deferred_deletion)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        dm.directlvm_device | dm.thinpooldev)
            cur=${cur##*=};
            _filedir;
            return
        ;;
        dm.fs)
            COMPREPLY=($( compgen -W "ext4 xfs" -- "${cur##*=}" ));
            return
        ;;
        dm.libdm_log_level)
            COMPREPLY=($( compgen -W "2 3 4 5 6 7" -- "${cur##*=}" ));
            return
        ;;
    esac;
    case "$prev" in
        --authorization-plugin)
            __docker_complete_plugins_bundled --type Authorization;
            return
        ;;
        --config-file | --containerd | --init-path | --pidfile | -p | --tlscacert | --tlscert | --tlskey | --userland-proxy-path)
            _filedir;
            return
        ;;
        --default-ulimit)
            __docker_complete_ulimits;
            return
        ;;
        --exec-root | --data-root)
            _filedir -d;
            return
        ;;
        --log-driver)
            __docker_complete_log_drivers;
            return
        ;;
        --storage-driver | -s)
            COMPREPLY=($( compgen -W "aufs btrfs overlay2 vfs zfs" -- "$(echo "$cur" | tr '[:upper:]' '[:lower:]')" ));
            return
        ;;
        --storage-opt)
            local btrfs_options="btrfs.min_space";
            local overlay2_options="overlay2.size";
            local zfs_options="zfs.fsname";
            local all_options="$btrfs_options $overlay2_options $zfs_options";
            case $(__docker_value_of_option '--storage-driver|-s') in
                '')
                    COMPREPLY=($( compgen -W "$all_options" -S = -- "$cur" ))
                ;;
                btrfs)
                    COMPREPLY=($( compgen -W "$btrfs_options" -S = -- "$cur" ))
                ;;
                overlay2)
                    COMPREPLY=($( compgen -W "$overlay2_options" -S = -- "$cur" ))
                ;;
                zfs)
                    COMPREPLY=($( compgen -W "$zfs_options" -S = -- "$cur" ))
                ;;
                *)
                    return
                ;;
            esac;
            __docker_nospace;
            return
        ;;
        --log-level | -l)
            __docker_complete_log_levels;
            return
        ;;
        --log-opt)
            __docker_complete_log_options;
            return
        ;;
        --metrics-addr)
            __docker_complete_local_ips;
            __docker_append_to_completions ":";
            __docker_nospace;
            return
        ;;
        --seccomp-profile)
            _filedir json;
            return
        ;;
        --swarm-default-advertise-addr)
            __docker_complete_local_interfaces;
            return
        ;;
        --userns-remap)
            __docker_complete_user_group;
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "$boolean_options $options_with_args" -- "$cur" ))
        ;;
    esac
}
_docker_diff ()
{
    _docker_container_diff
}
_docker_docker ()
{
    local boolean_options="
		$global_boolean_options
		--help
		--version -v
	";
    case "$prev" in
        --config)
            _filedir -d;
            return
        ;;
        --context | -c)
            __docker_complete_contexts;
            return
        ;;
        --log-level | -l)
            __docker_complete_log_levels;
            return
        ;;
        $(__docker_to_extglob "$global_options_with_args"))
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "$boolean_options $global_options_with_args" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag "$(__docker_to_extglob "$global_options_with_args")" );
            if [ "$cword" -eq "$counter" ]; then
                __docker_server_is_experimental && commands+=(${experimental_server_commands[*]});
                COMPREPLY=($( compgen -W "${commands[*]} help" -- "$cur" ));
            fi
        ;;
    esac
}
_docker_events ()
{
    _docker_system_events
}
_docker_exec ()
{
    _docker_container_exec
}
_docker_export ()
{
    _docker_container_export
}
_docker_help ()
{
    local counter=$(__docker_pos_first_nonflag);
    if [ "$cword" -eq "$counter" ]; then
        COMPREPLY=($( compgen -W "${commands[*]}" -- "$cur" ));
    fi
}
_docker_history ()
{
    _docker_image_history
}
_docker_image ()
{
    local subcommands="
		build
		history
		import
		inspect
		load
		ls
		prune
		pull
		push
		rm
		save
		tag
	";
    local aliases="
		images
		list
		remove
		rmi
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_image_build ()
{
    local options_with_args="
		--add-host
		--build-arg
		--cache-from
		--cgroup-parent
		--cpuset-cpus
		--cpuset-mems
		--cpu-shares -c
		--cpu-period
		--cpu-quota
		--file -f
		--iidfile
		--label
		--memory -m
		--memory-swap
		--network
		--platform
		--shm-size
		--tag -t
		--target
		--ulimit
	";
    __docker_server_os_is windows && options_with_args+="
		--isolation
	";
    local boolean_options="
		--disable-content-trust=false
		--force-rm
		--help
		--no-cache
		--pull
		--quiet -q
		--rm
	";
    if __docker_server_is_experimental; then
        boolean_options+="
			--squash
		";
    fi;
    if [ "$DOCKER_BUILDKIT" = "1" ]; then
        options_with_args+="
			--output -o
			--progress
			--secret
			--ssh
		";
    else
        boolean_options+="
			--compress
		";
    fi;
    local all_options="$options_with_args $boolean_options";
    case "$prev" in
        --add-host)
            case "$cur" in
                *:)
                    __docker_complete_resolved_hostname;
                    return
                ;;
            esac
        ;;
        --build-arg)
            COMPREPLY=($( compgen -e -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --cache-from)
            __docker_complete_images --repo --tag --id;
            return
        ;;
        --file | -f | --iidfile)
            _filedir;
            return
        ;;
        --isolation)
            if __docker_server_os_is windows; then
                __docker_complete_isolation;
                return;
            fi
        ;;
        --network)
            case "$cur" in
                container:*)
                    __docker_complete_containers_all --cur "${cur#*:}"
                ;;
                *)
                    COMPREPLY=($( compgen -W "$(__docker_plugins_bundled --type Network) $(__docker_networks) container:" -- "$cur"));
                    if [ "${COMPREPLY[*]}" = "container:" ]; then
                        __docker_nospace;
                    fi
                ;;
            esac;
            return
        ;;
        --progress)
            COMPREPLY=($( compgen -W "auto plain tty" -- "$cur" ));
            return
        ;;
        --tag | -t)
            __docker_complete_images --repo --tag;
            return
        ;;
        --target)
            local context_pos=$( __docker_pos_first_nonflag "$( __docker_to_alternatives "$options_with_args" )" );
            local context="${words[$context_pos]}";
            context="${context:-.}";
            local file="$( __docker_value_of_option '--file|f' )";
            local default_file="${context%/}/Dockerfile";
            local dockerfile="${file:-$default_file}";
            local targets="$( sed -n 's/^FROM .\+ AS \(.\+\)/\1/p' "$dockerfile" 2>/dev/null )";
            COMPREPLY=($( compgen -W "$targets" -- "$cur" ));
            return
        ;;
        --ulimit)
            __docker_complete_ulimits;
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "$all_options" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag "$( __docker_to_alternatives "$options_with_args" )" );
            if [ "$cword" -eq "$counter" ]; then
                _filedir -d;
            fi
        ;;
    esac
}
_docker_image_history ()
{
    case "$prev" in
        --format)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--format --help --human=false -H=false --no-trunc --quiet -q" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--format');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_images --force-tag --id;
            fi
        ;;
    esac
}
_docker_image_images ()
{
    _docker_image_ls
}
_docker_image_import ()
{
    case "$prev" in
        --change | -c | --message | -m | --platform)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            local options="--change -c --help --message -m --platform";
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--change|-c|--message|-m');
            if [ "$cword" -eq "$counter" ]; then
                _filedir;
                return;
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    __docker_complete_images --repo --tag;
                    return;
                fi;
            fi
        ;;
    esac
}
_docker_image_inspect ()
{
    _docker_inspect --type image
}
_docker_image_list ()
{
    _docker_image_ls
}
_docker_image_load ()
{
    case "$prev" in
        --input | -i | "<")
            _filedir;
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help --input -i --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_image_ls ()
{
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in
        before | since)
            __docker_complete_images --cur "${cur##*=}" --force-tag --id;
            return
        ;;
        dangling)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        label)
            return
        ;;
        reference)
            __docker_complete_images --cur "${cur##*=}" --repo --tag;
            return
        ;;
    esac;
    case "$prev" in
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "before dangling label reference since" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--all -a --digests --filter -f --format --help --no-trunc --quiet -q" -- "$cur" ))
        ;;
        =)
            return
        ;;
        *)
            __docker_complete_images --repo --tag
        ;;
    esac
}
_docker_image_prune ()
{
    case "$prev" in
        --filter)
            COMPREPLY=($( compgen -W "label label! until" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--all -a --force -f --filter --help" -- "$cur" ))
        ;;
    esac
}
_docker_image_pull ()
{
    case "$prev" in
        --platform)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            local options="--all-tags -a --disable-content-trust=false --help --platform --quiet -q";
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag --platform);
            if [ "$cword" -eq "$counter" ]; then
                for arg in "${COMP_WORDS[@]}";
                do
                    case "$arg" in
                        --all-tags | -a)
                            __docker_complete_images --repo;
                            return
                        ;;
                    esac;
                done;
                __docker_complete_images --repo --tag;
            fi
        ;;
    esac
}
_docker_image_push ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--all-tags -a --disable-content-trust=false --help --quiet -q" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_images --repo --tag;
            fi
        ;;
    esac
}
_docker_image_remove ()
{
    _docker_image_rm
}
_docker_image_rm ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--force -f --help --no-prune" -- "$cur" ))
        ;;
        *)
            __docker_complete_images --force-tag --id
        ;;
    esac
}
_docker_image_rmi ()
{
    _docker_image_rm
}
_docker_image_save ()
{
    case "$prev" in
        --output | -o | ">")
            _filedir;
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help --output -o" -- "$cur" ))
        ;;
        *)
            __docker_complete_images --repo --tag --id
        ;;
    esac
}
_docker_image_tag ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_images --force-tag --id;
                return;
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    __docker_complete_images --repo --tag;
                    return;
                fi;
            fi
        ;;
    esac
}
_docker_images ()
{
    _docker_image_ls
}
_docker_import ()
{
    _docker_image_import
}
_docker_info ()
{
    _docker_system_info
}
_docker_inspect ()
{
    local preselected_type;
    local type;
    if [ "$1" = "--type" ]; then
        preselected_type=yes;
        type="$2";
    else
        type=$(__docker_value_of_option --type);
    fi;
    case "$prev" in
        --format | -f)
            return
        ;;
        --type)
            if [ -z "$preselected_type" ]; then
                COMPREPLY=($( compgen -W "container image network node plugin secret service volume" -- "$cur" ));
                return;
            fi
        ;;
    esac;
    case "$cur" in
        -*)
            local options="--format -f --help --size -s";
            if [ -z "$preselected_type" ]; then
                options+=" --type";
            fi;
            COMPREPLY=($( compgen -W "$options" -- "$cur" ))
        ;;
        *)
            case "$type" in
                '')
                    COMPREPLY=($( compgen -W "
						$(__docker_containers --all)
						$(__docker_images --force-tag --id)
						$(__docker_networks)
						$(__docker_nodes)
						$(__docker_plugins_installed)
						$(__docker_secrets)
						$(__docker_services)
						$(__docker_volumes)
					" -- "$cur" ));
                    __ltrim_colon_completions "$cur"
                ;;
                container)
                    __docker_complete_containers_all
                ;;
                image)
                    __docker_complete_images --force-tag --id
                ;;
                network)
                    __docker_complete_networks
                ;;
                node)
                    __docker_complete_nodes
                ;;
                plugin)
                    __docker_complete_plugins_installed
                ;;
                secret)
                    __docker_complete_secrets
                ;;
                service)
                    __docker_complete_services
                ;;
                volume)
                    __docker_complete_volumes
                ;;
            esac
        ;;
    esac
}
_docker_kill ()
{
    _docker_container_kill
}
_docker_load ()
{
    _docker_image_load
}
_docker_login ()
{
    case "$prev" in
        --password | -p | --username | -u)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help --password -p --password-stdin --username -u" -- "$cur" ))
        ;;
    esac
}
_docker_logout ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
    esac
}
_docker_logs ()
{
    _docker_container_logs
}
_docker_manifest ()
{
    local subcommands="
		annotate
		create
		inspect
		push
		rm
	";
    __docker_subcommands "$subcommands" && return;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_manifest_annotate ()
{
    case "$prev" in
        --arch)
            COMPREPLY=($( compgen -W "
				386
				amd64
				arm
				arm64
				mips64
				mips64le
				ppc64le
				riscv64
				s390x" -- "$cur" ));
            return
        ;;
        --os)
            COMPREPLY=($( compgen -W "
				darwin
				dragonfly
				freebsd
				linux
				netbsd
				openbsd
				plan9
				solaris
				windows" -- "$cur" ));
            return
        ;;
        --os-features | --variant)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--arch --help --os --os-features --variant" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag "--arch|--os|--os-features|--variant" );
            if [ "$cword" -eq "$counter" ] || [ "$cword" -eq "$((counter + 1))" ]; then
                __docker_complete_images --force-tag --id;
            fi
        ;;
    esac
}
_docker_manifest_create ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--amend -a --help --insecure" -- "$cur" ))
        ;;
        *)
            __docker_complete_images --force-tag --id
        ;;
    esac
}
_docker_manifest_inspect ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help --insecure --verbose -v" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag );
            if [ "$cword" -eq "$counter" ] || [ "$cword" -eq "$((counter + 1))" ]; then
                __docker_complete_images --force-tag --id;
            fi
        ;;
    esac
}
_docker_manifest_push ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help --insecure --purge -p" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag );
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_images --force-tag --id;
            fi
        ;;
    esac
}
_docker_manifest_rm ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_images --force-tag --id
        ;;
    esac
}
_docker_network ()
{
    local subcommands="
		connect
		create
		disconnect
		inspect
		ls
		prune
		rm
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_network_connect ()
{
    local options_with_args="
		--alias
		--ip
		--ip6
		--link
		--link-local-ip
	";
    local boolean_options="
		--help
	";
    case "$prev" in
        --link)
            case "$cur" in
                *:*)

                ;;
                *)
                    __docker_complete_containers_running;
                    COMPREPLY=($( compgen -W "${COMPREPLY[*]}" -S ':' ));
                    __docker_nospace
                ;;
            esac;
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "$boolean_options $options_with_args" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag "$( __docker_to_alternatives "$options_with_args" )" );
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_networks;
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    __docker_complete_containers_all;
                fi;
            fi
        ;;
    esac
}
_docker_network_create ()
{
    case "$prev" in
        --aux-address | --gateway | --ip-range | --ipam-opt | --ipv6 | --opt | -o | --subnet)
            return
        ;;
        --config-from)
            __docker_complete_networks;
            return
        ;;
        --driver | -d)
            __docker_complete_plugins_bundled --type Network --remove host --remove null --add macvlan;
            return
        ;;
        --ipam-driver)
            COMPREPLY=($( compgen -W "default" -- "$cur" ));
            return
        ;;
        --label)
            return
        ;;
        --scope)
            COMPREPLY=($( compgen -W "local swarm" -- "$cur" ));
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--attachable --aux-address --config-from --config-only --driver -d --gateway --help --ingress --internal --ip-range --ipam-driver --ipam-opt --ipv6 --label --opt -o --scope --subnet" -- "$cur" ))
        ;;
    esac
}
_docker_network_disconnect ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_networks;
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    __docker_complete_containers_in_network "$prev";
                fi;
            fi
        ;;
    esac
}
_docker_network_inspect ()
{
    case "$prev" in
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--format -f --help --verbose" -- "$cur" ))
        ;;
        *)
            __docker_complete_networks
        ;;
    esac
}
_docker_network_ls ()
{
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in
        dangling)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        driver)
            __docker_complete_plugins_bundled --cur "${cur##*=}" --type Network --add macvlan;
            return
        ;;
        id)
            __docker_complete_networks --cur "${cur##*=}" --id;
            return
        ;;
        name)
            __docker_complete_networks --cur "${cur##*=}" --name;
            return
        ;;
        scope)
            COMPREPLY=($( compgen -W "global local swarm" -- "${cur##*=}" ));
            return
        ;;
        type)
            COMPREPLY=($( compgen -W "builtin custom" -- "${cur##*=}" ));
            return
        ;;
    esac;
    case "$prev" in
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "dangling driver id label name scope type" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --no-trunc --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_network_prune ()
{
    case "$prev" in
        --filter)
            COMPREPLY=($( compgen -W "label label! until" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--force -f --filter --help" -- "$cur" ))
        ;;
    esac
}
_docker_network_rm ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_networks --filter type=custom
        ;;
    esac
}
_docker_node ()
{
    local subcommands="
		demote
		inspect
		ls
		promote
		rm
		ps
		update
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_node_demote ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_nodes --filter role=manager
        ;;
    esac
}
_docker_node_inspect ()
{
    case "$prev" in
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--format -f --help --pretty" -- "$cur" ))
        ;;
        *)
            __docker_complete_nodes --add self
        ;;
    esac
}
_docker_node_list ()
{
    _docker_node_ls
}
_docker_node_ls ()
{
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in
        id)
            __docker_complete_nodes --cur "${cur##*=}" --id;
            return
        ;;
        label | node.label)
            return
        ;;
        membership)
            COMPREPLY=($( compgen -W "accepted pending" -- "${cur##*=}" ));
            return
        ;;
        name)
            __docker_complete_nodes --cur "${cur##*=}" --name;
            return
        ;;
        role)
            COMPREPLY=($( compgen -W "manager worker" -- "${cur##*=}" ));
            return
        ;;
    esac;
    case "$prev" in
        --filter | -f)
            COMPREPLY=($( compgen -W "id label membership name node.label role" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_node_promote ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_nodes --filter role=worker
        ;;
    esac
}
_docker_node_ps ()
{
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in
        desired-state)
            COMPREPLY=($( compgen -W "accepted running shutdown" -- "${cur##*=}" ));
            return
        ;;
        name)
            __docker_complete_services --cur "${cur##*=}" --name;
            return
        ;;
    esac;
    case "$prev" in
        --filter | -f)
            COMPREPLY=($( compgen -W "desired-state id label name" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --no-resolve --no-trunc --quiet -q" -- "$cur" ))
        ;;
        *)
            __docker_complete_nodes --add self
        ;;
    esac
}
_docker_node_remove ()
{
    _docker_node_rm
}
_docker_node_rm ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_nodes
        ;;
    esac
}
_docker_node_update ()
{
    case "$prev" in
        --availability)
            COMPREPLY=($( compgen -W "active drain pause" -- "$cur" ));
            return
        ;;
        --role)
            COMPREPLY=($( compgen -W "manager worker" -- "$cur" ));
            return
        ;;
        --label-add | --label-rm)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--availability --help --label-add --label-rm --role" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--availability|--label-add|--label-rm|--role');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_nodes;
            fi
        ;;
    esac
}
_docker_pause ()
{
    _docker_container_pause
}
_docker_plugin ()
{
    local subcommands="
		create
		disable
		enable
		inspect
		install
		ls
		push
		rm
		set
		upgrade
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_plugin_create ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--compress --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                return;
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    _filedir -d;
                fi;
            fi
        ;;
    esac
}
_docker_plugin_disable ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_plugins_installed --filter enabled=true;
            fi
        ;;
    esac
}
_docker_plugin_enable ()
{
    case "$prev" in
        --timeout)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help --timeout" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--timeout');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_plugins_installed --filter enabled=false;
            fi
        ;;
    esac
}
_docker_plugin_inspect ()
{
    case "$prev" in
        --format | f)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--format -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_plugins_installed
        ;;
    esac
}
_docker_plugin_install ()
{
    case "$prev" in
        --alias)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--alias --disable --disable-content-trust=false --grant-all-permissions --help" -- "$cur" ))
        ;;
    esac
}
_docker_plugin_list ()
{
    _docker_plugin_ls
}
_docker_plugin_ls ()
{
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in
        capability)
            COMPREPLY=($( compgen -W "authz ipamdriver logdriver metricscollector networkdriver volumedriver" -- "${cur##*=}" ));
            return
        ;;
        enabled)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
    esac;
    case "$prev" in
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "capability enabled" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --no-trunc --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_plugin_push ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_plugins_installed;
            fi
        ;;
    esac
}
_docker_plugin_remove ()
{
    _docker_plugin_rm
}
_docker_plugin_rm ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_plugins_installed
        ;;
    esac
}
_docker_plugin_set ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_plugins_installed;
            fi
        ;;
    esac
}
_docker_plugin_upgrade ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--disable-content-trust --grant-all-permissions --help --skip-remote-check" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_plugins_installed;
                __ltrim_colon_completions "$cur";
            else
                if [ "$cword" -eq "$((counter + 1))" ]; then
                    local plugin_images="$(__docker_plugins_installed)";
                    COMPREPLY=($(compgen -S : -W "${plugin_images%:*}" -- "$cur"));
                    __docker_nospace;
                fi;
            fi
        ;;
    esac
}
_docker_port ()
{
    _docker_container_port
}
_docker_ps ()
{
    _docker_container_ls
}
_docker_pull ()
{
    _docker_image_pull
}
_docker_push ()
{
    _docker_image_push
}
_docker_rename ()
{
    _docker_container_rename
}
_docker_restart ()
{
    _docker_container_restart
}
_docker_rm ()
{
    _docker_container_rm
}
_docker_rmi ()
{
    _docker_image_rm
}
_docker_run ()
{
    _docker_container_run
}
_docker_save ()
{
    _docker_image_save
}
_docker_search ()
{
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in
        is-automated)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
        is-official)
            COMPREPLY=($( compgen -W "false true" -- "${cur##*=}" ));
            return
        ;;
    esac;
    case "$prev" in
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "is-automated is-official stars" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format | --limit)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --limit --no-trunc" -- "$cur" ))
        ;;
    esac
}
_docker_secret ()
{
    local subcommands="
		create
		inspect
		ls
		rm
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_secret_create ()
{
    case "$prev" in
        --driver | -d | --label | -l)
            return
        ;;
        --template-driver)
            COMPREPLY=($( compgen -W "golang" -- "$cur" ));
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--driver -d --help --label -l --template-driver" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--driver|-d|--label|-l|--template-driver');
            if [ "$cword" -eq "$((counter + 1))" ]; then
                _filedir;
            fi
        ;;
    esac
}
_docker_secret_inspect ()
{
    case "$prev" in
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--format -f --help --pretty" -- "$cur" ))
        ;;
        *)
            __docker_complete_secrets
        ;;
    esac
}
_docker_secret_list ()
{
    _docker_secret_ls
}
_docker_secret_ls ()
{
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in
        id)
            __docker_complete_secrets --cur "${cur##*=}" --id;
            return
        ;;
        name)
            __docker_complete_secrets --cur "${cur##*=}" --name;
            return
        ;;
    esac;
    case "$prev" in
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "id label name" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--format --filter -f --help --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_secret_remove ()
{
    _docker_secret_rm
}
_docker_secret_rm ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_secrets
        ;;
    esac
}
_docker_service ()
{
    local subcommands="
		create
		inspect
		logs
		ls
		rm
		rollback
		scale
		ps
		update
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_service_create ()
{
    _docker_service_update_and_create
}
_docker_service_inspect ()
{
    case "$prev" in
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--format -f --help --pretty" -- "$cur" ))
        ;;
        *)
            __docker_complete_services
        ;;
    esac
}
_docker_service_list ()
{
    _docker_service_ls
}
_docker_service_logs ()
{
    case "$prev" in
        --since | --tail | -n)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--details --follow -f --help --no-resolve --no-task-ids --no-trunc --raw --since --tail -n --timestamps -t" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--since|--tail|-n');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_services_and_tasks;
            fi
        ;;
    esac
}
_docker_service_ls ()
{
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in
        id)
            __docker_complete_services --cur "${cur##*=}" --id;
            return
        ;;
        mode)
            COMPREPLY=($( compgen -W "global global-job replicated replicated-job" -- "${cur##*=}" ));
            return
        ;;
        name)
            __docker_complete_services --cur "${cur##*=}" --name;
            return
        ;;
    esac;
    case "$prev" in
        --filter | -f)
            COMPREPLY=($( compgen -W "id label mode name" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_service_ps ()
{
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in
        desired-state)
            COMPREPLY=($( compgen -W "accepted running shutdown" -- "${cur##*=}" ));
            return
        ;;
        name)
            __docker_complete_services --cur "${cur##*=}" --name;
            return
        ;;
        node)
            __docker_complete_nodes --cur "${cur##*=}" --add self;
            return
        ;;
    esac;
    case "$prev" in
        --filter | -f)
            COMPREPLY=($( compgen -W "desired-state id name node" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --no-resolve --no-trunc --quiet -q" -- "$cur" ))
        ;;
        *)
            __docker_complete_services
        ;;
    esac
}
_docker_service_remove ()
{
    _docker_service_rm
}
_docker_service_rm ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_services
        ;;
    esac
}
_docker_service_rollback ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--detach -d --help --quit -q" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag );
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_services;
            fi
        ;;
    esac
}
_docker_service_scale ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--detach -d --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_services;
            __docker_append_to_completions "=";
            __docker_nospace
        ;;
    esac
}
_docker_service_update ()
{
    _docker_service_update_and_create
}
_docker_service_update_and_create ()
{
    local options_with_args="
		--cap-add
		--cap-drop
		--endpoint-mode
		--entrypoint
		--health-cmd
		--health-interval
		--health-retries
		--health-start-period
		--health-timeout
		--hostname
		--isolation
		--limit-cpu
		--limit-memory
		--limit-pids
		--log-driver
		--log-opt
		--max-replicas
		--replicas
		--replicas-max-per-node
		--reserve-cpu
		--reserve-memory
		--restart-condition
		--restart-delay
		--restart-max-attempts
		--restart-window
		--rollback-delay
		--rollback-failure-action
		--rollback-max-failure-ratio
		--rollback-monitor
		--rollback-order
		--rollback-parallelism
		--stop-grace-period
		--stop-signal
		--update-delay
		--update-failure-action
		--update-max-failure-ratio
		--update-monitor
		--update-order
		--update-parallelism
		--user -u
		--workdir -w
	";
    __docker_server_os_is windows && options_with_args+="
		--credential-spec
	";
    local boolean_options="
		--detach -d
		--help
		--init
		--no-healthcheck
		--no-resolve-image
		--read-only
		--tty -t
		--with-registry-auth
	";
    __docker_complete_log_driver_options && return;
    if [ "$subcommand" = "create" ]; then
        options_with_args="$options_with_args
			--config
			--constraint
			--container-label
			--dns
			--dns-option
			--dns-search
			--env -e
			--env-file
			--generic-resource
			--group
			--host
			--label -l
			--mode
			--mount
			--name
			--network
			--placement-pref
			--publish -p
			--secret
			--sysctl
			--ulimit
		";
        case "$prev" in
            --env-file)
                _filedir;
                return
            ;;
            --mode)
                COMPREPLY=($( compgen -W "global global-job replicated replicated-job" -- "$cur" ));
                return
            ;;
        esac;
    fi;
    if [ "$subcommand" = "update" ]; then
        options_with_args="$options_with_args
			--args
			--config-add
			--config-rm
			--constraint-add
			--constraint-rm
			--container-label-add
			--container-label-rm
			--dns-add
			--dns-option-add
			--dns-option-rm
			--dns-rm
			--dns-search-add
			--dns-search-rm
			--env-add
			--env-rm
			--generic-resource-add
			--generic-resource-rm
			--group-add
			--group-rm
			--host-add
			--host-rm
			--image
			--label-add
			--label-rm
			--mount-add
			--mount-rm
			--network-add
			--network-rm
			--placement-pref-add
			--placement-pref-rm
			--publish-add
			--publish-rm
			--rollback
			--secret-add
			--secret-rm
			--sysctl-add
			--sysctl-rm
			--ulimit-add
			--ulimit-rm
		";
        boolean_options="$boolean_options
			--force
		";
        case "$prev" in
            --env-rm)
                COMPREPLY=($( compgen -e -- "$cur" ));
                return
            ;;
            --image)
                __docker_complete_images --repo --tag --id;
                return
            ;;
        esac;
    fi;
    local strategy=$(__docker_map_key_of_current_option '--placement-pref|--placement-pref-add|--placement-pref-rm');
    case "$strategy" in
        spread)
            COMPREPLY=($( compgen -W "engine.labels node.labels" -S . -- "${cur##*=}" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "$prev" in
        --cap-add)
            __docker_complete_capabilities_addable;
            return
        ;;
        --cap-drop)
            __docker_complete_capabilities_droppable;
            return
        ;;
        --config | --config-add | --config-rm)
            __docker_complete_configs;
            return
        ;;
        --endpoint-mode)
            COMPREPLY=($( compgen -W "dnsrr vip" -- "$cur" ));
            return
        ;;
        --env | -e | --env-add)
            COMPREPLY=($( compgen -e -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --group | --group-add | --group-rm)
            COMPREPLY=($(compgen -g -- "$cur"));
            return
        ;;
        --host | --host-add | --host-rm)
            case "$cur" in
                *:)
                    __docker_complete_resolved_hostname;
                    return
                ;;
            esac
        ;;
        --isolation)
            __docker_complete_isolation;
            return
        ;;
        --log-driver)
            __docker_complete_log_drivers;
            return
        ;;
        --log-opt)
            __docker_complete_log_options;
            return
        ;;
        --network | --network-add | --network-rm)
            __docker_complete_networks;
            return
        ;;
        --placement-pref | --placement-pref-add | --placement-pref-rm)
            COMPREPLY=($( compgen -W "spread" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --restart-condition)
            COMPREPLY=($( compgen -W "any none on-failure" -- "$cur" ));
            return
        ;;
        --rollback-failure-action)
            COMPREPLY=($( compgen -W "continue pause" -- "$cur" ));
            return
        ;;
        --secret | --secret-add | --secret-rm)
            __docker_complete_secrets;
            return
        ;;
        --stop-signal)
            __docker_complete_signals;
            return
        ;;
        --update-failure-action)
            COMPREPLY=($( compgen -W "continue pause rollback" -- "$cur" ));
            return
        ;;
        --ulimit | --ulimit-add)
            __docker_complete_ulimits;
            return
        ;;
        --ulimit-rm)
            __docker_complete_ulimits --rm;
            return
        ;;
        --update-order | --rollback-order)
            COMPREPLY=($( compgen -W "start-first stop-first" -- "$cur" ));
            return
        ;;
        --user | -u)
            __docker_complete_user_group;
            return
        ;;
        $(__docker_to_extglob "$options_with_args"))
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "$boolean_options $options_with_args" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag "$( __docker_to_alternatives "$options_with_args" )" );
            if [ "$subcommand" = "update" ]; then
                if [ "$cword" -eq "$counter" ]; then
                    __docker_complete_services;
                fi;
            else
                if [ "$cword" -eq "$counter" ]; then
                    __docker_complete_images --repo --tag --id;
                fi;
            fi
        ;;
    esac
}
_docker_stack ()
{
    local subcommands="
		config
		deploy
		ls
		ps
		rm
		services
	";
    local aliases="
		down
		list
		remove
		up
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_stack_config ()
{
    case "$prev" in
        --compose-file | -c)
            _filedir yml;
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--compose-file -c --help --skip-interpolation" -- "$cur" ))
        ;;
    esac
}
_docker_stack_deploy ()
{
    case "$prev" in
        --compose-file | -c)
            _filedir yml;
            return
        ;;
        --resolve-image)
            COMPREPLY=($( compgen -W "always changed never" -- "$cur" ));
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--compose-file -c --help --prune --resolve-image --with-registry-auth" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--compose-file|-c|--resolve-image');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_stacks;
            fi
        ;;
    esac
}
_docker_stack_down ()
{
    _docker_stack_rm
}
_docker_stack_list ()
{
    _docker_stack_ls
}
_docker_stack_ls ()
{
    case "$prev" in
        --format)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--format --help" -- "$cur" ))
        ;;
    esac
}
_docker_stack_ps ()
{
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in
        desired-state)
            COMPREPLY=($( compgen -W "accepted running shutdown" -- "${cur##*=}" ));
            return
        ;;
        id)
            __docker_complete_stacks --cur "${cur##*=}" --id;
            return
        ;;
        name)
            __docker_complete_stacks --cur "${cur##*=}" --name;
            return
        ;;
    esac;
    case "$prev" in
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "id name desired-state" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --no-resolve --no-trunc --quiet -q" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--filter|-f|--format');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_stacks;
            fi
        ;;
    esac
}
_docker_stack_remove ()
{
    _docker_stack_rm
}
_docker_stack_rm ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            __docker_complete_stacks
        ;;
    esac
}
_docker_stack_services ()
{
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in
        id)
            __docker_complete_services --cur "${cur##*=}" --id;
            return
        ;;
        label)
            return
        ;;
        name)
            __docker_complete_services --cur "${cur##*=}" --name;
            return
        ;;
    esac;
    case "$prev" in
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "id label name" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --quiet -q" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag '--filter|-f|--format');
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_stacks;
            fi
        ;;
    esac
}
_docker_stack_up ()
{
    _docker_stack_deploy
}
_docker_start ()
{
    _docker_container_start
}
_docker_stats ()
{
    _docker_container_stats
}
_docker_stop ()
{
    _docker_container_stop
}
_docker_swarm ()
{
    local subcommands="
		ca
		init
		join
		join-token
		leave
		unlock
		unlock-key
		update
	";
    __docker_subcommands "$subcommands" && return;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_swarm_ca ()
{
    case "$prev" in
        --ca-cert | --ca-key)
            _filedir;
            return
        ;;
        --cert-expiry | --external-ca)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--ca-cert --ca-key --cert-expiry --detach -d --external-ca --help --quiet -q --rotate" -- "$cur" ))
        ;;
    esac
}
_docker_swarm_init ()
{
    case "$prev" in
        --advertise-addr)
            if [[ $cur == *: ]]; then
                COMPREPLY=($( compgen -W "2377" -- "${cur##*:}" ));
            else
                __docker_complete_local_interfaces;
                __docker_nospace;
            fi;
            return
        ;;
        --availability)
            COMPREPLY=($( compgen -W "active drain pause" -- "$cur" ));
            return
        ;;
        --cert-expiry | --data-path-port | --default-addr-pool | --default-addr-pool-mask-length | --dispatcher-heartbeat | --external-ca | --max-snapshots | --snapshot-interval | --task-history-limit)
            return
        ;;
        --data-path-addr)
            __docker_complete_local_interfaces;
            return
        ;;
        --listen-addr)
            if [[ $cur == *: ]]; then
                COMPREPLY=($( compgen -W "2377" -- "${cur##*:}" ));
            else
                __docker_complete_local_interfaces --add 0.0.0.0;
                __docker_nospace;
            fi;
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--advertise-addr --autolock --availability --cert-expiry --data-path-addr --data-path-port --default-addr-pool --default-addr-pool-mask-length --dispatcher-heartbeat --external-ca --force-new-cluster --help --listen-addr --max-snapshots --snapshot-interval --task-history-limit " -- "$cur" ))
        ;;
    esac
}
_docker_swarm_join ()
{
    case "$prev" in
        --advertise-addr)
            if [[ $cur == *: ]]; then
                COMPREPLY=($( compgen -W "2377" -- "${cur##*:}" ));
            else
                __docker_complete_local_interfaces;
                __docker_nospace;
            fi;
            return
        ;;
        --availability)
            COMPREPLY=($( compgen -W "active drain pause" -- "$cur" ));
            return
        ;;
        --data-path-addr)
            __docker_complete_local_interfaces;
            return
        ;;
        --listen-addr)
            if [[ $cur == *: ]]; then
                COMPREPLY=($( compgen -W "2377" -- "${cur##*:}" ));
            else
                __docker_complete_local_interfaces --add 0.0.0.0;
                __docker_nospace;
            fi;
            return
        ;;
        --token)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--advertise-addr --availability --data-path-addr --help --listen-addr --token" -- "$cur" ))
        ;;
        *:)
            COMPREPLY=($( compgen -W "2377" -- "${cur##*:}" ))
        ;;
    esac
}
_docker_swarm_join_token ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help --quiet -q --rotate" -- "$cur" ))
        ;;
        *)
            local counter=$( __docker_pos_first_nonflag );
            if [ "$cword" -eq "$counter" ]; then
                COMPREPLY=($( compgen -W "manager worker" -- "$cur" ));
            fi
        ;;
    esac
}
_docker_swarm_leave ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
    esac
}
_docker_swarm_unlock ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
    esac
}
_docker_swarm_unlock_key ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help --quiet -q --rotate" -- "$cur" ))
        ;;
    esac
}
_docker_swarm_update ()
{
    case "$prev" in
        --cert-expiry | --dispatcher-heartbeat | --external-ca | --max-snapshots | --snapshot-interval | --task-history-limit)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--autolock --cert-expiry --dispatcher-heartbeat --external-ca --help --max-snapshots --snapshot-interval --task-history-limit" -- "$cur" ))
        ;;
    esac
}
_docker_system ()
{
    local subcommands="
		df
		events
		info
		prune
	";
    __docker_subcommands "$subcommands" && return;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_system_df ()
{
    case "$prev" in
        --format)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--format --help --verbose -v" -- "$cur" ))
        ;;
    esac
}
_docker_system_events ()
{
    local key=$(__docker_map_key_of_current_option '-f|--filter');
    case "$key" in
        container)
            __docker_complete_containers_all --cur "${cur##*=}";
            return
        ;;
        daemon)
            local name=$(__docker_q info | sed -n 's/^\(ID\|Name\): //p');
            COMPREPLY=($( compgen -W "$name" -- "${cur##*=}" ));
            return
        ;;
        event)
            COMPREPLY=($( compgen -W "
				attach
				commit
				connect
				copy
				create
				delete
				destroy
				detach
				die
				disable
				disconnect
				enable
				exec_create
				exec_detach
				exec_die
				exec_start
				export
				health_status
				import
				install
				kill
				load
				mount
				oom
				pause
				pull
				push
				reload
				remove
				rename
				resize
				restart
				save
				start
				stop
				tag
				top
				unmount
				unpause
				untag
				update
			" -- "${cur##*=}" ));
            return
        ;;
        image)
            __docker_complete_images --cur "${cur##*=}" --repo --tag;
            return
        ;;
        network)
            __docker_complete_networks --cur "${cur##*=}";
            return
        ;;
        node)
            __docker_complete_nodes --cur "${cur##*=}";
            return
        ;;
        scope)
            COMPREPLY=($( compgen -W "local swarm" -- "${cur##*=}" ));
            return
        ;;
        type)
            COMPREPLY=($( compgen -W "config container daemon image network node plugin secret service volume" -- "${cur##*=}" ));
            return
        ;;
        volume)
            __docker_complete_volumes --cur "${cur##*=}";
            return
        ;;
    esac;
    case "$prev" in
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "container daemon event image label network node scope type volume" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --since | --until)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--filter -f --help --since --until --format" -- "$cur" ))
        ;;
    esac
}
_docker_system_info ()
{
    case "$prev" in
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--format -f --help" -- "$cur" ))
        ;;
    esac
}
_docker_system_prune ()
{
    case "$prev" in
        --filter)
            COMPREPLY=($( compgen -W "label label! until" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--all -a --force -f --filter --help --volumes" -- "$cur" ))
        ;;
    esac
}
_docker_tag ()
{
    _docker_image_tag
}
_docker_top ()
{
    _docker_container_top
}
_docker_trust ()
{
    local subcommands="
		inspect
		revoke
		sign
	";
    __docker_subcommands "$subcommands" && return;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_trust_inspect ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help --pretty" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_images --repo --tag;
            fi
        ;;
    esac
}
_docker_trust_revoke ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help --yes -y" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_images --repo --tag;
            fi
        ;;
    esac
}
_docker_trust_sign ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help --local" -- "$cur" ))
        ;;
        *)
            local counter=$(__docker_pos_first_nonflag);
            if [ "$cword" -eq "$counter" ]; then
                __docker_complete_images --force-tag --id;
            fi
        ;;
    esac
}
_docker_unpause ()
{
    _docker_container_unpause
}
_docker_update ()
{
    _docker_container_update
}
_docker_version ()
{
    case "$prev" in
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--format -f --help" -- "$cur" ))
        ;;
    esac
}
_docker_volume ()
{
    local subcommands="
		create
		inspect
		ls
		prune
		rm
	";
    local aliases="
		list
		remove
	";
    __docker_subcommands "$subcommands $aliases" && return;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--help" -- "$cur" ))
        ;;
        *)
            COMPREPLY=($( compgen -W "$subcommands" -- "$cur" ))
        ;;
    esac
}
_docker_volume_create ()
{
    case "$prev" in
        --driver | -d)
            __docker_complete_plugins_bundled --type Volume;
            return
        ;;
        --label | --opt | -o)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--driver -d --help --label --opt -o" -- "$cur" ))
        ;;
    esac
}
_docker_volume_inspect ()
{
    case "$prev" in
        --format | -f)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--format -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_volumes
        ;;
    esac
}
_docker_volume_list ()
{
    _docker_volume_ls
}
_docker_volume_ls ()
{
    local key=$(__docker_map_key_of_current_option '--filter|-f');
    case "$key" in
        dangling)
            COMPREPLY=($( compgen -W "true false" -- "${cur##*=}" ));
            return
        ;;
        driver)
            __docker_complete_plugins_bundled --cur "${cur##*=}" --type Volume;
            return
        ;;
        name)
            __docker_complete_volumes --cur "${cur##*=}";
            return
        ;;
    esac;
    case "$prev" in
        --filter | -f)
            COMPREPLY=($( compgen -S = -W "dangling driver label name" -- "$cur" ));
            __docker_nospace;
            return
        ;;
        --format)
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--filter -f --format --help --quiet -q" -- "$cur" ))
        ;;
    esac
}
_docker_volume_prune ()
{
    case "$prev" in
        --filter)
            COMPREPLY=($( compgen -W "label label!" -S = -- "$cur" ));
            __docker_nospace;
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--filter --force -f --help" -- "$cur" ))
        ;;
    esac
}
_docker_volume_remove ()
{
    _docker_volume_rm
}
_docker_volume_rm ()
{
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W "--force -f --help" -- "$cur" ))
        ;;
        *)
            __docker_complete_volumes
        ;;
    esac
}
_docker_wait ()
{
    _docker_container_wait
}
_doitlive_completion ()
{
    local IFS='	';
    COMPREPLY=($( env COMP_WORDS="${COMP_WORDS[*]}"                    COMP_CWORD=$COMP_CWORD                    _DOITLIVE_COMPLETE=complete-bash $1 ));
    return 0
}
_dub ()
{
    local cur prev words cword split;
    _init_completion -s || return;
    local creation_commands;
    creation_commands='init run build test generate describe clean dustmite';
    local management_commands;
    management_commands='fetch remove upgrade add-path remove-path add-local remove-local list add-override remove-override list-overrides clean-caches';
    case "$prev" in
        -h | --help)
            return 0
        ;;
    esac;
    $split && return 0;
    local common_options;
    common_options='-h -v -q';
    local packages;
    packages=$(dub list| awk '/^[[:space:]]+/ { print $1 }');
    if [[ $cword -eq 1 ]]; then
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '$common_options $( _parse_help "$1" )' -- "$cur" ));
        else
            COMPREPLY=($( compgen -W "$creation_commands $management_commands" -- "$cur" ));
        fi;
    else
        local command=${words[1]};
        local specific_options;
        specific_options=$( "$1" $command --help 2>/dev/null | _parse_help - );
        case $command in
            init | add-path | remove-path | add-local | remove-local | dustmite)
                COMPREPLY=($( compgen -d -W '$common_options $specific_options' -- "$cur" ))
            ;;
            run | build | test | generate | describe | clean | upgrade | add-override | remove-override)
                COMPREPLY=($( compgen -W '$packages $common_options $specific_options' -- "$cur" ))
            ;;
            *)
                COMPREPLY=($( compgen -W '$common_options $specific_options' -- "$cur" ))
            ;;
        esac;
    fi;
    [[ $COMPREPLY == *= ]] && compopt -o nospace;
    return
}
_dvd_devices ()
{
    COMPREPLY=("${COMPREPLY[@]}" $( compgen -f -d -X "!*/?(r)dvd*" -- "${cur:-/dev/}" ))
}
_edquota ()
{
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in
        -F | --format)
            _quota_formats;
            return 0
        ;;
        -f | --filesystem)
            _filesystems;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-r --remote -m --no-mixed-pathnames \
            -g --group -u --user -p --prototype -F --format -f --filesystem \
            -t --edit-period -T --edit-times' -- "$cur" ));
    else
        _user_or_group;
    fi
}
_exa ()
{
    cur=${COMP_WORDS[COMP_CWORD]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in
        -'?' | --help | -v | --version)
            return
        ;;
        -L | --level)
            COMPREPLY=($( compgen -W '{0..9}' -- "$cur" ));
            return
        ;;
        -s | --sort)
            COMPREPLY=($( compgen -W 'name filename Name Filename size filesize extension Extension date time modified changed accessed created type inode oldest newest age none --' -- "$cur" ));
            return
        ;;
        -t | --time)
            COMPREPLY=($( compgen -W 'modified changed accessed created --' -- $cur ));
            return
        ;;
        --time-style)
            COMPREPLY=($( compgen -W 'default iso long-iso full-iso --' -- $cur ));
            return
        ;;
    esac;
    case "$cur" in
        -*)
            COMPREPLY=($( compgen -W '$( _parse_help "$1" )' -- "$cur" ))
        ;;
        *)
            _filedir
        ;;
    esac
}
_expand ()
{
    if [[ "$cur" == \~*/* ]]; then
        eval cur=$cur;
    else
        if [[ "$cur" == \~* ]]; then
            cur=${cur#\~};
            COMPREPLY=($( compgen -P '~' -u "$cur" ));
            [ ${#COMPREPLY[@]} -eq 1 ] && eval COMPREPLY[0]=${COMPREPLY[0]};
            return ${#COMPREPLY[@]};
        fi;
    fi
}
_export ()
{
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    case $COMP_LINE in
        *=\$*)
            COMPREPLY=($( compgen -v -P '$' -- "${cur#*=\$}" ))
        ;;
        *[^=])
            COMPREPLY=($( compgen -v -S '=' -- "$cur" ))
        ;;
        *=)
            COMPREPLY=("$( eval echo -n \"$`echo ${cur%=}`\" |
                ( echo -n \'
                  sed -e 's/'\''/'\''\\\'\'''\''/g'
                  echo -n \' ) )")
        ;;
    esac
}
_fd ()
{
    local i cur prev opts cmds;
    COMPREPLY=();
    cur="${COMP_WORDS[COMP_CWORD]}";
    prev="${COMP_WORDS[COMP_CWORD-1]}";
    cmd="";
    opts="";
    for i in ${COMP_WORDS[@]};
    do
        case "${cmd},${i}" in
            ",$1")
                cmd="fd"
            ;;
            *)

            ;;
        esac;
    done;
    case "${cmd}" in
        fd)
            opts="-H -I -u -s -i -g -F -a -l -L -p -0 -d -E -t -e -S -o -x -X -c -j -1 -q -h -V --hidden --no-hidden --no-ignore --ignore --no-ignore-vcs --ignore-vcs --no-require-git --require-git --no-ignore-parent --no-global-ignore-file --unrestricted --case-sensitive --ignore-case --glob --regex --fixed-strings --and --absolute-path --relative-path --list-details --follow --no-follow --full-path --print0 --max-depth --min-depth --exact-depth --exclude --prune --type --extension --size --changed-within --changed-before --owner --exec --exec-batch --batch-size --ignore-file --color --threads --max-buffer-time --max-results --quiet --show-errors --base-directory --path-separator --search-path --strip-cwd-prefix --one-file-system --gen-completions --help --version [pattern] [path]...";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 1 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                --and)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --max-depth)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -d)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --min-depth)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --exact-depth)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --exclude)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -E)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --type)
                    COMPREPLY=($(compgen -W "file directory symlink executable empty socket pipe" -- "${cur}"));
                    return 0
                ;;
                -t)
                    COMPREPLY=($(compgen -W "file directory symlink executable empty socket pipe" -- "${cur}"));
                    return 0
                ;;
                --extension)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -e)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --size)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -S)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --changed-within)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --changed-before)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --owner)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -o)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --exec)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -x)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --exec-batch)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -X)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --batch-size)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --ignore-file)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --color)
                    COMPREPLY=($(compgen -W "auto always never" -- "${cur}"));
                    return 0
                ;;
                -c)
                    COMPREPLY=($(compgen -W "auto always never" -- "${cur}"));
                    return 0
                ;;
                --threads)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -j)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --max-buffer-time)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --max-results)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --base-directory)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --path-separator)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --search-path)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --gen-completions)
                    COMPREPLY=($(compgen -W "bash elvish fish powershell zsh" -- "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
    esac
}
_filedir ()
{
    local i IFS='
' xspec;
    _tilde "$cur" || return 0;
    local -a toks;
    local quoted tmp;
    _quote_readline_by_ref "$cur" quoted;
    toks=(${toks[@]-} $(
        compgen -d -- "$cur" | {
            while read -r tmp; do
                # TODO: I have removed a "[ -n $tmp ] &&" before 'printf ..',
                #       and everything works again. If this bug suddenly
                #       appears again (i.e. "cd /b<TAB>" becomes "cd /"),
                #       remember to check for other similar conditionals (here
                #       and _filedir_xspec()). --David
                printf '%s\n' $tmp
            done
        }
    ));
    if [[ "$1" != -d ]]; then
        [[ ${BASH_VERSINFO[0]} -ge 4 ]] && xspec=${1:+"!*.@($1|${1^^})"} || xspec=${1:+"!*.@($1|$(printf %s $1 | tr '[:lower:]' '[:upper:]'))"};
        toks=(${toks[@]-} $( compgen -f -X "$xspec" -- $quoted));
    fi;
    [ ${#toks[@]} -ne 0 ] && _compopt_o_filenames;
    COMPREPLY=("${COMPREPLY[@]}" "${toks[@]}")
}
_filedir_xspec ()
{
    local IFS cur xspec;
    IFS='
';
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    _expand || return 0;
    xspec=$( awk "/^complete[ \t]+.*[ \t]${1##*/}([ \t]|\$)/ { print \$0; exit }"         "$BASH_COMPLETION" );
    xspec=${xspec#*-X };
    xspec=${xspec%% *};
    local -a toks;
    local tmp;
    toks=(${toks[@]-} $(
        compgen -d -- "$(quote_readline "$cur")" | {
        while read -r tmp; do
            # see long TODO comment in _filedir() --David
            printf '%s\n' $tmp
        done
        }
        ));
    eval xspec="${xspec}";
    local matchop=!;
    if [[ $xspec == !* ]]; then
        xspec=${xspec#!};
        matchop=@;
    fi;
    [[ ${BASH_VERSINFO[0]} -ge 4 ]] && xspec="$matchop($xspec|${xspec^^})" || xspec="$matchop($xspec|$(printf %s $xspec | tr '[:lower:]' '[:upper:]'))";
    toks=(${toks[@]-} $(
        eval compgen -f -X "!$xspec" -- "\$(quote_readline "\$cur")" | {
        while read -r tmp; do
            [ -n $tmp ] && printf '%s\n' $tmp
        done
        }
        ));
    [ ${#toks[@]} -ne 0 ] && _compopt_o_filenames;
    COMPREPLY=("${toks[@]}")
}
_filesystems ()
{
    COMPREPLY=($( compgen -W "$(awk '/^\// {print $1}' /etc/mtab)"         -- "$cur" ))
}
_find ()
{
    local cur prev i exprfound onlyonce;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in
        -maxdepth | -mindepth)
            COMPREPLY=($( compgen -W '0 1 2 3 4 5 6 7 8 9' -- "$cur" ));
            return 0
        ;;
        -newer | -anewer | -cnewer | -fls | -fprint | -fprint0 | -fprintf | -name | -iname | -lname | -ilname | -wholename | -iwholename | -samefile)
            _filedir;
            return 0
        ;;
        -fstype)
            _fstypes;
            if [[ "$( uname -s )" == *BSD ]]; then
                COMPREPLY=("${COMPREPLY[@]}" $( compgen -W 'local rdonly' -- "$cur" ));
            fi;
            return 0
        ;;
        -gid)
            _gids;
            return 0
        ;;
        -group)
            COMPREPLY=($( compgen -g -- "$cur" 2>/dev/null));
            return 0
        ;;
        -xtype | -type)
            COMPREPLY=($( compgen -W 'b c d p f l s' -- "$cur" ));
            return 0
        ;;
        -uid)
            _uids;
            return 0
        ;;
        -user)
            COMPREPLY=($( compgen -u -- "$cur" ));
            return 0
        ;;
        -exec | -execdir | -ok | -okdir)
            COMP_WORDS=(COMP_WORDS[0] "$cur");
            COMP_CWORD=1;
            _command;
            return 0
        ;;
        -[acm]min | -[acm]time | -iname | -lname | -wholename | -iwholename | -lwholename | -ilwholename | -inum | -path | -ipath | -regex | -iregex | -links | -perm | -size | -used | -printf | -context)
            return 0
        ;;
        -regextype)
            COMPREPLY=($( compgen -W 'emacs posix-awk posix-basic \
                posix-egrep posix-extended' -- "$cur" ));
            return 0
        ;;
    esac;
    _expand || return 0;
    for i in ${COMP_WORDS[@]};
    do
        [[ "$i" = [-\(\),\!]* ]] && exprfound=1 && break;
    done;
    if [[ "$exprfound" != 1 && "$cur" != [-\(\),\!]* ]]; then
        _filedir -d;
        return 0;
    fi;
    COMPREPLY=($( compgen -W '-daystart -depth -follow -help \
        -ignore_readdir_race -maxdepth -mindepth -mindepth -mount \
        -noignore_readdir_race -noleaf -regextype -version -warn -nowarn \
        -xdev \
        -amin -anewer -atime -cmin -cnewer -ctime -empty -executable -false \
        -fstype -gid -group -ilname -iname -inum -ipath -iregex -iwholename \
        -links -lname -mmin -mtime -name -newer -nogroup -nouser -path -perm \
        -readable -regex -samefile -size -true -type -uid -used -user \
        -wholename -writable -xtype -context \
        -delete -exec -execdir -fls -fprint -fprint0 -fprintf -ls -ok -okdir \
        -print -print0 -printf -prune -quit' -- "$cur" ));
    onlyonce=' -daystart -depth -follow -help -ignore_readdir_race -maxdepth \
       -mindepth -mount -noignore_readdir_race -noleaf -nowarn -regextype \
       -version -warn -xdev ';
    COMPREPLY=($(            (while read -d ' ' i; do
            [[ -z "$i" || "${onlyonce/ ${i%% *} / }" == "$onlyonce" ]] &&
            continue
            # flatten array with spaces on either side,
            # otherwise we cannot grep on word boundaries of
            # first and last word
            COMPREPLY=" ${COMPREPLY[@]} "
            # remove word from list of completions
            COMPREPLY=( ${COMPREPLY/ ${i%% *} / } )
            done
            printf '%s ' "${COMPREPLY[@]}") <<<"${COMP_WORDS[@]}"
          ));
    _filedir;
    return 0
}
_fstypes ()
{
    local fss;
    if [ -e /proc/filesystems ]; then
        fss="$( cut -d'	' -f2 /proc/filesystems )
             $( awk '! /\*/ { print $NF }' /etc/filesystems 2>/dev/null )";
    else
        fss="$( awk '/^[ \t]*[^#]/ { print $3 }' /etc/fstab 2>/dev/null )
             $( awk '/^[ \t]*[^#]/ { print $3 }' /etc/mnttab 2>/dev/null )
             $( awk '/^[ \t]*[^#]/ { print $4 }' /etc/vfstab 2>/dev/null )
             $( awk '{ print $1 }' /etc/dfs/fstypes 2>/dev/null )
             $( [ -d /etc/fs ] && command ls /etc/fs )";
    fi;
    [ -n "$fss" ] && COMPREPLY=("${COMPREPLY[@]}" $( compgen -W "$fss" -- "$cur" ))
}
_function ()
{
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    if [[ $1 == @(declare|typeset) ]]; then
        if [ "$prev" = -f ]; then
            COMPREPLY=($( compgen -A function -- "$cur" ));
        else
            if [[ "$cur" == -* ]]; then
                COMPREPLY=($( compgen -W '-a -f -F -i -r -x -p' -- "$cur" ));
            fi;
        fi;
    else
        if [ $COMP_CWORD -eq 1 ]; then
            COMPREPLY=($( compgen -A function -- "$cur" ));
        else
            COMPREPLY=("() $( type -- ${COMP_WORDS[1]} | sed -e 1,2d )");
        fi;
    fi
}
_gcc ()
{
    local cur cc backend;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    _expand || return 0;
    case $1 in
        gcj)
            backend=jc1
        ;;
        gpc)
            backend=gpc1
        ;;
        *77)
            backend=f771
        ;;
        *)
            backend=cc1
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        cc=$( $1 -print-prog-name=$backend );
        COMPREPLY=($( compgen -W "$( $cc --help 2>/dev/null |            tr '\t' ' ' |            sed -e '/^  *-/!d' -e 's/ *-\([^ ]*\).*/-\1/' |            sort -u )" -- "$cur" ));
    else
        _filedir;
    fi
}
_get_comp_words_by_ref ()
{
    local exclude flag i OPTIND=1;
    local cur cword words=();
    local upargs=() upvars=() vcur vcword vprev vwords;
    while getopts "c:i:n:p:w:" flag "$@"; do
        case $flag in
            c)
                vcur=$OPTARG
            ;;
            i)
                vcword=$OPTARG
            ;;
            n)
                exclude=$OPTARG
            ;;
            p)
                vprev=$OPTARG
            ;;
            w)
                vwords=$OPTARG
            ;;
        esac;
    done;
    while [[ $# -ge $OPTIND ]]; do
        case ${!OPTIND} in
            cur)
                vcur=cur
            ;;
            prev)
                vprev=prev
            ;;
            cword)
                vcword=cword
            ;;
            words)
                vwords=words
            ;;
            *)
                echo "bash: $FUNCNAME(): \`${!OPTIND}': unknown argument" 1>&2;
                return 1
            ;;
        esac;
        let "OPTIND += 1";
    done;
    __get_cword_at_cursor_by_ref "$exclude" words cword cur;
    [[ -n $vcur ]] && {
        upvars+=("$vcur");
        upargs+=(-v $vcur "$cur")
    };
    [[ -n $vcword ]] && {
        upvars+=("$vcword");
        upargs+=(-v $vcword "$cword")
    };
    [[ -n $vprev ]] && {
        upvars+=("$vprev");
        upargs+=(-v $vprev "${words[cword - 1]}")
    };
    [[ -n $vwords ]] && {
        upvars+=("$vwords");
        upargs+=(-a${#words[@]} $vwords "${words[@]}")
    };
    (( ${#upvars[@]} )) && local "${upvars[@]}" && _upvars "${upargs[@]}"
}
_get_cword ()
{
    local LC_CTYPE=C;
    local cword words;
    __reassemble_comp_words_by_ref "$1" words cword;
    if [[ -n ${2//[^0-9]/} ]]; then
        printf "%s" "${words[cword-$2]}";
    else
        if [[ "${#words[cword]}" -eq 0 || "$COMP_POINT" == "${#COMP_LINE}" ]]; then
            printf "%s" "${words[cword]}";
        else
            local i;
            local cur="$COMP_LINE";
            local index="$COMP_POINT";
            for ((i = 0; i <= cword; ++i ))
            do
                while [[ "${#cur}" -ge ${#words[i]} && "${cur:0:${#words[i]}}" != "${words[i]}" ]]; do
                    cur="${cur:1}";
                    ((index--));
                done;
                if [[ "$i" -lt "$cword" ]]; then
                    local old_size="${#cur}";
                    cur="${cur#${words[i]}}";
                    local new_size="${#cur}";
                    index=$(( index - old_size + new_size ));
                fi;
            done;
            if [[ "${words[cword]:0:${#cur}}" != "$cur" ]]; then
                printf "%s" "${words[cword]}";
            else
                printf "%s" "${cur:0:$index}";
            fi;
        fi;
    fi
}
_get_first_arg ()
{
    local i;
    arg=;
    for ((i=1; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            arg=${COMP_WORDS[i]};
            break;
        fi;
    done
}
_get_pword ()
{
    if [ $COMP_CWORD -ge 1 ]; then
        _get_cword "${@:-}" 1;
    fi
}
_gids ()
{
    if type getent >&/dev/null; then
        COMPREPLY=($( compgen -W '$( getent group | cut -d: -f3 )'             -- "$cur" ));
    else
        if type perl >&/dev/null; then
            COMPREPLY=($( compgen -W '$( perl -e '"'"'while (($gid) = (getgrent)[2]) { print $gid . "\n" }'"'"' )' -- "$cur" ));
        else
            COMPREPLY=($( compgen -W '$( cut -d: -f3 /etc/group )' -- "$cur" ));
        fi;
    fi
}
_git_add ()
{
    case "$cur" in
        --chmod=*)
            __gitcomp "+x -x" "" "${cur##--chmod=}";
            return
        ;;
        --*)
            __gitcomp_builtin add;
            return
        ;;
    esac;
    local complete_opt="--others --modified --directory --no-empty-directory";
    if test -n "$(__git_find_on_cmdline "-u --update")"; then
        complete_opt="--modified";
    fi;
    __git_complete_index_file "$complete_opt"
}
_git_am ()
{
    __git_find_repo_path;
    if [ -d "$__git_repo_path"/rebase-apply ]; then
        __gitcomp "$__git_am_inprogress_options";
        return;
    fi;
    case "$cur" in
        --whitespace=*)
            __gitcomp "$__git_whitespacelist" "" "${cur##--whitespace=}";
            return
        ;;
        --patch-format=*)
            __gitcomp "$__git_patchformat" "" "${cur##--patch-format=}";
            return
        ;;
        --show-current-patch=*)
            __gitcomp "$__git_showcurrentpatch" "" "${cur##--show-current-patch=}";
            return
        ;;
        --quoted-cr=*)
            __gitcomp "$__git_quoted_cr" "" "${cur##--quoted-cr=}";
            return
        ;;
        --*)
            __gitcomp_builtin am "" "$__git_am_inprogress_options";
            return
        ;;
    esac
}
_git_apply ()
{
    case "$cur" in
        --whitespace=*)
            __gitcomp "$__git_whitespacelist" "" "${cur##--whitespace=}";
            return
        ;;
        --*)
            __gitcomp_builtin apply;
            return
        ;;
    esac
}
_git_archive ()
{
    case "$cur" in
        --format=*)
            __gitcomp "$(git archive --list)" "" "${cur##--format=}";
            return
        ;;
        --remote=*)
            __gitcomp_nl "$(__git_remotes)" "" "${cur##--remote=}";
            return
        ;;
        --*)
            __gitcomp_builtin archive "--format= --list --verbose --prefix= --worktree-attributes";
            return
        ;;
    esac;
    __git_complete_file
}
_git_bisect ()
{
    __git_has_doubledash && return;
    local subcommands="start bad good skip reset visualize replay log run";
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if [ -z "$subcommand" ]; then
        __git_find_repo_path;
        if [ -f "$__git_repo_path"/BISECT_START ]; then
            __gitcomp "$subcommands";
        else
            __gitcomp "replay start";
        fi;
        return;
    fi;
    case "$subcommand" in
        bad | good | reset | skip | start)
            __git_complete_refs
        ;;
        *)

        ;;
    esac
}
_git_branch ()
{
    local i c="$__git_cmd_idx" only_local_ref="n" has_r="n";
    while [ $c -lt $cword ]; do
        i="${words[c]}";
        case "$i" in
            -d | -D | --delete | -m | -M | --move | -c | -C | --copy)
                only_local_ref="y"
            ;;
            -r | --remotes)
                has_r="y"
            ;;
        esac;
        ((c++));
    done;
    case "$cur" in
        --set-upstream-to=*)
            __git_complete_refs --cur="${cur##--set-upstream-to=}"
        ;;
        --*)
            __gitcomp_builtin branch
        ;;
        *)
            if [ $only_local_ref = "y" -a $has_r = "n" ]; then
                __gitcomp_direct "$(__git_heads "" "$cur" " ")";
            else
                __git_complete_refs;
            fi
        ;;
    esac
}
_git_bundle ()
{
    local cmd="${words[__git_cmd_idx+1]}";
    case "$cword" in
        $((__git_cmd_idx+1)))
            __gitcomp "create list-heads verify unbundle"
        ;;
        $((__git_cmd_idx+2)))

        ;;
        *)
            case "$cmd" in
                create)
                    __git_complete_revlist
                ;;
            esac
        ;;
    esac
}
_git_checkout ()
{
    __git_has_doubledash && return;
    local dwim_opt="$(__git_checkout_default_dwim_mode)";
    case "$prev" in
        -b | -B | --orphan)
            __git_complete_refs $dwim_opt --mode="heads";
            return
        ;;
        *)

        ;;
    esac;
    case "$cur" in
        --conflict=*)
            __gitcomp "diff3 merge zdiff3" "" "${cur##--conflict=}"
        ;;
        --*)
            __gitcomp_builtin checkout
        ;;
        *)
            if [ -n "$(__git_find_on_cmdline "-b -B -d --detach --orphan")" ]; then
                __git_complete_refs --mode="refs";
            else
                if [ -n "$(__git_find_on_cmdline "--track")" ]; then
                    __git_complete_refs --mode="remote-heads";
                else
                    __git_complete_refs $dwim_opt --mode="refs";
                fi;
            fi
        ;;
    esac
}
_git_cherry_pick ()
{
    __git_find_repo_path;
    if [ -f "$__git_repo_path"/CHERRY_PICK_HEAD ]; then
        __gitcomp "$__git_cherry_pick_inprogress_options";
        return;
    fi;
    __git_complete_strategy && return;
    case "$cur" in
        --*)
            __gitcomp_builtin cherry-pick "" "$__git_cherry_pick_inprogress_options"
        ;;
        *)
            __git_complete_refs
        ;;
    esac
}
_git_clean ()
{
    case "$cur" in
        --*)
            __gitcomp_builtin clean;
            return
        ;;
    esac;
    __git_complete_index_file "--others --directory"
}
_git_clone ()
{
    case "$prev" in
        -c | --config)
            __git_complete_config_variable_name_and_value;
            return
        ;;
    esac;
    case "$cur" in
        --config=*)
            __git_complete_config_variable_name_and_value --cur="${cur##--config=}";
            return
        ;;
        --*)
            __gitcomp_builtin clone;
            return
        ;;
    esac
}
_git_commit ()
{
    case "$prev" in
        -c | -C)
            __git_complete_refs;
            return
        ;;
    esac;
    case "$cur" in
        --cleanup=*)
            __gitcomp "default scissors strip verbatim whitespace
			" "" "${cur##--cleanup=}";
            return
        ;;
        --reuse-message=* | --reedit-message=* | --fixup=* | --squash=*)
            __git_complete_refs --cur="${cur#*=}";
            return
        ;;
        --untracked-files=*)
            __gitcomp "$__git_untracked_file_modes" "" "${cur##--untracked-files=}";
            return
        ;;
        --*)
            __gitcomp_builtin commit;
            return
        ;;
    esac;
    if __git rev-parse --verify --quiet HEAD > /dev/null; then
        __git_complete_index_file "--committable";
    else
        __git_complete_index_file "--cached";
    fi
}
_git_config ()
{
    case "$prev" in
        --get | --get-all | --unset | --unset-all)
            __gitcomp_nl "$(__git_config_get_set_variables)";
            return
        ;;
        *.*)
            __git_complete_config_variable_value;
            return
        ;;
    esac;
    case "$cur" in
        --*)
            __gitcomp_builtin config
        ;;
        *)
            __git_complete_config_variable_name
        ;;
    esac
}
_git_describe ()
{
    case "$cur" in
        --*)
            __gitcomp_builtin describe;
            return
        ;;
    esac;
    __git_complete_refs
}
_git_diff ()
{
    __git_has_doubledash && return;
    case "$cur" in
        --diff-algorithm=*)
            __gitcomp "$__git_diff_algorithms" "" "${cur##--diff-algorithm=}";
            return
        ;;
        --submodule=*)
            __gitcomp "$__git_diff_submodule_formats" "" "${cur##--submodule=}";
            return
        ;;
        --color-moved=*)
            __gitcomp "$__git_color_moved_opts" "" "${cur##--color-moved=}";
            return
        ;;
        --color-moved-ws=*)
            __gitcomp "$__git_color_moved_ws_opts" "" "${cur##--color-moved-ws=}";
            return
        ;;
        --*)
            __gitcomp "$__git_diff_difftool_options";
            return
        ;;
    esac;
    __git_complete_revlist_file
}
_git_difftool ()
{
    __git_has_doubledash && return;
    case "$cur" in
        --tool=*)
            __gitcomp "$__git_mergetools_common kompare" "" "${cur##--tool=}";
            return
        ;;
        --*)
            __gitcomp_builtin difftool "$__git_diff_difftool_options";
            return
        ;;
    esac;
    __git_complete_revlist_file
}
_git_fetch ()
{
    case "$cur" in
        --recurse-submodules=*)
            __gitcomp "$__git_fetch_recurse_submodules" "" "${cur##--recurse-submodules=}";
            return
        ;;
        --filter=*)
            __gitcomp "blob:none blob:limit= sparse:oid=" "" "${cur##--filter=}";
            return
        ;;
        --*)
            __gitcomp_builtin fetch;
            return
        ;;
    esac;
    __git_complete_remote_or_refspec
}
_git_format_patch ()
{
    case "$cur" in
        --thread=*)
            __gitcomp "
			deep shallow
			" "" "${cur##--thread=}";
            return
        ;;
        --base=* | --interdiff=* | --range-diff=*)
            __git_complete_refs --cur="${cur#--*=}";
            return
        ;;
        --*)
            __gitcomp_builtin format-patch "$__git_format_patch_extra_options";
            return
        ;;
    esac;
    __git_complete_revlist
}
_git_fsck ()
{
    case "$cur" in
        --*)
            __gitcomp_builtin fsck;
            return
        ;;
    esac
}
_git_gitk ()
{
    __gitk_main
}
_git_grep ()
{
    __git_has_doubledash && return;
    case "$cur" in
        --*)
            __gitcomp_builtin grep;
            return
        ;;
    esac;
    case "$cword,$prev" in
        $((__git_cmd_idx+1)),* | *,-*)
            __git_complete_symbol && return
        ;;
    esac;
    __git_complete_refs
}
_git_help ()
{
    case "$cur" in
        --*)
            __gitcomp_builtin help;
            return
        ;;
    esac;
    if test -n "${GIT_TESTING_ALL_COMMAND_LIST-}"; then
        __gitcomp "$GIT_TESTING_ALL_COMMAND_LIST $(__git --list-cmds=alias,list-guide) gitk";
    else
        __gitcomp "$(__git --list-cmds=main,nohelpers,alias,list-guide) gitk";
    fi
}
_git_init ()
{
    case "$cur" in
        --shared=*)
            __gitcomp "
			false true umask group all world everybody
			" "" "${cur##--shared=}";
            return
        ;;
        --*)
            __gitcomp_builtin init;
            return
        ;;
    esac
}
_git_log ()
{
    __git_has_doubledash && return;
    __git_find_repo_path;
    local merge="";
    if [ -f "$__git_repo_path/MERGE_HEAD" ]; then
        merge="--merge";
    fi;
    case "$prev,$cur" in
        -L,:*:*)
            return
        ;;
        -L,:*)
            __git_complete_symbol --cur="${cur#:}" --sfx=":";
            return
        ;;
        -G,* | -S,*)
            __git_complete_symbol;
            return
        ;;
    esac;
    case "$cur" in
        --pretty=* | --format=*)
            __gitcomp "$__git_log_pretty_formats $(__git_pretty_aliases)
			" "" "${cur#*=}";
            return
        ;;
        --date=*)
            __gitcomp "$__git_log_date_formats" "" "${cur##--date=}";
            return
        ;;
        --decorate=*)
            __gitcomp "full short no" "" "${cur##--decorate=}";
            return
        ;;
        --diff-algorithm=*)
            __gitcomp "$__git_diff_algorithms" "" "${cur##--diff-algorithm=}";
            return
        ;;
        --submodule=*)
            __gitcomp "$__git_diff_submodule_formats" "" "${cur##--submodule=}";
            return
        ;;
        --no-walk=*)
            __gitcomp "sorted unsorted" "" "${cur##--no-walk=}";
            return
        ;;
        --*)
            __gitcomp "
			$__git_log_common_options
			$__git_log_shortlog_options
			$__git_log_gitk_options
			--root --topo-order --date-order --reverse
			--follow --full-diff
			--abbrev-commit --no-abbrev-commit --abbrev=
			--relative-date --date=
			--pretty= --format= --oneline
			--show-signature
			--cherry-mark
			--cherry-pick
			--graph
			--decorate --decorate= --no-decorate
			--walk-reflogs
			--no-walk --no-walk= --do-walk
			--parents --children
			--expand-tabs --expand-tabs= --no-expand-tabs
			$merge
			$__git_diff_common_options
			--pickaxe-all --pickaxe-regex
			";
            return
        ;;
        -L:*:*)
            return
        ;;
        -L:*)
            __git_complete_symbol --cur="${cur#-L:}" --sfx=":";
            return
        ;;
        -G*)
            __git_complete_symbol --pfx="-G" --cur="${cur#-G}";
            return
        ;;
        -S*)
            __git_complete_symbol --pfx="-S" --cur="${cur#-S}";
            return
        ;;
    esac;
    __git_complete_revlist
}
_git_ls_files ()
{
    case "$cur" in
        --*)
            __gitcomp_builtin ls-files;
            return
        ;;
    esac;
    __git_complete_index_file "--cached"
}
_git_ls_remote ()
{
    case "$cur" in
        --*)
            __gitcomp_builtin ls-remote;
            return
        ;;
    esac;
    __gitcomp_nl "$(__git_remotes)"
}
_git_ls_tree ()
{
    case "$cur" in
        --*)
            __gitcomp_builtin ls-tree;
            return
        ;;
    esac;
    __git_complete_file
}
_git_merge ()
{
    __git_complete_strategy && return;
    case "$cur" in
        --*)
            __gitcomp_builtin merge;
            return
        ;;
    esac;
    __git_complete_refs
}
_git_merge_base ()
{
    case "$cur" in
        --*)
            __gitcomp_builtin merge-base;
            return
        ;;
    esac;
    __git_complete_refs
}
_git_mergetool ()
{
    case "$cur" in
        --tool=*)
            __gitcomp "$__git_mergetools_common tortoisemerge" "" "${cur##--tool=}";
            return
        ;;
        --*)
            __gitcomp "--tool= --prompt --no-prompt --gui --no-gui";
            return
        ;;
    esac
}
_git_mv ()
{
    case "$cur" in
        --*)
            __gitcomp_builtin mv;
            return
        ;;
    esac;
    if [ $(__git_count_arguments "mv") -gt 0 ]; then
        __git_complete_index_file "--cached --others --directory";
    else
        __git_complete_index_file "--cached";
    fi
}
_git_notes ()
{
    local subcommands='add append copy edit get-ref list merge prune remove show';
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    case "$subcommand,$cur" in
        ,--*)
            __gitcomp_builtin notes
        ;;
        ,*)
            case "$prev" in
                --ref)
                    __git_complete_refs
                ;;
                *)
                    __gitcomp "$subcommands --ref"
                ;;
            esac
        ;;
        *,--reuse-message=* | *,--reedit-message=*)
            __git_complete_refs --cur="${cur#*=}"
        ;;
        *,--*)
            __gitcomp_builtin notes_$subcommand
        ;;
        prune,* | get-ref,*)

        ;;
        *)
            case "$prev" in
                -m | -F)

                ;;
                *)
                    __git_complete_refs
                ;;
            esac
        ;;
    esac
}
_git_pull ()
{
    __git_complete_strategy && return;
    case "$cur" in
        --recurse-submodules=*)
            __gitcomp "$__git_fetch_recurse_submodules" "" "${cur##--recurse-submodules=}";
            return
        ;;
        --*)
            __gitcomp_builtin pull;
            return
        ;;
    esac;
    __git_complete_remote_or_refspec
}
_git_push ()
{
    case "$prev" in
        --repo)
            __gitcomp_nl "$(__git_remotes)";
            return
        ;;
        --recurse-submodules)
            __gitcomp "$__git_push_recurse_submodules";
            return
        ;;
    esac;
    case "$cur" in
        --repo=*)
            __gitcomp_nl "$(__git_remotes)" "" "${cur##--repo=}";
            return
        ;;
        --recurse-submodules=*)
            __gitcomp "$__git_push_recurse_submodules" "" "${cur##--recurse-submodules=}";
            return
        ;;
        --force-with-lease=*)
            __git_complete_force_with_lease "${cur##--force-with-lease=}";
            return
        ;;
        --*)
            __gitcomp_builtin push;
            return
        ;;
    esac;
    __git_complete_remote_or_refspec
}
_git_range_diff ()
{
    case "$cur" in
        --*)
            __gitcomp "
			--creation-factor= --no-dual-color
			$__git_diff_common_options
		";
            return
        ;;
    esac;
    __git_complete_revlist
}
_git_rebase ()
{
    __git_find_repo_path;
    if [ -f "$__git_repo_path"/rebase-merge/interactive ]; then
        __gitcomp "$__git_rebase_interactive_inprogress_options";
        return;
    else
        if [ -d "$__git_repo_path"/rebase-apply ] || [ -d "$__git_repo_path"/rebase-merge ]; then
            __gitcomp "$__git_rebase_inprogress_options";
            return;
        fi;
    fi;
    __git_complete_strategy && return;
    case "$cur" in
        --whitespace=*)
            __gitcomp "$__git_whitespacelist" "" "${cur##--whitespace=}";
            return
        ;;
        --onto=*)
            __git_complete_refs --cur="${cur##--onto=}";
            return
        ;;
        --*)
            __gitcomp_builtin rebase "" "$__git_rebase_interactive_inprogress_options";
            return
        ;;
    esac;
    __git_complete_refs
}
_git_reflog ()
{
    local subcommands="show delete expire";
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if [ -z "$subcommand" ]; then
        __gitcomp "$subcommands";
    else
        __git_complete_refs;
    fi
}
_git_remote ()
{
    local subcommands="
		add rename remove set-head set-branches
		get-url set-url show prune update
		";
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if [ -z "$subcommand" ]; then
        case "$cur" in
            --*)
                __gitcomp_builtin remote
            ;;
            *)
                __gitcomp "$subcommands"
            ;;
        esac;
        return;
    fi;
    case "$subcommand,$cur" in
        add,--*)
            __gitcomp_builtin remote_add
        ;;
        add,*)

        ;;
        set-head,--*)
            __gitcomp_builtin remote_set-head
        ;;
        set-branches,--*)
            __gitcomp_builtin remote_set-branches
        ;;
        set-head,* | set-branches,*)
            __git_complete_remote_or_refspec
        ;;
        update,--*)
            __gitcomp_builtin remote_update
        ;;
        update,*)
            __gitcomp "$(__git_remotes) $(__git_get_config_variables "remotes")"
        ;;
        set-url,--*)
            __gitcomp_builtin remote_set-url
        ;;
        get-url,--*)
            __gitcomp_builtin remote_get-url
        ;;
        prune,--*)
            __gitcomp_builtin remote_prune
        ;;
        *)
            __gitcomp_nl "$(__git_remotes)"
        ;;
    esac
}
_git_replace ()
{
    case "$cur" in
        --format=*)
            __gitcomp "short medium long" "" "${cur##--format=}";
            return
        ;;
        --*)
            __gitcomp_builtin replace;
            return
        ;;
    esac;
    __git_complete_refs
}
_git_rerere ()
{
    local subcommands="clear forget diff remaining status gc";
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if test -z "$subcommand"; then
        __gitcomp "$subcommands";
        return;
    fi
}
_git_reset ()
{
    __git_has_doubledash && return;
    case "$cur" in
        --*)
            __gitcomp_builtin reset;
            return
        ;;
    esac;
    __git_complete_refs
}
_git_restore ()
{
    case "$prev" in
        -s)
            __git_complete_refs;
            return
        ;;
    esac;
    case "$cur" in
        --conflict=*)
            __gitcomp "diff3 merge zdiff3" "" "${cur##--conflict=}"
        ;;
        --source=*)
            __git_complete_refs --cur="${cur##--source=}"
        ;;
        --*)
            __gitcomp_builtin restore
        ;;
        *)
            if __git rev-parse --verify --quiet HEAD > /dev/null; then
                __git_complete_index_file "--modified";
            fi
        ;;
    esac
}
_git_revert ()
{
    __git_find_repo_path;
    if [ -f "$__git_repo_path"/REVERT_HEAD ]; then
        __gitcomp "$__git_revert_inprogress_options";
        return;
    fi;
    __git_complete_strategy && return;
    case "$cur" in
        --*)
            __gitcomp_builtin revert "" "$__git_revert_inprogress_options";
            return
        ;;
    esac;
    __git_complete_refs
}
_git_rm ()
{
    case "$cur" in
        --*)
            __gitcomp_builtin rm;
            return
        ;;
    esac;
    __git_complete_index_file "--cached"
}
_git_send_email ()
{
    case "$prev" in
        --to | --cc | --bcc | --from)
            __gitcomp "$(__git send-email --dump-aliases)";
            return
        ;;
    esac;
    case "$cur" in
        --confirm=*)
            __gitcomp "
			$__git_send_email_confirm_options
			" "" "${cur##--confirm=}";
            return
        ;;
        --suppress-cc=*)
            __gitcomp "
			$__git_send_email_suppresscc_options
			" "" "${cur##--suppress-cc=}";
            return
        ;;
        --smtp-encryption=*)
            __gitcomp "ssl tls" "" "${cur##--smtp-encryption=}";
            return
        ;;
        --thread=*)
            __gitcomp "
			deep shallow
			" "" "${cur##--thread=}";
            return
        ;;
        --to=* | --cc=* | --bcc=* | --from=*)
            __gitcomp "$(__git send-email --dump-aliases)" "" "${cur#--*=}";
            return
        ;;
        --*)
            __gitcomp_builtin send-email "$__git_format_patch_extra_options";
            return
        ;;
    esac;
    __git_complete_revlist
}
_git_shortlog ()
{
    __git_has_doubledash && return;
    case "$cur" in
        --*)
            __gitcomp "
			$__git_log_common_options
			$__git_log_shortlog_options
			--numbered --summary --email
			";
            return
        ;;
    esac;
    __git_complete_revlist
}
_git_show ()
{
    __git_has_doubledash && return;
    case "$cur" in
        --pretty=* | --format=*)
            __gitcomp "$__git_log_pretty_formats $(__git_pretty_aliases)
			" "" "${cur#*=}";
            return
        ;;
        --diff-algorithm=*)
            __gitcomp "$__git_diff_algorithms" "" "${cur##--diff-algorithm=}";
            return
        ;;
        --submodule=*)
            __gitcomp "$__git_diff_submodule_formats" "" "${cur##--submodule=}";
            return
        ;;
        --color-moved=*)
            __gitcomp "$__git_color_moved_opts" "" "${cur##--color-moved=}";
            return
        ;;
        --color-moved-ws=*)
            __gitcomp "$__git_color_moved_ws_opts" "" "${cur##--color-moved-ws=}";
            return
        ;;
        --*)
            __gitcomp "--pretty= --format= --abbrev-commit --no-abbrev-commit
			--oneline --show-signature
			--expand-tabs --expand-tabs= --no-expand-tabs
			$__git_diff_common_options
			";
            return
        ;;
    esac;
    __git_complete_revlist_file
}
_git_show_branch ()
{
    case "$cur" in
        --*)
            __gitcomp_builtin show-branch;
            return
        ;;
    esac;
    __git_complete_revlist
}
_git_sparse_checkout ()
{
    local subcommands="list init set disable add reapply";
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if [ -z "$subcommand" ]; then
        __gitcomp "$subcommands";
        return;
    fi;
    case "$subcommand,$cur" in
        *,--*)
            __gitcomp_builtin sparse-checkout_$subcommand "" "--"
        ;;
        set,* | add,*)
            if [ "$(__git config core.sparseCheckoutCone)" == "true" ] || [ -n "$(__git_find_on_cmdline --cone)" ]; then
                __gitcomp_directories;
            fi
        ;;
    esac
}
_git_stage ()
{
    _git_add
}
_git_stash ()
{
    local subcommands='push list show apply clear drop pop create branch';
    local subcommand="$(__git_find_on_cmdline "$subcommands save")";
    if [ -z "$subcommand" ]; then
        case "$((cword - __git_cmd_idx)),$cur" in
            *,--*)
                __gitcomp_builtin stash_push
            ;;
            1,sa*)
                __gitcomp "save"
            ;;
            1,*)
                __gitcomp "$subcommands"
            ;;
        esac;
        return;
    fi;
    case "$subcommand,$cur" in
        list,--*)
            __gitcomp_builtin stash_list "$__git_log_common_options $__git_diff_common_options"
        ;;
        show,--*)
            __gitcomp_builtin stash_show "$__git_diff_common_options"
        ;;
        *,--*)
            __gitcomp_builtin "stash_$subcommand"
        ;;
        branch,*)
            if [ $cword -eq $((__git_cmd_idx+2)) ]; then
                __git_complete_refs;
            else
                __gitcomp_nl "$(__git stash list 					| sed -n -e 's/:.*//p')";
            fi
        ;;
        show,* | apply,* | drop,* | pop,*)
            __gitcomp_nl "$(__git stash list 				| sed -n -e 's/:.*//p')"
        ;;
    esac
}
_git_status ()
{
    local complete_opt;
    local untracked_state;
    case "$cur" in
        --ignore-submodules=*)
            __gitcomp "none untracked dirty all" "" "${cur##--ignore-submodules=}";
            return
        ;;
        --untracked-files=*)
            __gitcomp "$__git_untracked_file_modes" "" "${cur##--untracked-files=}";
            return
        ;;
        --column=*)
            __gitcomp "
			always never auto column row plain dense nodense
			" "" "${cur##--column=}";
            return
        ;;
        --*)
            __gitcomp_builtin status;
            return
        ;;
    esac;
    untracked_state="$(__git_get_option_value "-u" "--untracked-files=" 		"$__git_untracked_file_modes" "status.showUntrackedFiles")";
    case "$untracked_state" in
        no)
            complete_opt=
        ;;
        all | normal | *)
            complete_opt="--cached --directory --no-empty-directory --others";
            if [ -n "$(__git_find_on_cmdline "--ignored")" ]; then
                complete_opt="$complete_opt --ignored --exclude=*";
            fi
        ;;
    esac;
    __git_complete_index_file "$complete_opt"
}
_git_submodule ()
{
    __git_has_doubledash && return;
    local subcommands="add status init deinit update set-branch set-url summary foreach sync absorbgitdirs";
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if [ -z "$subcommand" ]; then
        case "$cur" in
            --*)
                __gitcomp "--quiet"
            ;;
            *)
                __gitcomp "$subcommands"
            ;;
        esac;
        return;
    fi;
    case "$subcommand,$cur" in
        add,--*)
            __gitcomp "--branch --force --name --reference --depth"
        ;;
        status,--*)
            __gitcomp "--cached --recursive"
        ;;
        deinit,--*)
            __gitcomp "--force --all"
        ;;
        update,--*)
            __gitcomp "
			--init --remote --no-fetch
			--recommend-shallow --no-recommend-shallow
			--force --rebase --merge --reference --depth --recursive --jobs
		"
        ;;
        set-branch,--*)
            __gitcomp "--default --branch"
        ;;
        summary,--*)
            __gitcomp "--cached --files --summary-limit"
        ;;
        foreach,--* | sync,--*)
            __gitcomp "--recursive"
        ;;
        *)

        ;;
    esac
}
_git_svn ()
{
    local subcommands="
		init fetch clone rebase dcommit log find-rev
		set-tree commit-diff info create-ignore propget
		proplist show-ignore show-externals branch tag blame
		migrate mkdirs reset gc
		";
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if [ -z "$subcommand" ]; then
        __gitcomp "$subcommands";
    else
        local remote_opts="--username= --config-dir= --no-auth-cache";
        local fc_opts="
			--follow-parent --authors-file= --repack=
			--no-metadata --use-svm-props --use-svnsync-props
			--log-window-size= --no-checkout --quiet
			--repack-flags --use-log-author --localtime
			--add-author-from
			--recursive
			--ignore-paths= --include-paths= $remote_opts
			";
        local init_opts="
			--template= --shared= --trunk= --tags=
			--branches= --stdlayout --minimize-url
			--no-metadata --use-svm-props --use-svnsync-props
			--rewrite-root= --prefix= $remote_opts
			";
        local cmt_opts="
			--edit --rmdir --find-copies-harder --copy-similarity=
			";
        case "$subcommand,$cur" in
            fetch,--*)
                __gitcomp "--revision= --fetch-all $fc_opts"
            ;;
            clone,--*)
                __gitcomp "--revision= $fc_opts $init_opts"
            ;;
            init,--*)
                __gitcomp "$init_opts"
            ;;
            dcommit,--*)
                __gitcomp "
				--merge --strategy= --verbose --dry-run
				--fetch-all --no-rebase --commit-url
				--revision --interactive $cmt_opts $fc_opts
				"
            ;;
            set-tree,--*)
                __gitcomp "--stdin $cmt_opts $fc_opts"
            ;;
            create-ignore,--* | propget,--* | proplist,--* | show-ignore,--* | show-externals,--* | mkdirs,--*)
                __gitcomp "--revision="
            ;;
            log,--*)
                __gitcomp "
				--limit= --revision= --verbose --incremental
				--oneline --show-commit --non-recursive
				--authors-file= --color
				"
            ;;
            rebase,--*)
                __gitcomp "
				--merge --verbose --strategy= --local
				--fetch-all --dry-run $fc_opts
				"
            ;;
            commit-diff,--*)
                __gitcomp "--message= --file= --revision= $cmt_opts"
            ;;
            info,--*)
                __gitcomp "--url"
            ;;
            branch,--*)
                __gitcomp "--dry-run --message --tag"
            ;;
            tag,--*)
                __gitcomp "--dry-run --message"
            ;;
            blame,--*)
                __gitcomp "--git-format"
            ;;
            migrate,--*)
                __gitcomp "
				--config-dir= --ignore-paths= --minimize
				--no-auth-cache --username=
				"
            ;;
            reset,--*)
                __gitcomp "--revision= --parent"
            ;;
            *)

            ;;
        esac;
    fi
}
_git_switch ()
{
    local dwim_opt="$(__git_checkout_default_dwim_mode)";
    case "$prev" in
        -c | -C | --orphan)
            __git_complete_refs $dwim_opt --mode="heads";
            return
        ;;
        *)

        ;;
    esac;
    case "$cur" in
        --conflict=*)
            __gitcomp "diff3 merge zdiff3" "" "${cur##--conflict=}"
        ;;
        --*)
            __gitcomp_builtin switch
        ;;
        *)
            if [ -n "$(__git_find_on_cmdline "--orphan")" ]; then
                return;
            fi;
            if [ -n "$(__git_find_on_cmdline "-c -C -d --detach")" ]; then
                __git_complete_refs --mode="refs";
            else
                if [ -n "$(__git_find_on_cmdline "--track")" ]; then
                    __git_complete_refs --mode="remote-heads";
                else
                    __git_complete_refs $dwim_opt --mode="heads";
                fi;
            fi
        ;;
    esac
}
_git_tag ()
{
    local i c="$__git_cmd_idx" f=0;
    while [ $c -lt $cword ]; do
        i="${words[c]}";
        case "$i" in
            -d | --delete | -v | --verify)
                __gitcomp_direct "$(__git_tags "" "$cur" " ")";
                return
            ;;
            -f)
                f=1
            ;;
        esac;
        ((c++));
    done;
    case "$prev" in
        -m | -F)

        ;;
        -* | tag)
            if [ $f = 1 ]; then
                __gitcomp_direct "$(__git_tags "" "$cur" " ")";
            fi
        ;;
        *)
            __git_complete_refs
        ;;
    esac;
    case "$cur" in
        --*)
            __gitcomp_builtin tag
        ;;
    esac
}
_git_whatchanged ()
{
    _git_log
}
_git_worktree ()
{
    local subcommands="add list lock move prune remove unlock";
    local subcommand subcommand_idx;
    subcommand="$(__git_find_on_cmdline --show-idx "$subcommands")";
    subcommand_idx="${subcommand% *}";
    subcommand="${subcommand#* }";
    case "$subcommand,$cur" in
        ,*)
            __gitcomp "$subcommands"
        ;;
        *,--*)
            __gitcomp_builtin worktree_$subcommand
        ;;
        add,*)
            case "$prev" in
                -b | -B)
                    __git_complete_refs
                ;;
                -*)

                ;;
                *)
                    if [ $cword -eq $((subcommand_idx+1)) ]; then
                        :;
                    else
                        case "${words[cword-2]}" in
                            -b | -B)

                            ;;
                            *)
                                __git_complete_refs
                            ;;
                        esac;
                    fi
                ;;
            esac
        ;;
        lock,* | remove,* | unlock,*)
            __git_complete_worktree_paths
        ;;
        move,*)
            if [ $cword -eq $((subcommand_idx+1)) ]; then
                __git_complete_worktree_paths;
            else
                :;
            fi
        ;;
    esac
}
_gum_choose ()
{
    last_command="gum_choose";
    command_aliases=();
    commands=();
    flags=();
    two_word_flags=();
    local_nonpersistent_flags=();
    flags_with_completion=();
    flags_completion=();
    flags+=("--limit");
    flags+=("--no-limit");
    flags+=("--ordered");
    flags+=("--height");
    flags+=("--cursor=");
    two_word_flags+=("--cursor");
    flags+=("--header=");
    two_word_flags+=("--header");
    flags+=("--cursor-prefix=");
    two_word_flags+=("--cursor-prefix");
    flags+=("--selected-prefix=");
    two_word_flags+=("--selected-prefix");
    flags+=("--unselected-prefix=");
    two_word_flags+=("--unselected-prefix");
    flags+=("--selected");
    flags+=("--cursor.background=");
    two_word_flags+=("--cursor.background");
    flags+=("--cursor.foreground=");
    two_word_flags+=("--cursor.foreground");
    flags+=("--cursor.border=");
    two_word_flags+=("--cursor.border");
    flags+=("--cursor.border-background=");
    two_word_flags+=("--cursor.border-background");
    flags+=("--cursor.border-foreground=");
    two_word_flags+=("--cursor.border-foreground");
    flags+=("--cursor.align=");
    two_word_flags+=("--cursor.align");
    flags+=("--cursor.height");
    flags+=("--cursor.width");
    flags+=("--cursor.margin=");
    two_word_flags+=("--cursor.margin");
    flags+=("--cursor.padding=");
    two_word_flags+=("--cursor.padding");
    flags+=("--cursor.bold");
    flags+=("--cursor.faint");
    flags+=("--cursor.italic");
    flags+=("--cursor.strikethrough");
    flags+=("--cursor.underline");
    flags+=("--header.background=");
    two_word_flags+=("--header.background");
    flags+=("--header.foreground=");
    two_word_flags+=("--header.foreground");
    flags+=("--header.border=");
    two_word_flags+=("--header.border");
    flags+=("--header.border-background=");
    two_word_flags+=("--header.border-background");
    flags+=("--header.border-foreground=");
    two_word_flags+=("--header.border-foreground");
    flags+=("--header.align=");
    two_word_flags+=("--header.align");
    flags+=("--header.height");
    flags+=("--header.width");
    flags+=("--header.margin=");
    two_word_flags+=("--header.margin");
    flags+=("--header.padding=");
    two_word_flags+=("--header.padding");
    flags+=("--header.bold");
    flags+=("--header.faint");
    flags+=("--header.italic");
    flags+=("--header.strikethrough");
    flags+=("--header.underline");
    flags+=("--item.background=");
    two_word_flags+=("--item.background");
    flags+=("--item.foreground=");
    two_word_flags+=("--item.foreground");
    flags+=("--item.border=");
    two_word_flags+=("--item.border");
    flags+=("--item.border-background=");
    two_word_flags+=("--item.border-background");
    flags+=("--item.border-foreground=");
    two_word_flags+=("--item.border-foreground");
    flags+=("--item.align=");
    two_word_flags+=("--item.align");
    flags+=("--item.height");
    flags+=("--item.width");
    flags+=("--item.margin=");
    two_word_flags+=("--item.margin");
    flags+=("--item.padding=");
    two_word_flags+=("--item.padding");
    flags+=("--item.bold");
    flags+=("--item.faint");
    flags+=("--item.italic");
    flags+=("--item.strikethrough");
    flags+=("--item.underline");
    flags+=("--selected.background=");
    two_word_flags+=("--selected.background");
    flags+=("--selected.foreground=");
    two_word_flags+=("--selected.foreground");
    flags+=("--selected.border=");
    two_word_flags+=("--selected.border");
    flags+=("--selected.border-background=");
    two_word_flags+=("--selected.border-background");
    flags+=("--selected.border-foreground=");
    two_word_flags+=("--selected.border-foreground");
    flags+=("--selected.align=");
    two_word_flags+=("--selected.align");
    flags+=("--selected.height");
    flags+=("--selected.width");
    flags+=("--selected.margin=");
    two_word_flags+=("--selected.margin");
    flags+=("--selected.padding=");
    two_word_flags+=("--selected.padding");
    flags+=("--selected.bold");
    flags+=("--selected.faint");
    flags+=("--selected.italic");
    flags+=("--selected.strikethrough");
    flags+=("--selected.underline");
    noun_aliases=()
}
_gum_confirm ()
{
    last_command="gum_confirm";
    command_aliases=();
    commands=();
    flags=();
    two_word_flags=();
    local_nonpersistent_flags=();
    flags_with_completion=();
    flags_completion=();
    flags+=("--affirmative=");
    two_word_flags+=("--affirmative");
    flags+=("--negative=");
    two_word_flags+=("--negative");
    flags+=("--default");
    flags+=("--timeout");
    flags+=("--prompt.background=");
    two_word_flags+=("--prompt.background");
    flags+=("--prompt.foreground=");
    two_word_flags+=("--prompt.foreground");
    flags+=("--prompt.border=");
    two_word_flags+=("--prompt.border");
    flags+=("--prompt.border-background=");
    two_word_flags+=("--prompt.border-background");
    flags+=("--prompt.border-foreground=");
    two_word_flags+=("--prompt.border-foreground");
    flags+=("--prompt.align=");
    two_word_flags+=("--prompt.align");
    flags+=("--prompt.height");
    flags+=("--prompt.width");
    flags+=("--prompt.margin=");
    two_word_flags+=("--prompt.margin");
    flags+=("--prompt.padding=");
    two_word_flags+=("--prompt.padding");
    flags+=("--prompt.bold");
    flags+=("--prompt.faint");
    flags+=("--prompt.italic");
    flags+=("--prompt.strikethrough");
    flags+=("--prompt.underline");
    flags+=("--selected.background=");
    two_word_flags+=("--selected.background");
    flags+=("--selected.foreground=");
    two_word_flags+=("--selected.foreground");
    flags+=("--selected.border=");
    two_word_flags+=("--selected.border");
    flags+=("--selected.border-background=");
    two_word_flags+=("--selected.border-background");
    flags+=("--selected.border-foreground=");
    two_word_flags+=("--selected.border-foreground");
    flags+=("--selected.align=");
    two_word_flags+=("--selected.align");
    flags+=("--selected.height");
    flags+=("--selected.width");
    flags+=("--selected.margin=");
    two_word_flags+=("--selected.margin");
    flags+=("--selected.padding=");
    two_word_flags+=("--selected.padding");
    flags+=("--selected.bold");
    flags+=("--selected.faint");
    flags+=("--selected.italic");
    flags+=("--selected.strikethrough");
    flags+=("--selected.underline");
    flags+=("--unselected.background=");
    two_word_flags+=("--unselected.background");
    flags+=("--unselected.foreground=");
    two_word_flags+=("--unselected.foreground");
    flags+=("--unselected.border=");
    two_word_flags+=("--unselected.border");
    flags+=("--unselected.border-background=");
    two_word_flags+=("--unselected.border-background");
    flags+=("--unselected.border-foreground=");
    two_word_flags+=("--unselected.border-foreground");
    flags+=("--unselected.align=");
    two_word_flags+=("--unselected.align");
    flags+=("--unselected.height");
    flags+=("--unselected.width");
    flags+=("--unselected.margin=");
    two_word_flags+=("--unselected.margin");
    flags+=("--unselected.padding=");
    two_word_flags+=("--unselected.padding");
    flags+=("--unselected.bold");
    flags+=("--unselected.faint");
    flags+=("--unselected.italic");
    flags+=("--unselected.strikethrough");
    flags+=("--unselected.underline");
    noun_aliases=()
}
_gum_file ()
{
    last_command="gum_file";
    command_aliases=();
    commands=();
    flags=();
    two_word_flags=();
    local_nonpersistent_flags=();
    flags_with_completion=();
    flags_completion=();
    flags+=("--cursor=");
    two_word_flags+=("--cursor");
    two_word_flags+=("-c");
    flags+=("--all");
    flags+=("-a");
    flags+=("--file");
    flags+=("--directory");
    flags+=("--height");
    flags+=("--cursor.background=");
    two_word_flags+=("--cursor.background");
    flags+=("--cursor.foreground=");
    two_word_flags+=("--cursor.foreground");
    flags+=("--cursor.border=");
    two_word_flags+=("--cursor.border");
    flags+=("--cursor.border-background=");
    two_word_flags+=("--cursor.border-background");
    flags+=("--cursor.border-foreground=");
    two_word_flags+=("--cursor.border-foreground");
    flags+=("--cursor.align=");
    two_word_flags+=("--cursor.align");
    flags+=("--cursor.height");
    flags+=("--cursor.width");
    flags+=("--cursor.margin=");
    two_word_flags+=("--cursor.margin");
    flags+=("--cursor.padding=");
    two_word_flags+=("--cursor.padding");
    flags+=("--cursor.bold");
    flags+=("--cursor.faint");
    flags+=("--cursor.italic");
    flags+=("--cursor.strikethrough");
    flags+=("--cursor.underline");
    flags+=("--symlink.background=");
    two_word_flags+=("--symlink.background");
    flags+=("--symlink.foreground=");
    two_word_flags+=("--symlink.foreground");
    flags+=("--symlink.border=");
    two_word_flags+=("--symlink.border");
    flags+=("--symlink.border-background=");
    two_word_flags+=("--symlink.border-background");
    flags+=("--symlink.border-foreground=");
    two_word_flags+=("--symlink.border-foreground");
    flags+=("--symlink.align=");
    two_word_flags+=("--symlink.align");
    flags+=("--symlink.height");
    flags+=("--symlink.width");
    flags+=("--symlink.margin=");
    two_word_flags+=("--symlink.margin");
    flags+=("--symlink.padding=");
    two_word_flags+=("--symlink.padding");
    flags+=("--symlink.bold");
    flags+=("--symlink.faint");
    flags+=("--symlink.italic");
    flags+=("--symlink.strikethrough");
    flags+=("--symlink.underline");
    flags+=("--directory.background=");
    two_word_flags+=("--directory.background");
    flags+=("--directory.foreground=");
    two_word_flags+=("--directory.foreground");
    flags+=("--directory.border=");
    two_word_flags+=("--directory.border");
    flags+=("--directory.border-background=");
    two_word_flags+=("--directory.border-background");
    flags+=("--directory.border-foreground=");
    two_word_flags+=("--directory.border-foreground");
    flags+=("--directory.align=");
    two_word_flags+=("--directory.align");
    flags+=("--directory.height");
    flags+=("--directory.width");
    flags+=("--directory.margin=");
    two_word_flags+=("--directory.margin");
    flags+=("--directory.padding=");
    two_word_flags+=("--directory.padding");
    flags+=("--directory.bold");
    flags+=("--directory.faint");
    flags+=("--directory.italic");
    flags+=("--directory.strikethrough");
    flags+=("--directory.underline");
    flags+=("--file.background=");
    two_word_flags+=("--file.background");
    flags+=("--file.foreground=");
    two_word_flags+=("--file.foreground");
    flags+=("--file.border=");
    two_word_flags+=("--file.border");
    flags+=("--file.border-background=");
    two_word_flags+=("--file.border-background");
    flags+=("--file.border-foreground=");
    two_word_flags+=("--file.border-foreground");
    flags+=("--file.align=");
    two_word_flags+=("--file.align");
    flags+=("--file.height");
    flags+=("--file.width");
    flags+=("--file.margin=");
    two_word_flags+=("--file.margin");
    flags+=("--file.padding=");
    two_word_flags+=("--file.padding");
    flags+=("--file.bold");
    flags+=("--file.faint");
    flags+=("--file.italic");
    flags+=("--file.strikethrough");
    flags+=("--file.underline");
    flags+=("--permissions.background=");
    two_word_flags+=("--permissions.background");
    flags+=("--permissions.foreground=");
    two_word_flags+=("--permissions.foreground");
    flags+=("--permissions.border=");
    two_word_flags+=("--permissions.border");
    flags+=("--permissions.border-background=");
    two_word_flags+=("--permissions.border-background");
    flags+=("--permissions.border-foreground=");
    two_word_flags+=("--permissions.border-foreground");
    flags+=("--permissions.align=");
    two_word_flags+=("--permissions.align");
    flags+=("--permissions.height");
    flags+=("--permissions.width");
    flags+=("--permissions.margin=");
    two_word_flags+=("--permissions.margin");
    flags+=("--permissions.padding=");
    two_word_flags+=("--permissions.padding");
    flags+=("--permissions.bold");
    flags+=("--permissions.faint");
    flags+=("--permissions.italic");
    flags+=("--permissions.strikethrough");
    flags+=("--permissions.underline");
    flags+=("--selected.background=");
    two_word_flags+=("--selected.background");
    flags+=("--selected.foreground=");
    two_word_flags+=("--selected.foreground");
    flags+=("--selected.border=");
    two_word_flags+=("--selected.border");
    flags+=("--selected.border-background=");
    two_word_flags+=("--selected.border-background");
    flags+=("--selected.border-foreground=");
    two_word_flags+=("--selected.border-foreground");
    flags+=("--selected.align=");
    two_word_flags+=("--selected.align");
    flags+=("--selected.height");
    flags+=("--selected.width");
    flags+=("--selected.margin=");
    two_word_flags+=("--selected.margin");
    flags+=("--selected.padding=");
    two_word_flags+=("--selected.padding");
    flags+=("--selected.bold");
    flags+=("--selected.faint");
    flags+=("--selected.italic");
    flags+=("--selected.strikethrough");
    flags+=("--selected.underline");
    flags+=("--file-size.background=");
    two_word_flags+=("--file-size.background");
    flags+=("--file-size.foreground=");
    two_word_flags+=("--file-size.foreground");
    flags+=("--file-size.border=");
    two_word_flags+=("--file-size.border");
    flags+=("--file-size.border-background=");
    two_word_flags+=("--file-size.border-background");
    flags+=("--file-size.border-foreground=");
    two_word_flags+=("--file-size.border-foreground");
    flags+=("--file-size.align=");
    two_word_flags+=("--file-size.align");
    flags+=("--file-size.height");
    flags+=("--file-size.width");
    flags+=("--file-size.margin=");
    two_word_flags+=("--file-size.margin");
    flags+=("--file-size.padding=");
    two_word_flags+=("--file-size.padding");
    flags+=("--file-size.bold");
    flags+=("--file-size.faint");
    flags+=("--file-size.italic");
    flags+=("--file-size.strikethrough");
    flags+=("--file-size.underline");
    noun_aliases=()
}
_gum_filter ()
{
    last_command="gum_filter";
    command_aliases=();
    commands=();
    flags=();
    two_word_flags=();
    local_nonpersistent_flags=();
    flags_with_completion=();
    flags_completion=();
    flags+=("--indicator=");
    two_word_flags+=("--indicator");
    flags+=("--indicator.background=");
    two_word_flags+=("--indicator.background");
    flags+=("--indicator.foreground=");
    two_word_flags+=("--indicator.foreground");
    flags+=("--indicator.border=");
    two_word_flags+=("--indicator.border");
    flags+=("--indicator.border-background=");
    two_word_flags+=("--indicator.border-background");
    flags+=("--indicator.border-foreground=");
    two_word_flags+=("--indicator.border-foreground");
    flags+=("--indicator.align=");
    two_word_flags+=("--indicator.align");
    flags+=("--indicator.height");
    flags+=("--indicator.width");
    flags+=("--indicator.margin=");
    two_word_flags+=("--indicator.margin");
    flags+=("--indicator.padding=");
    two_word_flags+=("--indicator.padding");
    flags+=("--indicator.bold");
    flags+=("--indicator.faint");
    flags+=("--indicator.italic");
    flags+=("--indicator.strikethrough");
    flags+=("--indicator.underline");
    flags+=("--limit");
    flags+=("--no-limit");
    flags+=("--strict");
    flags+=("--selected-prefix=");
    two_word_flags+=("--selected-prefix");
    flags+=("--selected-indicator.background=");
    two_word_flags+=("--selected-indicator.background");
    flags+=("--selected-indicator.foreground=");
    two_word_flags+=("--selected-indicator.foreground");
    flags+=("--selected-indicator.border=");
    two_word_flags+=("--selected-indicator.border");
    flags+=("--selected-indicator.border-background=");
    two_word_flags+=("--selected-indicator.border-background");
    flags+=("--selected-indicator.border-foreground=");
    two_word_flags+=("--selected-indicator.border-foreground");
    flags+=("--selected-indicator.align=");
    two_word_flags+=("--selected-indicator.align");
    flags+=("--selected-indicator.height");
    flags+=("--selected-indicator.width");
    flags+=("--selected-indicator.margin=");
    two_word_flags+=("--selected-indicator.margin");
    flags+=("--selected-indicator.padding=");
    two_word_flags+=("--selected-indicator.padding");
    flags+=("--selected-indicator.bold");
    flags+=("--selected-indicator.faint");
    flags+=("--selected-indicator.italic");
    flags+=("--selected-indicator.strikethrough");
    flags+=("--selected-indicator.underline");
    flags+=("--unselected-prefix=");
    two_word_flags+=("--unselected-prefix");
    flags+=("--unselected-prefix.background=");
    two_word_flags+=("--unselected-prefix.background");
    flags+=("--unselected-prefix.foreground=");
    two_word_flags+=("--unselected-prefix.foreground");
    flags+=("--unselected-prefix.border=");
    two_word_flags+=("--unselected-prefix.border");
    flags+=("--unselected-prefix.border-background=");
    two_word_flags+=("--unselected-prefix.border-background");
    flags+=("--unselected-prefix.border-foreground=");
    two_word_flags+=("--unselected-prefix.border-foreground");
    flags+=("--unselected-prefix.align=");
    two_word_flags+=("--unselected-prefix.align");
    flags+=("--unselected-prefix.height");
    flags+=("--unselected-prefix.width");
    flags+=("--unselected-prefix.margin=");
    two_word_flags+=("--unselected-prefix.margin");
    flags+=("--unselected-prefix.padding=");
    two_word_flags+=("--unselected-prefix.padding");
    flags+=("--unselected-prefix.bold");
    flags+=("--unselected-prefix.faint");
    flags+=("--unselected-prefix.italic");
    flags+=("--unselected-prefix.strikethrough");
    flags+=("--unselected-prefix.underline");
    flags+=("--header.background=");
    two_word_flags+=("--header.background");
    flags+=("--header.foreground=");
    two_word_flags+=("--header.foreground");
    flags+=("--header.border=");
    two_word_flags+=("--header.border");
    flags+=("--header.border-background=");
    two_word_flags+=("--header.border-background");
    flags+=("--header.border-foreground=");
    two_word_flags+=("--header.border-foreground");
    flags+=("--header.align=");
    two_word_flags+=("--header.align");
    flags+=("--header.height");
    flags+=("--header.width");
    flags+=("--header.margin=");
    two_word_flags+=("--header.margin");
    flags+=("--header.padding=");
    two_word_flags+=("--header.padding");
    flags+=("--header.bold");
    flags+=("--header.faint");
    flags+=("--header.italic");
    flags+=("--header.strikethrough");
    flags+=("--header.underline");
    flags+=("--header=");
    two_word_flags+=("--header");
    flags+=("--text.background=");
    two_word_flags+=("--text.background");
    flags+=("--text.foreground=");
    two_word_flags+=("--text.foreground");
    flags+=("--text.border=");
    two_word_flags+=("--text.border");
    flags+=("--text.border-background=");
    two_word_flags+=("--text.border-background");
    flags+=("--text.border-foreground=");
    two_word_flags+=("--text.border-foreground");
    flags+=("--text.align=");
    two_word_flags+=("--text.align");
    flags+=("--text.height");
    flags+=("--text.width");
    flags+=("--text.margin=");
    two_word_flags+=("--text.margin");
    flags+=("--text.padding=");
    two_word_flags+=("--text.padding");
    flags+=("--text.bold");
    flags+=("--text.faint");
    flags+=("--text.italic");
    flags+=("--text.strikethrough");
    flags+=("--text.underline");
    flags+=("--match.background=");
    two_word_flags+=("--match.background");
    flags+=("--match.foreground=");
    two_word_flags+=("--match.foreground");
    flags+=("--match.border=");
    two_word_flags+=("--match.border");
    flags+=("--match.border-background=");
    two_word_flags+=("--match.border-background");
    flags+=("--match.border-foreground=");
    two_word_flags+=("--match.border-foreground");
    flags+=("--match.align=");
    two_word_flags+=("--match.align");
    flags+=("--match.height");
    flags+=("--match.width");
    flags+=("--match.margin=");
    two_word_flags+=("--match.margin");
    flags+=("--match.padding=");
    two_word_flags+=("--match.padding");
    flags+=("--match.bold");
    flags+=("--match.faint");
    flags+=("--match.italic");
    flags+=("--match.strikethrough");
    flags+=("--match.underline");
    flags+=("--placeholder=");
    two_word_flags+=("--placeholder");
    flags+=("--prompt=");
    two_word_flags+=("--prompt");
    flags+=("--prompt.background=");
    two_word_flags+=("--prompt.background");
    flags+=("--prompt.foreground=");
    two_word_flags+=("--prompt.foreground");
    flags+=("--prompt.border=");
    two_word_flags+=("--prompt.border");
    flags+=("--prompt.border-background=");
    two_word_flags+=("--prompt.border-background");
    flags+=("--prompt.border-foreground=");
    two_word_flags+=("--prompt.border-foreground");
    flags+=("--prompt.align=");
    two_word_flags+=("--prompt.align");
    flags+=("--prompt.height");
    flags+=("--prompt.width");
    flags+=("--prompt.margin=");
    two_word_flags+=("--prompt.margin");
    flags+=("--prompt.padding=");
    two_word_flags+=("--prompt.padding");
    flags+=("--prompt.bold");
    flags+=("--prompt.faint");
    flags+=("--prompt.italic");
    flags+=("--prompt.strikethrough");
    flags+=("--prompt.underline");
    flags+=("--width");
    flags+=("--height");
    flags+=("--value=");
    two_word_flags+=("--value");
    flags+=("--reverse");
    flags+=("--fuzzy");
    noun_aliases=()
}
_gum_format ()
{
    last_command="gum_format";
    command_aliases=();
    commands=();
    flags=();
    two_word_flags=();
    local_nonpersistent_flags=();
    flags_with_completion=();
    flags_completion=();
    flags+=("--theme=");
    two_word_flags+=("--theme");
    flags+=("--language=");
    two_word_flags+=("--language");
    two_word_flags+=("-l");
    flags+=("--type=");
    two_word_flags+=("--type");
    two_word_flags+=("-t");
    noun_aliases=()
}
_gum_input ()
{
    last_command="gum_input";
    command_aliases=();
    commands=();
    flags=();
    two_word_flags=();
    local_nonpersistent_flags=();
    flags_with_completion=();
    flags_completion=();
    flags+=("--placeholder=");
    two_word_flags+=("--placeholder");
    flags+=("--prompt=");
    two_word_flags+=("--prompt");
    flags+=("--prompt.background=");
    two_word_flags+=("--prompt.background");
    flags+=("--prompt.foreground=");
    two_word_flags+=("--prompt.foreground");
    flags+=("--prompt.border=");
    two_word_flags+=("--prompt.border");
    flags+=("--prompt.border-background=");
    two_word_flags+=("--prompt.border-background");
    flags+=("--prompt.border-foreground=");
    two_word_flags+=("--prompt.border-foreground");
    flags+=("--prompt.align=");
    two_word_flags+=("--prompt.align");
    flags+=("--prompt.height");
    flags+=("--prompt.width");
    flags+=("--prompt.margin=");
    two_word_flags+=("--prompt.margin");
    flags+=("--prompt.padding=");
    two_word_flags+=("--prompt.padding");
    flags+=("--prompt.bold");
    flags+=("--prompt.faint");
    flags+=("--prompt.italic");
    flags+=("--prompt.strikethrough");
    flags+=("--prompt.underline");
    flags+=("--cursor.background=");
    two_word_flags+=("--cursor.background");
    flags+=("--cursor.foreground=");
    two_word_flags+=("--cursor.foreground");
    flags+=("--cursor.border=");
    two_word_flags+=("--cursor.border");
    flags+=("--cursor.border-background=");
    two_word_flags+=("--cursor.border-background");
    flags+=("--cursor.border-foreground=");
    two_word_flags+=("--cursor.border-foreground");
    flags+=("--cursor.align=");
    two_word_flags+=("--cursor.align");
    flags+=("--cursor.height");
    flags+=("--cursor.width");
    flags+=("--cursor.margin=");
    two_word_flags+=("--cursor.margin");
    flags+=("--cursor.padding=");
    two_word_flags+=("--cursor.padding");
    flags+=("--cursor.bold");
    flags+=("--cursor.faint");
    flags+=("--cursor.italic");
    flags+=("--cursor.strikethrough");
    flags+=("--cursor.underline");
    flags+=("--value=");
    two_word_flags+=("--value");
    flags+=("--char-limit");
    flags+=("--width");
    flags+=("--password");
    flags+=("--header=");
    two_word_flags+=("--header");
    flags+=("--header.background=");
    two_word_flags+=("--header.background");
    flags+=("--header.foreground=");
    two_word_flags+=("--header.foreground");
    flags+=("--header.border=");
    two_word_flags+=("--header.border");
    flags+=("--header.border-background=");
    two_word_flags+=("--header.border-background");
    flags+=("--header.border-foreground=");
    two_word_flags+=("--header.border-foreground");
    flags+=("--header.align=");
    two_word_flags+=("--header.align");
    flags+=("--header.height");
    flags+=("--header.width");
    flags+=("--header.margin=");
    two_word_flags+=("--header.margin");
    flags+=("--header.padding=");
    two_word_flags+=("--header.padding");
    flags+=("--header.bold");
    flags+=("--header.faint");
    flags+=("--header.italic");
    flags+=("--header.strikethrough");
    flags+=("--header.underline");
    noun_aliases=()
}
_gum_join ()
{
    last_command="gum_join";
    command_aliases=();
    commands=();
    flags=();
    two_word_flags=();
    local_nonpersistent_flags=();
    flags_with_completion=();
    flags_completion=();
    flags+=("--align=");
    two_word_flags+=("--align");
    flags+=("--horizontal");
    flags+=("--vertical");
    noun_aliases=()
}
_gum_pager ()
{
    last_command="gum_pager";
    command_aliases=();
    commands=();
    flags=();
    two_word_flags=();
    local_nonpersistent_flags=();
    flags_with_completion=();
    flags_completion=();
    flags+=("--background=");
    two_word_flags+=("--background");
    flags+=("--foreground=");
    two_word_flags+=("--foreground");
    flags+=("--border=");
    two_word_flags+=("--border");
    flags+=("--border-background=");
    two_word_flags+=("--border-background");
    flags+=("--border-foreground=");
    two_word_flags+=("--border-foreground");
    flags+=("--align=");
    two_word_flags+=("--align");
    flags+=("--height");
    flags+=("--width");
    flags+=("--margin=");
    two_word_flags+=("--margin");
    flags+=("--padding=");
    two_word_flags+=("--padding");
    flags+=("--bold");
    flags+=("--faint");
    flags+=("--italic");
    flags+=("--strikethrough");
    flags+=("--underline");
    flags+=("--help.background=");
    two_word_flags+=("--help.background");
    flags+=("--help.foreground=");
    two_word_flags+=("--help.foreground");
    flags+=("--help.border=");
    two_word_flags+=("--help.border");
    flags+=("--help.border-background=");
    two_word_flags+=("--help.border-background");
    flags+=("--help.border-foreground=");
    two_word_flags+=("--help.border-foreground");
    flags+=("--help.align=");
    two_word_flags+=("--help.align");
    flags+=("--help.height");
    flags+=("--help.width");
    flags+=("--help.margin=");
    two_word_flags+=("--help.margin");
    flags+=("--help.padding=");
    two_word_flags+=("--help.padding");
    flags+=("--help.bold");
    flags+=("--help.faint");
    flags+=("--help.italic");
    flags+=("--help.strikethrough");
    flags+=("--help.underline");
    flags+=("--show-line-numbers");
    flags+=("--line-number.background=");
    two_word_flags+=("--line-number.background");
    flags+=("--line-number.foreground=");
    two_word_flags+=("--line-number.foreground");
    flags+=("--line-number.border=");
    two_word_flags+=("--line-number.border");
    flags+=("--line-number.border-background=");
    two_word_flags+=("--line-number.border-background");
    flags+=("--line-number.border-foreground=");
    two_word_flags+=("--line-number.border-foreground");
    flags+=("--line-number.align=");
    two_word_flags+=("--line-number.align");
    flags+=("--line-number.height");
    flags+=("--line-number.width");
    flags+=("--line-number.margin=");
    two_word_flags+=("--line-number.margin");
    flags+=("--line-number.padding=");
    two_word_flags+=("--line-number.padding");
    flags+=("--line-number.bold");
    flags+=("--line-number.faint");
    flags+=("--line-number.italic");
    flags+=("--line-number.strikethrough");
    flags+=("--line-number.underline");
    flags+=("--soft-wrap");
    noun_aliases=()
}
_gum_root_command ()
{
    last_command="gum";
    command_aliases=();
    commands=();
    commands+=("choose");
    commands+=("confirm");
    commands+=("file");
    commands+=("filter");
    commands+=("format");
    commands+=("input");
    commands+=("join");
    commands+=("pager");
    commands+=("spin");
    commands+=("style");
    commands+=("table");
    commands+=("write");
    flags=();
    two_word_flags=();
    local_nonpersistent_flags=();
    flags_with_completion=();
    flags_completion=();
    flags+=("--help");
    flags+=("-h");
    flags+=("--version");
    flags+=("-v");
    noun_aliases=()
}
_gum_spin ()
{
    last_command="gum_spin";
    command_aliases=();
    commands=();
    flags=();
    two_word_flags=();
    local_nonpersistent_flags=();
    flags_with_completion=();
    flags_completion=();
    flags+=("--show-output");
    flags+=("--spinner=");
    two_word_flags+=("--spinner");
    two_word_flags+=("-s");
    flags+=("--spinner.background=");
    two_word_flags+=("--spinner.background");
    flags+=("--spinner.foreground=");
    two_word_flags+=("--spinner.foreground");
    flags+=("--spinner.border=");
    two_word_flags+=("--spinner.border");
    flags+=("--spinner.border-background=");
    two_word_flags+=("--spinner.border-background");
    flags+=("--spinner.border-foreground=");
    two_word_flags+=("--spinner.border-foreground");
    flags+=("--spinner.align=");
    two_word_flags+=("--spinner.align");
    flags+=("--spinner.height");
    flags+=("--spinner.width");
    flags+=("--spinner.margin=");
    two_word_flags+=("--spinner.margin");
    flags+=("--spinner.padding=");
    two_word_flags+=("--spinner.padding");
    flags+=("--spinner.bold");
    flags+=("--spinner.faint");
    flags+=("--spinner.italic");
    flags+=("--spinner.strikethrough");
    flags+=("--spinner.underline");
    flags+=("--title=");
    two_word_flags+=("--title");
    flags+=("--title.background=");
    two_word_flags+=("--title.background");
    flags+=("--title.foreground=");
    two_word_flags+=("--title.foreground");
    flags+=("--title.border=");
    two_word_flags+=("--title.border");
    flags+=("--title.border-background=");
    two_word_flags+=("--title.border-background");
    flags+=("--title.border-foreground=");
    two_word_flags+=("--title.border-foreground");
    flags+=("--title.align=");
    two_word_flags+=("--title.align");
    flags+=("--title.height");
    flags+=("--title.width");
    flags+=("--title.margin=");
    two_word_flags+=("--title.margin");
    flags+=("--title.padding=");
    two_word_flags+=("--title.padding");
    flags+=("--title.bold");
    flags+=("--title.faint");
    flags+=("--title.italic");
    flags+=("--title.strikethrough");
    flags+=("--title.underline");
    flags+=("--align=");
    two_word_flags+=("--align");
    two_word_flags+=("-a");
    noun_aliases=()
}
_gum_style ()
{
    last_command="gum_style";
    command_aliases=();
    commands=();
    flags=();
    two_word_flags=();
    local_nonpersistent_flags=();
    flags_with_completion=();
    flags_completion=();
    flags+=("--background=");
    two_word_flags+=("--background");
    flags+=("--foreground=");
    two_word_flags+=("--foreground");
    flags+=("--border=");
    two_word_flags+=("--border");
    flags+=("--border-background=");
    two_word_flags+=("--border-background");
    flags+=("--border-foreground=");
    two_word_flags+=("--border-foreground");
    flags+=("--align=");
    two_word_flags+=("--align");
    flags+=("--height");
    flags+=("--width");
    flags+=("--margin=");
    two_word_flags+=("--margin");
    flags+=("--padding=");
    two_word_flags+=("--padding");
    flags+=("--bold");
    flags+=("--faint");
    flags+=("--italic");
    flags+=("--strikethrough");
    flags+=("--underline");
    noun_aliases=()
}
_gum_table ()
{
    last_command="gum_table";
    command_aliases=();
    commands=();
    flags=();
    two_word_flags=();
    local_nonpersistent_flags=();
    flags_with_completion=();
    flags_completion=();
    flags+=("--separator=");
    two_word_flags+=("--separator");
    two_word_flags+=("-s");
    flags+=("--columns");
    flags+=("-c");
    flags+=("--widths");
    flags+=("-w");
    flags+=("--height");
    flags+=("--cell.background=");
    two_word_flags+=("--cell.background");
    flags+=("--cell.foreground=");
    two_word_flags+=("--cell.foreground");
    flags+=("--cell.border=");
    two_word_flags+=("--cell.border");
    flags+=("--cell.border-background=");
    two_word_flags+=("--cell.border-background");
    flags+=("--cell.border-foreground=");
    two_word_flags+=("--cell.border-foreground");
    flags+=("--cell.align=");
    two_word_flags+=("--cell.align");
    flags+=("--cell.height");
    flags+=("--cell.width");
    flags+=("--cell.margin=");
    two_word_flags+=("--cell.margin");
    flags+=("--cell.padding=");
    two_word_flags+=("--cell.padding");
    flags+=("--cell.bold");
    flags+=("--cell.faint");
    flags+=("--cell.italic");
    flags+=("--cell.strikethrough");
    flags+=("--cell.underline");
    flags+=("--header.background=");
    two_word_flags+=("--header.background");
    flags+=("--header.foreground=");
    two_word_flags+=("--header.foreground");
    flags+=("--header.border=");
    two_word_flags+=("--header.border");
    flags+=("--header.border-background=");
    two_word_flags+=("--header.border-background");
    flags+=("--header.border-foreground=");
    two_word_flags+=("--header.border-foreground");
    flags+=("--header.align=");
    two_word_flags+=("--header.align");
    flags+=("--header.height");
    flags+=("--header.width");
    flags+=("--header.margin=");
    two_word_flags+=("--header.margin");
    flags+=("--header.padding=");
    two_word_flags+=("--header.padding");
    flags+=("--header.bold");
    flags+=("--header.faint");
    flags+=("--header.italic");
    flags+=("--header.strikethrough");
    flags+=("--header.underline");
    flags+=("--selected.background=");
    two_word_flags+=("--selected.background");
    flags+=("--selected.foreground=");
    two_word_flags+=("--selected.foreground");
    flags+=("--selected.border=");
    two_word_flags+=("--selected.border");
    flags+=("--selected.border-background=");
    two_word_flags+=("--selected.border-background");
    flags+=("--selected.border-foreground=");
    two_word_flags+=("--selected.border-foreground");
    flags+=("--selected.align=");
    two_word_flags+=("--selected.align");
    flags+=("--selected.height");
    flags+=("--selected.width");
    flags+=("--selected.margin=");
    two_word_flags+=("--selected.margin");
    flags+=("--selected.padding=");
    two_word_flags+=("--selected.padding");
    flags+=("--selected.bold");
    flags+=("--selected.faint");
    flags+=("--selected.italic");
    flags+=("--selected.strikethrough");
    flags+=("--selected.underline");
    flags+=("--file=");
    two_word_flags+=("--file");
    two_word_flags+=("-f");
    noun_aliases=()
}
_gum_write ()
{
    last_command="gum_write";
    command_aliases=();
    commands=();
    flags=();
    two_word_flags=();
    local_nonpersistent_flags=();
    flags_with_completion=();
    flags_completion=();
    flags+=("--width");
    flags+=("--height");
    flags+=("--header=");
    two_word_flags+=("--header");
    flags+=("--placeholder=");
    two_word_flags+=("--placeholder");
    flags+=("--prompt=");
    two_word_flags+=("--prompt");
    flags+=("--show-cursor-line");
    flags+=("--show-line-numbers");
    flags+=("--value=");
    two_word_flags+=("--value");
    flags+=("--char-limit");
    flags+=("--base.background=");
    two_word_flags+=("--base.background");
    flags+=("--base.foreground=");
    two_word_flags+=("--base.foreground");
    flags+=("--base.border=");
    two_word_flags+=("--base.border");
    flags+=("--base.border-background=");
    two_word_flags+=("--base.border-background");
    flags+=("--base.border-foreground=");
    two_word_flags+=("--base.border-foreground");
    flags+=("--base.align=");
    two_word_flags+=("--base.align");
    flags+=("--base.height");
    flags+=("--base.width");
    flags+=("--base.margin=");
    two_word_flags+=("--base.margin");
    flags+=("--base.padding=");
    two_word_flags+=("--base.padding");
    flags+=("--base.bold");
    flags+=("--base.faint");
    flags+=("--base.italic");
    flags+=("--base.strikethrough");
    flags+=("--base.underline");
    flags+=("--cursor-line-number.background=");
    two_word_flags+=("--cursor-line-number.background");
    flags+=("--cursor-line-number.foreground=");
    two_word_flags+=("--cursor-line-number.foreground");
    flags+=("--cursor-line-number.border=");
    two_word_flags+=("--cursor-line-number.border");
    flags+=("--cursor-line-number.border-background=");
    two_word_flags+=("--cursor-line-number.border-background");
    flags+=("--cursor-line-number.border-foreground=");
    two_word_flags+=("--cursor-line-number.border-foreground");
    flags+=("--cursor-line-number.align=");
    two_word_flags+=("--cursor-line-number.align");
    flags+=("--cursor-line-number.height");
    flags+=("--cursor-line-number.width");
    flags+=("--cursor-line-number.margin=");
    two_word_flags+=("--cursor-line-number.margin");
    flags+=("--cursor-line-number.padding=");
    two_word_flags+=("--cursor-line-number.padding");
    flags+=("--cursor-line-number.bold");
    flags+=("--cursor-line-number.faint");
    flags+=("--cursor-line-number.italic");
    flags+=("--cursor-line-number.strikethrough");
    flags+=("--cursor-line-number.underline");
    flags+=("--cursor-line.background=");
    two_word_flags+=("--cursor-line.background");
    flags+=("--cursor-line.foreground=");
    two_word_flags+=("--cursor-line.foreground");
    flags+=("--cursor-line.border=");
    two_word_flags+=("--cursor-line.border");
    flags+=("--cursor-line.border-background=");
    two_word_flags+=("--cursor-line.border-background");
    flags+=("--cursor-line.border-foreground=");
    two_word_flags+=("--cursor-line.border-foreground");
    flags+=("--cursor-line.align=");
    two_word_flags+=("--cursor-line.align");
    flags+=("--cursor-line.height");
    flags+=("--cursor-line.width");
    flags+=("--cursor-line.margin=");
    two_word_flags+=("--cursor-line.margin");
    flags+=("--cursor-line.padding=");
    two_word_flags+=("--cursor-line.padding");
    flags+=("--cursor-line.bold");
    flags+=("--cursor-line.faint");
    flags+=("--cursor-line.italic");
    flags+=("--cursor-line.strikethrough");
    flags+=("--cursor-line.underline");
    flags+=("--cursor.background=");
    two_word_flags+=("--cursor.background");
    flags+=("--cursor.foreground=");
    two_word_flags+=("--cursor.foreground");
    flags+=("--cursor.border=");
    two_word_flags+=("--cursor.border");
    flags+=("--cursor.border-background=");
    two_word_flags+=("--cursor.border-background");
    flags+=("--cursor.border-foreground=");
    two_word_flags+=("--cursor.border-foreground");
    flags+=("--cursor.align=");
    two_word_flags+=("--cursor.align");
    flags+=("--cursor.height");
    flags+=("--cursor.width");
    flags+=("--cursor.margin=");
    two_word_flags+=("--cursor.margin");
    flags+=("--cursor.padding=");
    two_word_flags+=("--cursor.padding");
    flags+=("--cursor.bold");
    flags+=("--cursor.faint");
    flags+=("--cursor.italic");
    flags+=("--cursor.strikethrough");
    flags+=("--cursor.underline");
    flags+=("--end-of-buffer.background=");
    two_word_flags+=("--end-of-buffer.background");
    flags+=("--end-of-buffer.foreground=");
    two_word_flags+=("--end-of-buffer.foreground");
    flags+=("--end-of-buffer.border=");
    two_word_flags+=("--end-of-buffer.border");
    flags+=("--end-of-buffer.border-background=");
    two_word_flags+=("--end-of-buffer.border-background");
    flags+=("--end-of-buffer.border-foreground=");
    two_word_flags+=("--end-of-buffer.border-foreground");
    flags+=("--end-of-buffer.align=");
    two_word_flags+=("--end-of-buffer.align");
    flags+=("--end-of-buffer.height");
    flags+=("--end-of-buffer.width");
    flags+=("--end-of-buffer.margin=");
    two_word_flags+=("--end-of-buffer.margin");
    flags+=("--end-of-buffer.padding=");
    two_word_flags+=("--end-of-buffer.padding");
    flags+=("--end-of-buffer.bold");
    flags+=("--end-of-buffer.faint");
    flags+=("--end-of-buffer.italic");
    flags+=("--end-of-buffer.strikethrough");
    flags+=("--end-of-buffer.underline");
    flags+=("--line-number.background=");
    two_word_flags+=("--line-number.background");
    flags+=("--line-number.foreground=");
    two_word_flags+=("--line-number.foreground");
    flags+=("--line-number.border=");
    two_word_flags+=("--line-number.border");
    flags+=("--line-number.border-background=");
    two_word_flags+=("--line-number.border-background");
    flags+=("--line-number.border-foreground=");
    two_word_flags+=("--line-number.border-foreground");
    flags+=("--line-number.align=");
    two_word_flags+=("--line-number.align");
    flags+=("--line-number.height");
    flags+=("--line-number.width");
    flags+=("--line-number.margin=");
    two_word_flags+=("--line-number.margin");
    flags+=("--line-number.padding=");
    two_word_flags+=("--line-number.padding");
    flags+=("--line-number.bold");
    flags+=("--line-number.faint");
    flags+=("--line-number.italic");
    flags+=("--line-number.strikethrough");
    flags+=("--line-number.underline");
    flags+=("--header.background=");
    two_word_flags+=("--header.background");
    flags+=("--header.foreground=");
    two_word_flags+=("--header.foreground");
    flags+=("--header.border=");
    two_word_flags+=("--header.border");
    flags+=("--header.border-background=");
    two_word_flags+=("--header.border-background");
    flags+=("--header.border-foreground=");
    two_word_flags+=("--header.border-foreground");
    flags+=("--header.align=");
    two_word_flags+=("--header.align");
    flags+=("--header.height");
    flags+=("--header.width");
    flags+=("--header.margin=");
    two_word_flags+=("--header.margin");
    flags+=("--header.padding=");
    two_word_flags+=("--header.padding");
    flags+=("--header.bold");
    flags+=("--header.faint");
    flags+=("--header.italic");
    flags+=("--header.strikethrough");
    flags+=("--header.underline");
    flags+=("--placeholder.background=");
    two_word_flags+=("--placeholder.background");
    flags+=("--placeholder.foreground=");
    two_word_flags+=("--placeholder.foreground");
    flags+=("--placeholder.border=");
    two_word_flags+=("--placeholder.border");
    flags+=("--placeholder.border-background=");
    two_word_flags+=("--placeholder.border-background");
    flags+=("--placeholder.border-foreground=");
    two_word_flags+=("--placeholder.border-foreground");
    flags+=("--placeholder.align=");
    two_word_flags+=("--placeholder.align");
    flags+=("--placeholder.height");
    flags+=("--placeholder.width");
    flags+=("--placeholder.margin=");
    two_word_flags+=("--placeholder.margin");
    flags+=("--placeholder.padding=");
    two_word_flags+=("--placeholder.padding");
    flags+=("--placeholder.bold");
    flags+=("--placeholder.faint");
    flags+=("--placeholder.italic");
    flags+=("--placeholder.strikethrough");
    flags+=("--placeholder.underline");
    flags+=("--prompt.background=");
    two_word_flags+=("--prompt.background");
    flags+=("--prompt.foreground=");
    two_word_flags+=("--prompt.foreground");
    flags+=("--prompt.border=");
    two_word_flags+=("--prompt.border");
    flags+=("--prompt.border-background=");
    two_word_flags+=("--prompt.border-background");
    flags+=("--prompt.border-foreground=");
    two_word_flags+=("--prompt.border-foreground");
    flags+=("--prompt.align=");
    two_word_flags+=("--prompt.align");
    flags+=("--prompt.height");
    flags+=("--prompt.width");
    flags+=("--prompt.margin=");
    two_word_flags+=("--prompt.margin");
    flags+=("--prompt.padding=");
    two_word_flags+=("--prompt.padding");
    flags+=("--prompt.bold");
    flags+=("--prompt.faint");
    flags+=("--prompt.italic");
    flags+=("--prompt.strikethrough");
    flags+=("--prompt.underline");
    noun_aliases=()
}
_gzip ()
{
    local cur prev xspec helpopts;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    helpopts=`_parse_help ${COMP_WORDS[0]}`;
    case $prev in
        -b | --blocksize | -p | --processes | -S | --suffix | -h | --help | -V | --version)
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W "$helpopts -1 -2 -3 -4 -5 -6 -7 -8 -9"             -- "$cur" ));
        return 0;
    fi;
    local IFS='
';
    xspec="*.@(gz|t[ag]z)";
    if [[ "$prev" == --* ]]; then
        [[ "$prev" == --decompress || "$prev" == --list || "$prev" == --test ]] && xspec="!"$xspec;
        [[ "$prev" == --force ]] && xspec=;
    else
        if [[ "$prev" == -* ]]; then
            [[ "$prev" == -*[dlt]* ]] && xspec="!"$xspec;
            [[ "$prev" == -*f* ]] && xspec=;
        else
            if [[ "$prev" == '>' || "$prev" == '>>' ]]; then
                xspec=;
            else
                if [ "$prev" = '<' ]; then
                    xspec=;
                fi;
            fi;
        fi;
    fi;
    _expand || return 0;
    _compopt_o_filenames;
    COMPREPLY=($( compgen -f -X "$xspec" -- "$cur" ) $( compgen -d -- "$cur" ))
}
_heimdal_encodings ()
{
    COMPREPLY=($( compgen -W 'des-cbc-mcrc des-cbc-md4 des-cbc-md5 \
        des3-cbc-sha1 arcfour-hmac-md5 aes128-cts-hmac-sha1-96 \
        aes256-cts-hmac-sha1-96' -- "$cur" ))
}
_heimdal_principals ()
{
    COMPREPLY=($( compgen -W "$( kadmin -l dump 2>/dev/null |         awk '{print $1}' )" -- "$cur" ))
}
_heimdal_realms ()
{
    COMPREPLY=($( compgen -W "( kadmin -l dump 2>/dev/null |         awk '{print $1}' | awk -F@ '{print $2}' )" -- "$cur" ))
}
_iconv ()
{
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in
        -'?' | --help | --usage | -V | --version | --unicode-subst | --byte-subst | --widechar-subst)
            return 0
        ;;
        -f | --from-code | -t | --to-code)
            COMPREPLY=($( compgen -W '$( iconv -l | \
                sed -e "s@/*\$@@" -e "s/[,()]//g" )' -- "$cur" ));
            return 0
        ;;
        -o | --output)
            _filedir;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" = -* ]]; then
        COMPREPLY=($( compgen -W '--from-code --to-code --list -c
            --unicode-subst --byte-subst --widechar-subst --output --silent
            --verbose --help --usage --version' -- "$cur" ));
        return 0;
    fi
}
_id ()
{
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-a -g --group -G --groups -n --name\
            -r --real -u --user --help --version' -- "$cur" ));
    else
        COMPREPLY=($( compgen -u "$cur" ));
    fi
}
_installed_modules ()
{
    COMPREPLY=($( compgen -W "$( PATH="$PATH:/sbin" lsmod |         awk '{if (NR != 1) print $1}' )" -- "$1" ))
}
_jar ()
{
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [ $COMP_CWORD = 1 ]; then
        COMPREPLY=($( compgen -W 'c t x u' -- "$cur" ));
        return 0;
    fi;
    case ${COMP_WORDS[1]} in
        *c*f)
            _filedir
        ;;
        *f)
            _filedir '@([ejw]ar|zip|apk)'
        ;;
        *)
            _filedir
        ;;
    esac
}
_jarsigner ()
{
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    case $prev in
        -keystore)
            COMPREPLY=($( compgen -W 'NONE' -- "$cur" ));
            _filedir '@(jks|ks|p12|pfx)';
            return 0
        ;;
        -storepass | -keypass | -sigfile | -digestalg | -sigalg | -tsacert | -altsigner | -altsignerpath | -providerName | -providerClass | -providerArg)
            return 0
        ;;
        -storetype)
            COMPREPLY=($( compgen -W 'JKS PKCS11 PKCS12' -- "$cur" ));
            return 0
        ;;
        -signedjar)
            _filedir jar;
            return 0
        ;;
        -tsa)
            _filedir;
            return 0
        ;;
    esac;
    local i jar=false;
    for ((i=0; i < ${#COMP_WORDS[@]}-1; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" == *.jar && "${COMP_WORDS[i-1]}" != -signedjar ]]; then
            jar=true;
            break;
        fi;
    done;
    if ! $jar; then
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '-keystore -storepass -storetype \
                -keypass -sigfile -signedjar -digestalg -sigalg -verify \
                -verbose -certs -tsa -tsacert -altsigner -altsignerpath \
                -protected -providerName -providerClass -providerArg'                 -- "$cur" ));
        fi;
        _filedir jar;
    fi
}
_java ()
{
    local cur prev words cword i;
    COMPREPLY=();
    _get_comp_words_by_ref -n : cur prev words cword;
    for ((i=1; i < $cword; i++))
    do
        case ${words[$i]} in
            -cp | -classpath)
                ((i++))
            ;;
            -*)

            ;;
            *)
                _filedir;
                return 0
            ;;
        esac;
    done;
    case $cur in
        -verbose:*)
            COMPREPLY=($( compgen -W 'class gc jni' -- "${cur#*:}" ));
            return 0
        ;;
        -javaagent:*)
            cur=${cur#*:};
            _filedir '@(jar|zip)';
            return 0
        ;;
        -agentpath:*)
            cur=${cur#*:};
            _filedir so;
            return 0
        ;;
        -splash:*)
            cur=${cur#*:};
            _filedir '@(gif|jp?(e)g|png)';
            return 0
        ;;
        -Xbootclasspath*:*)
            _java_path;
            return 0
        ;;
        -Xcheck:*)
            COMPREPLY=($( compgen -W 'jni' -- "${cur#*:}" ));
            return 0
        ;;
        -Xgc:*)
            COMPREPLY=($( compgen -W 'singlecon gencon singlepar genpar'                 -- "${cur#*:}" ));
            return 0
        ;;
        -Xgcprio:*)
            COMPREPLY=($( compgen -W 'throughput pausetime deterministic'                 -- "${cur#*:}" ));
            return 0
        ;;
        -Xloggc:* | -Xverboselog:*)
            cur=${cur#*:};
            _filedir;
            return 0
        ;;
        -Xshare:*)
            COMPREPLY=($( compgen -W 'auto off on' -- "${cur#*:}" ));
            return 0
        ;;
        -Xverbose:*)
            COMPREPLY=($( compgen -W 'memory load jni cpuinfo codegen opt
                gcpause gcreport' -- "${cur#*:}" ));
            return 0
        ;;
        -Xverify:*)
            COMPREPLY=($( compgen -W 'all none remote' -- "${cur#*:}" ));
            return 0
        ;;
        -D* | -*:*)
            return 0
        ;;
    esac;
    case $prev in
        -cp | -classpath)
            _java_path;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-client -server -agentlib: -agentpath:
            -classpath -D -d32 -d64 -enableassertions -disableassertions
            -enablesystemassertions -disablesystemassertions -jar -javaagent:
            -verbose -verbose -version -showversion -help -X' -- "$cur" ));
    else
        if [[ "$prev" == -jar ]]; then
            _filedir jar;
        else
            _java_classes;
        fi;
    fi;
    [[ ${#COMPREPLY[@]} -eq 1 && ${COMPREPLY[0]} == -*[:=] ]] && type compopt >&/dev/null && compopt -o nospace;
    __ltrim_colon_completions "$cur"
}
_java_classes ()
{
    local classpath i;
    _java_find_classpath;
    cur=${cur//.//};
    for i in ${classpath//:/ };
    do
        if [[ "$i" == *.@(jar|zip) && -r $i ]]; then
            if type zipinfo >&/dev/null; then
                COMPREPLY=("${COMPREPLY[@]}" $( zipinfo -1                     "$i" "$cur*" 2>/dev/null |                     command grep '^[^$]*\.class$' ));
            else
                COMPREPLY=("${COMPREPLY[@]}" $( jar tf "$i"                     "$cur" | command grep '^[^$]*\.class$' ));
            fi;
        else
            if [ -d $i ]; then
                COMPREPLY=("${COMPREPLY[@]}" $( command ls $i/$cur*.class 2>/dev/null |                     sed -ne '/\$/d' -e "s|^$i//*||p" ));
            fi;
        fi;
    done;
    COMPREPLY=(${COMPREPLY[@]%.class});
    COMPREPLY=(${COMPREPLY[@]//\//.})
}
_java_find_classpath ()
{
    local i;
    for ((i=1; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" == -@(cp|classpath) ]]; then
            classpath=${COMP_WORDS[i+1]};
            break;
        fi;
    done;
    [ -z "$classpath" ] && classpath=$CLASSPATH;
    [ -z "$classpath" ] && classpath=.
}
_java_find_sourcepath ()
{
    local i;
    for ((i=1; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" == -sourcepath ]]; then
            sourcepath=${COMP_WORDS[i+1]};
            break;
        fi;
    done;
    if [ -z "$sourcepath" ]; then
        _java_find_classpath;
        sourcepath=$classpath;
    fi
}
_java_packages ()
{
    local sourcepath i;
    _java_find_sourcepath;
    cur=${cur//.//};
    for i in ${sourcepath//:/ };
    do
        if [ -d $i ]; then
            COMPREPLY=("${COMPREPLY[@]}" $( command ls -F -d                 $i/$cur* 2>/dev/null | sed -e 's|^'$i'/||' ));
        fi;
    done;
    COMPREPLY=($( tr " " "\n" <<<"${COMPREPLY[@]}" | command grep "/$" ));
    COMPREPLY=(${COMPREPLY[@]%/});
    cur=${COMPREPLY[@]//\//.}
}
_java_path ()
{
    cur=${cur##*:};
    _filedir '@(jar|zip)'
}
_javac ()
{
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    case $prev in
        -d)
            _filedir -d;
            return 0
        ;;
        -classpath | -bootclasspath | -sourcepath | -extdirs)
            _java_path;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-g -g:none -g:lines -g:vars \
            -g:source -O -nowarn -verbose -deprecation -classpath \
            -sourcepath -bootclasspath -extdirs -d -encoding -source \
            -target -help' -- "$cur" ));
    else
        _filedir java;
    fi
}
_javadoc ()
{
    COMPREPLY=();
    local cur prev classpath;
    _get_comp_words_by_ref cur prev;
    case $prev in
        -overview | -helpfile)
            _filedir '?(x)htm?(l)';
            return 0
        ;;
        -stylesheetfile)
            _filedir css;
            return 0
        ;;
        -d | -link | -linkoffline)
            _filedir -d;
            return 0
        ;;
        -classpath | -bootclasspath | -docletpath | -sourcepath | -extdirs)
            _java_path;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-overview -public -protected \
            -package -private -help -doclet -docletpath \
            -sourcepath -classpath -exclude -subpackages \
            -breakiterator -bootclasspath -source -extdirs \
            -verbose -locale -encoding -J -d -use -version \
            -author -docfilessubdirs -splitindex \
            -windowtitle -doctitle -header -footer -bottom \
            -link -linkoffline -excludedocfilessubdir \
            -group -nocomment -nodeprecated -noqualifier \
            -nosince -nodeprecatedlist -notree -noindex \
            -nohelp -nonavbar -quiet -serialwarn -tag \
            -taglet -tagletpath -charset -helpfile \
            -linksource -stylesheetfile -docencoding' -- "$cur" ));
    else
        _filedir java;
        _java_packages;
    fi
}
_javaws ()
{
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    case $prev in
        -help | -license | -about | -viewer | -arg | -param | -property | -update | -umask)
            return 0
        ;;
        -basedir | -codebase)
            _filedir -d;
            return 0
        ;;
        -uninstall | -import)
            _filedir jnlp;
            return 0
        ;;
    esac;
    if [[ $cur == -* ]]; then
        COMPREPLY=($( compgen -W "$( _parse_help "$1" -help ) " -- "$cur" ));
        return 0;
    fi;
    _filedir jnlp
}
_john ()
{
    local first cur options valopts compreplya compreplyb encodings formats format_classes;
    local primitives subformats list dir cmd cmd2 i ver ver1 ver2 ver3 prev words prefix option;
    LC_ALL=C;
    COMPREPLY=();
    if [[ "${COMP_WORDBREAKS}" == *:* ]]; then
        _get_comp_words_by_ref -n := cur prev words;
    else
        _get_comp_words_by_ref -n = cur prev words;
        if [[ "${cur}" == -*:* ]]; then
            if [[ "${cur}" == -*[:=]*[:=]* ]]; then
                return 0;
            fi;
            cur="${cur//:/=}";
            COMPREPLY=($(compgen -W "${cur}" -- ${cur}));
            compopt -o nospace;
            return 0;
        fi;
    fi;
    if [[ "_${cur}" != _-* ]]; then
        compopt -o bashdefault -o default;
        return 0;
    fi;
    first="${COMP_WORDS[0]}";
    ver=`${first} 2>/dev/null|sed -n '/^John the Ripper password cracker, ver/ s#^John the Ripper password cracker, ver[a-z :]*\([0-9.]*\).*$#\1#p'`;
    ver1=`echo $ver|sed 's#^\([0-9]*\).*$#\1#'`;
    ver2=`echo $ver|sed 's#^[0-9]*.\([0-9]*\).*$#\1#'`;
    ver3=`echo $ver|sed 's#^[0-9]*.[0-9]*.\([0-9]*\).*$#\1#'`;
    if [[ "_${ver3}" == "_" ]]; then
        ver3=0;
    fi;
    options="`{ ${first} 2>/dev/null|sed -n -e 's#^ *\(--[a-z-]*\(\[\)\?=\?\(LIST\)\?\).*$#\1#' -e '/^--/ p'; echo --stdin; ${first} --list=hidden-options 2>/dev/null|sed -n -e 's#^\(--[a-z-]*\(\[\)\?=\?\).*$#\1#' -e '/--/ p'; } | sort -u|grep -v -- '--show='`";
    if [[ "_${options}" == "_--stdin" && "_${__john_binary}" != "_" ]]; then
        first="${__john_binary}";
        options="`{ ${first} 2>/dev/null|sed -n -e 's#^ *\(--[a-z-]*\(\[\)\?=\?\(LIST\)\?\).*$#\1#' -e '/^--/ p'; echo --stdin; ${first} --list=hidden-options 2>/dev/null| sed -n -e 's#^\(--[a-z-]*\(\[\)\?=\?\).*$#\1#' -e '/--/ p'; } | sort -u`";
        if [[ "_${options}" == "_--stdin" ]]; then
            _filedir_xspec 2> /dev/null;
            return 0;
        fi;
    else
        if [[ ${first} == /* ]]; then
            __john_binary="${first}";
        else
            if [[ ${first} == */* ]]; then
                __john_binary="$PWD/${first}";
            else
                __john_binary="`which ${first}`";
            fi;
        fi;
    fi;
    valopts=`echo "$options"|grep '='|sed 's#^ *\([a-z=-]*\).*$#\1#'`;
    options="${options//[=/}";
    if [[ "${cur}" == --prince[=:]* || "${cur}" == -prince[=:]* ]]; then
        COMPREPLY=("--prince");
    else
        if [[ "${cur}" == --fuzz[=:]* || "${cur}" == -fuzz[=:]* ]]; then
            COMPREPLY=("--fuzz");
        else
            if [[ "${cur}" == --* ]]; then
                COMPREPLY=($(compgen -W "${options}" -- "${cur%%[=:]*}"));
            else
                COMPREPLY=($(compgen -W "${options}" -- "-${cur%%[=:]*}"));
            fi;
        fi;
    fi;
    i=${#COMPREPLY[*]};
    if [[ $i -eq 1 ]]; then
        if [[ "${cur}" != *[=:]* ]]; then
            if [[ $valopts == *${COMPREPLY[0]}* ]]; then
                if [[ "${cur}" == ${COMPREPLY[0]} ]]; then
                    if [[ "_${__john_completion}" == "_2" ]]; then
                        COMPREPLY=($(compgen -W "${cur}=" -- ${cur}));
                        compopt -o nospace;
                        return;
                    else
                        option="${cur}";
                    fi;
                else
                    compopt -o nospace;
                    return;
                fi;
            else
                return 0;
            fi;
        else
            if [[ "${COMPREPLY[0]}" == *= ]]; then
                option="${COMPREPLY[0]}${cur#*[=:]}";
            else
                option="${COMPREPLY[0]}=${cur#*[=:]}";
            fi;
        fi;
    else
        if [[ $i -eq 0 ]]; then
            compopt -o bashdefault -o default;
            return 0;
        else
            if [[ "${cur}" == *[=:]* ]]; then
                COMPREPLY=();
                return 0;
            else
                return 0;
            fi;
        fi;
    fi;
    COMPREPLY=();
    COMP_LINE=`echo ${COMP_LINE}|sed -r "s# [^\-][^ ]+##g"`;
    case "${option}" in
        --format=dynamic)
            cur=${cur#*[=:]};
            COMPREPLY=($(compgen -W "dynamic_ dynamic=" -- ${cur}));
            return 0
        ;;
        --format=dynamic=*)
            primitives=`${first} 2>/dev/null --list=subformats | awk '{print $7}' |  cut -d\( -f1 | sort -u|sed "s#^\(.*\)#\1\x5c\x5c\x5c\x5c(#"`;
            if [[ "_${primitives}" == "_" ]]; then
                return 0;
            fi;
            cur=${cur#*[=:]};
            cur=${cur#*[=:]};
            COMPREPLY=($(compgen -W "${primitives}" -- ${cur}));
            compopt -o nospace;
            return 0
        ;;
        --format=dynamic_*)
            subformats=`${first} 2>/dev/null --list=subformats|sed 's#^\(User\)\?Format = \(dynamic_[0-9]*\).*$#\2#'`;
            if [[ "_${subformats}" != _dynamic_0* ]]; then
                subformats=`${first} 2>/dev/null --subformat=LIST|sed 's#^\(User\)\?Format = \(dynamic_[0-9]*\).*$#\2#'`;
                if [[ "_${subformats}" != _dynamic_0* ]]; then
                    return 0;
                fi;
            fi;
            cur=${cur#*[=:]};
            COMPREPLY=($(compgen -W "${subformats}" -- ${cur}));
            return 0
        ;;
        --format=*)
            cur=`echo ${cur#*[=:]} | tr A-Z a-z`;
            formats=`${first} 2>/dev/null --list=formats|sed -n -e 's#,##g' -e 's#\<dynamic_n\>#dynamic#' -e 'p' | tr A-Z a-z`;
            if [[ "x${formats}" == x ]]; then
                formats=`${first} |sed -n -e '/^--format/,$ {' -e 's#^--format=[ A-Za-z]*:##' -e '/^--/ b' -e 's#^ *##' -e 's#\<dynamic_n\>#dynamic#' -e 's#^\(.*\)$#\1#' -e 's#/# #g' -e 'p }' | tr A-Z a-z`;
            fi;
            format_classes=`${first} --list=hidden-options  2>/dev/null|sed -n -e 's#,##g ; s#^--format=[ A-Za-z]*:## p'`;
            COMPREPLY=($(compgen -W "${formats} ${format_classes}" -- ${cur}));
            if [[ "${COMPREPLY[0]}_" == dynamic_ ]]; then
                compopt -o nospace;
            fi;
            return 0
        ;;
        --restore | --status)
            prev="${cur}";
            cur="";
            _filedir "rec";
            for ((i=0; i < ${#COMPREPLY[@]}; i++))
            do
                COMPREPLY[$i]="${prev}=${COMPREPLY[$i]%*.rec}";
            done;
            COMPREPLY[${#COMPREPLY[@]}]="${prev}";
            return 0
        ;;
        --restore=* | --status=*)
            cur=${cur#*[=:]};
            __expand_tilde_by_ref cur 2> /dev/null;
            _filedir "rec";
            for ((i=0; i < ${#COMPREPLY[@]}; i++))
            do
                if [[ ${COMPREPLY[$i]} =~ ^(.*)[.]rec$ ]]; then
                    COMPREPLY[$i]=${BASH_REMATCH[1]};
                    if [[ ${COMPREPLY[$i]} =~ ^(.*)[.][1-9][0-9]*$ ]]; then
                        COMPREPLY[$i]="";
                    fi;
                fi;
            done;
            return 0
        ;;
        --wordlist=* | --mkv-stats=* | --prince=* | --fuzz=* | --fuzz-dump=* | --single-wordlist=*)
            cur=${cur#*[=:]};
            __expand_tilde_by_ref cur 2> /dev/null;
            _filedir;
            return 0
        ;;
        --rules | --single)
            cmd=`echo ${COMP_LINE}|sed "s# ${cur}# --list=rules #"`;
            list=`${cmd} 2>/dev/null`;
            if [[ $? -ne 0 ]]; then
                list=`${first} --list=rules 2>/dev/null`;
            fi;
            if [[ $? -ne 0 ]]; then
                list="single wordlist NT";
            fi;
            list=`echo "${list}"|sed 's# #\n#g'|sed "s#^\(.\)#${cur}=\1#"`;
            list="${list} ${cur}";
            COMPREPLY=($(compgen -W "${list}" -- ${cur}));
            return 0
        ;;
        --rules=* | --single=*)
            cmd=`echo ${COMP_LINE}|sed "s# ${cur}# --list=rules #"`;
            list=`${cmd} 2>/dev/null`;
            if [[ $? -ne 0 ]]; then
                list=`${first} --list=rules 2>/dev/null`;
            fi;
            if [[ $? -eq 0 ]]; then
                cur=`echo ${cur#*[=:]} | tr A-Z a-z`;
                COMPREPLY=($(compgen -W "${list}" -- ${cur}));
            else
                cur=${cur#*[=:]};
                COMPREPLY=($(compgen -W "NT single wordlist" -- ${cur}));
            fi;
            return 0
        ;;
        --regex=alpha[:=]*)
            cmd=`echo ${COMP_LINE}|sed "s# ${cur}# --list=sections #"`;
            cur=${cur#*[=:]};
            cur=${cur#*[=:]};
            list=`${cmd} 2>/dev/null|LC_ALL=C grep "^list\.rexgen\.alpha:"|cut -d: -f 2-`;
            COMPREPLY=($(compgen -W "${list}" -- ${cur}));
            return 0
        ;;
        --regex=?(a|al|alp|alph|alpha))
            cur=${cur#*[=:]};
            COMPREPLY=($(compgen -W "alpha:" -- ${cur}));
            compopt -o nospace;
            return 0
        ;;
        --external=*)
            cmd=`echo ${COMP_LINE}|sed "s# ${cur}# --list=externals #"`;
            list=`${cmd} 2>/dev/null`;
            if [[ $? -ne 0 ]]; then
                list=`${first} --list=externals 2>/dev/null`;
            fi;
            if [[ $? -ne 0 ]]; then
                list="Filter_Alpha Filter_Digits Filter_Alnum Double Parallel Strip Keyboard";
                if [[ $ver1 -eq 1 && $ver2 -lt 8 ]]; then
                    list="${list} Filter_LanMan LanMan";
                fi;
                if [[ $ver1 -eq 1 && $ver2 -eq 7 ]]; then
                    if [[ $ver3 -ge 3 ]]; then
                        list="${list} DumbForce KnownForce";
                    fi;
                    if [[ $ver3 -ge 7 ]]; then
                        list="${list} DateTime Repeats Subsets AtLeast1-Simple AtLeast1-Generic Policy";
                    fi;
                    if [[ $ver3 -ge 8 ]]; then
                        list="${list} AppendLuhn";
                    fi;
                    if [[ $ver3 -ge 9 ]]; then
                        list="${list} AutoAbort AutoStatus";
                    fi;
                else
                    if [[ $ver1 -gt 1 || $ver1 -eq 1 && ver2 -gt 7 ]]; then
                        list="${list} LM_ASCII Filter_LM_ASCII Filter_ASCII Filter_Lower Filter_LowerNum Filter_LowerSpace Filter_Upper Filter_UpperNum DumbForce KnownForce DateTime Repeats Subsets AtLeast1-Simple AtLeast1-Generic Policy AppendLuhn AutoAbort AutoStatus";
                    fi;
                fi;
                cur=${cur#*[=:]};
            else
                cur=`echo ${cur#*[=:]} | tr A-Z a-z`;
            fi;
            COMPREPLY=($(compgen -W "${list}" -- ${cur}));
            return 0
        ;;
        --incremental)
            cmd=`echo ${COMP_LINE}|sed "s# ${cur}# --list=inc-modes #"`;
            list=`${cmd} 2>/dev/null`;
            if [[ $? -ne 0 ]]; then
                list=`${first} --list=inc-modes 2>/dev/null`;
            fi;
            if [[ $? -ne 0 ]]; then
                list="Alpha Digits Alnum";
                if [[ ${ver1} -eq 1 && ${ver2} -le 7 ]]; then
                    list="${list} All LanMan";
                else
                    list="${list} ASCII LM_ASCII Lower LowerNum LowerSpace Upper UpperNum";
                fi;
            fi;
            list=`echo "${list}"|sed 's# #\n#g'|sed "s#^\(.\)#${cur}=\1#"`;
            list="${list} ${cur}";
            COMPREPLY=($(compgen -W "${list}" -- ${cur}));
            return 0
        ;;
        --incremental=*)
            cmd=`echo ${COMP_LINE}|sed "s# ${cur}# --list=inc-modes #"`;
            list=`${cmd} 2>/dev/null`;
            if [[ $? -ne 0 ]]; then
                list=`${first} --list=inc-modes 2>/dev/null`;
            fi;
            if [[ $? -eq 0 ]]; then
                cur=`echo ${cur#*[=:]} | tr A-Z a-z`;
                COMPREPLY=($(compgen -W "${list}" -- ${cur}));
            else
                cur=${cur#*[=:]};
                list="Alpha Digits Alnum";
                if [[ ${ver1} -eq 1 && ${ver2} -le 7 ]]; then
                    list="${list} All LanMan";
                else
                    list="${list} ASCII LM_ASCII Lower LowerNum LowerSpace Upper UpperNum";
                fi;
                COMPREPLY=($(compgen -W "${list}" -- ${cur}));
            fi;
            return 0
        ;;
        --make-charset=*)
            cur=${cur#*[=:]};
            __expand_tilde_by_ref cur 2> /dev/null;
            _filedir "chr";
            return 0
        ;;
        --stdout)
            COMPREPLY=($(compgen -W "--stdout --stdout=LENGTH" -- ${cur}));
            return 0
        ;;
        --markov)
            COMPREPLY=($(compgen -W "--markov --markov=[MINLEVEL-]LEVEL[:START[:END]] --markov=MODE --markov=MODE:[MINLEVEL-]LEVEL[:START[:END]]" -- ${cur}));
            return 0
        ;;
        --markov=*)
            if [[ "${valopts}" == *--list=* ]]; then
                cmd=`echo ${COMP_LINE}|sed "s# ${cur}# --list=Markov #"`;
                list=`${cmd} 2>/dev/null | sed 's#^.*:.*$##' | sed 's#^[-0-9]*$##'`;
                cur=`echo ${cur#*[=:]} | tr A-Z a-z`;
                COMPREPLY=($(compgen -W "${list} [MINLEVEL-]LEVEL[:START[:END]] MODE MODE:[MINLEVEL-]LEVEL[:START[:END]]" -- ${cur}));
                compopt -o nospace;
            fi;
            return 0
        ;;
        --test)
            COMPREPLY=($(compgen -W "--test --test=SECONDS" -- ${cur}));
            return 0
        ;;
        --show)
            COMPREPLY=($(compgen -W "--show --show=" -- ${cur}));
            return 0
        ;;
        --show=?(*))
            cur=`echo ${cur#*[=:]} | tr A-Z a-z`;
            COMPREPLY=($(compgen -W "left formats types invalid" -- ${cur}));
            return 0
        ;;
        --users=?(-)+(L|U)* | --groups=+(-|G)* | --shells=+(-|S)* | --salts=+(-|C)*)
            return 0
        ;;
        --users=?(-))
            cur=${cur#*=};
            COMPREPLY=($(compgen -W "LOGIN,... UID,... -LOGIN,... -UID,..." -- ${cur}));
            return 0
        ;;
        --groups=*)
            cur=${cur#*=};
            COMPREPLY=($(compgen -W "GID,... -GID,..." -- ${cur}));
            return 0
        ;;
        --shells=*)
            cur=${cur#*=};
            COMPREPLY=($(compgen -W "SHELL,... -SHELL,..." -- ${cur}));
            return 0
        ;;
        --salts=*)
            cur=${cur#*=};
            COMPREPLY=($(compgen -W "COUNT -COUNT" -- ${cur}));
            return 0
        ;;
        --encoding=* | --intermediate-enc=* | --internal-codepage=* | --internal-encoding=* | --target-encoding=* | --input-encoding=*)
            cur=${cur#*[=:]};
            list=`${first} --list=\? 2>/dev/null|sed 's#\(,\)\?\( or\)\?[ ]*[<].*$##; s#,##g'`;
            if [[ "_${list}" == *encoding* ]]; then
                cmd="${first} --list=encodings";
            else
                cmd="${first} --encoding=LIST";
            fi;
            encodings=`${cmd} 2>&1|grep -v 'Supported encodings'|sed 's#[,()]##g; s#\bor ##g'|tr A-Z a-z`;
            if [[ "_${cur}" != "_" ]]; then
                case "${cur}" in
                    8*)
                        encodings=`echo "${encodings}" | sed 's#iso-8#8#g'`
                    ;;
                    iso8* | ISO8*)
                        encodings=`echo "${encodings}" | sed 's#iso-8#iso8#g'`
                    ;;
                    utf8 | UTF8)
                        encodings=`echo "${encodings}" | sed 's#utf-8#utf8#'`
                    ;;
                    koi8 | KOI8 | koi8- | KOI8-)

                    ;;
                    koi8* | KOI8*)
                        encodings=`echo "${encodings}" echo "$encodings" | sed 's#koi8-#koi8#'`
                    ;;
                esac;
                encodings=`echo "$encodings" ; echo "$encodings" | tr a-z A-Z`;
            fi;
            if [[ ${COMP_CWORD} -eq 2 || ${COMP_CWORD} -eq 3 && "_${cur}" != "_" ]]; then
                if [[ "_${list}" != *encoding* ]]; then
                    encodings="${encodings} LIST";
                fi;
            fi;
            COMPREPLY=($(compgen -W "${encodings}" -- ${cur}));
            return 0
        ;;
        --pot=* | --loopback=*)
            cur=${cur#*[=:]};
            __expand_tilde_by_ref cur 2> /dev/null;
            _filedir "pot";
            return 0
        ;;
        --config=*)
            cur=${cur#*[=:]};
            __expand_tilde_by_ref cur 2> /dev/null;
            _filedir '@(conf|ini)';
            return 0
        ;;
        --save-memory=*)
            cur=${cur#*[=:]};
            COMPREPLY=($(compgen -W "1 2 3" -- ${cur}));
            return 0
        ;;
        --regen-lost-salts=*)
            cur=${cur#*[=:]};
            COMPREPLY=($(compgen -W "1 2 3 4 5" -- ${cur}));
            return 0
        ;;
        --subformat=*)
            if [[ "${options}" == *--subformat=LIST* ]]; then
                cur=`echo ${cur#*[=:]} | tr a-z A-Z`;
                COMPREPLY=($(compgen -W "LIST" -- ${cur}));
            else
                cur=`echo ${cur#*[=:]} | tr A-Z a-z`;
                subformats=`${first} --test=0 --format=crypt --subformat=\? 2>&1|sed -n 's#,# #g;/^Subformat / s#^[^:]*:\(.*\)$#\L\1# p'`;
                COMPREPLY=($(compgen -W "${subformats}" -- ${cur}));
            fi;
            return 0
        ;;
        -+(platform|device)=[Ll]?([Ii]|[Ii][Ss]|[Ii][Ss][Tt]))
            list=`${first} --list=\? 2>/dev/null|sed 's#\(,\)\?\( or\)\?[ ]*[<].*$##; s#,##g'`;
            if [[ "${valopts}" == *--platform=* && "_${list}" != _*-devices* ]]; then
                cur=`echo ${cur#*[=:]} | tr a-z A-Z`;
                COMPREPLY=($(compgen -W "LIST" -- ${cur}));
            fi;
            return 0
        ;;
        --+(platform|device)=)
            list=`${first} --list=\? 2>/dev/null|sed 's#\(,\)\?\( or\)\?[ ]*[<].*$##; s#,##g'`;
            if [[ "${valopts}" == *--platform=* && "_${list}" != _*-devices* ]]; then
                cur=${cur#*[=:]};
                COMPREPLY=($(compgen -W "LIST N" -- ${cur}));
            fi;
            return 0
        ;;
        --list+(+(=|:)+([a-z_-]):|:+([a-z._-])=)*([A-Za-z0-9:._-]))
            cmd2=`echo ${COMP_LINE}|sed "s# ${cur}# #"`;
            cur=`echo ${cur#*[=:]} | tr A-Z a-z`;
            cmd=${cur%[=:]*};
            prefix="";
            if [[ "_${cmd}" == _*:* ]]; then
                prefix=${cmd#*:};
                prefix=${prefix#*:};
                cmd=${cmd%:*};
                cur=${cur#*[=:]};
            fi;
            cur=${cur#*[=:]};
            if [[ ( "_${cmd}" == _parameters || "_${cmd}" == _list-data ) && "_${prefix}" != "_" ]]; then
                list=`${cmd2} --list=${prefix} 2>/dev/null|sed 's#^.*\s.*$##'`;
            else
                list=`${cmd2} --list=help:${cmd} 2>/dev/null |sed 's#,#\n#g'`;
            fi;
            if [[ $? -eq 0 ]]; then
                COMPREPLY=($(compgen -W "${list}" -- ${cur}));
            fi;
            return 0
        ;;
        --list=*)
            cur=${cur#*[=:]};
            list=`${first} --list=\? 2>/dev/null|sed 's#\(,\)\?\(or\)\?[ ]*[<].*$##; s#,##g'`;
            if [[ $? -eq 0 ]]; then
                if [[ "${list}" == *help* ]]; then
                    COMPREPLY=($(compgen -W "${list}" -- ${cur}));
                else
                    COMPREPLY=($(compgen -W "${list} ?" -- ${cur}));
                fi;
                if [[ ${#COMPREPLY[@]} -eq 1 && "_${COMPREPLY[0]}" == _*:* ]]; then
                    if [[ "_${COMPREPLY[0]}" == _*\[:* ]]; then
                        COMPREPLY[0]=${COMPREPLY[0]%\[*};
                        if [[ "_${__john_completion}" == "_2" && "_${COMPREPLY[0]}" == _${cur} ]]; then
                            COMPREPLY[0]=${COMPREPLY[0]%:*}:;
                        fi;
                    else
                        COMPREPLY[0]=${COMPREPLY[0]%:*}:;
                    fi;
                    compopt -o nospace;
                fi;
            fi;
            return 0
        ;;
        --bare-always-valid=*)
            cur=${cur#*[=:]};
            COMPREPLY=($(compgen -W "Y" -- ${cur}));
            return 0
        ;;
        --verbosity=*)
            cur=${cur#*[=:]};
            COMPREPLY=($(compgen -W "1 2 3 4 5" -- ${cur}));
            return 0
        ;;
        -*+(=|:))
            return 0
        ;;
        -*)
            compreplya=`compgen -W "${options}" -- ${cur}`;
            if [[ "_${compreplya}_" == "__" ]]; then
                cur="-${cur}";
                compreplya=`compgen -W "${options}" -- ${cur}`;
            fi;
            compreplyb=`compgen -W "${valopts}" -- ${cur}`;
            COMPREPLY=($(compgen -W "${options}" -- ${cur}));
            if [[ "_${compreplya}" == "_${compreplyb}" ]]; then
                compopt -o nospace;
            fi;
            return 0
        ;;
    esac
}
_kernel_versions ()
{
    COMPREPLY=($( compgen -W '$( command ls /lib/modules )' -- "$cur" ))
}
_kill ()
{
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [[ $COMP_CWORD -eq 1 && "$cur" == -* ]]; then
        _signals;
    else
        _pids;
    fi
}
_killall ()
{
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [[ $COMP_CWORD -eq 1 && "$cur" == -* ]]; then
        _signals;
    else
        _pnames;
    fi;
    return 0
}
_known_hosts ()
{
    local options;
    COMPREPLY=();
    [[ "$1" == -a || "$2" == -a ]] && options=-a;
    [[ "$1" == -c || "$2" == -c ]] && options="$options -c";
    _known_hosts_real $options "$(_get_cword :)"
}
_known_hosts_real ()
{
    local configfile flag prefix;
    local cur curd awkcur user suffix aliases i host;
    local -a kh khd config;
    local OPTIND=1;
    while getopts "acF:p:" flag "$@"; do
        case $flag in
            a)
                aliases='yes'
            ;;
            c)
                suffix=':'
            ;;
            F)
                configfile=$OPTARG
            ;;
            p)
                prefix=$OPTARG
            ;;
        esac;
    done;
    [ $# -lt $OPTIND ] && echo "error: $FUNCNAME: missing mandatory argument CWORD";
    cur=${!OPTIND};
    let "OPTIND += 1";
    [ $# -ge $OPTIND ] && echo "error: $FUNCNAME("$@"): unprocessed arguments:" $(while [ $# -ge $OPTIND ]; do printf '%s\n' ${!OPTIND}; shift; done);
    [[ $cur == *@* ]] && user=${cur%@*}@ && cur=${cur#*@};
    kh=();
    if [ -n "$configfile" ]; then
        [ -r "$configfile" ] && config=("${config[@]}" "$configfile");
    else
        for i in /etc/ssh/ssh_config "${HOME}/.ssh/config" "${HOME}/.ssh2/config";
        do
            [ -r $i ] && config=("${config[@]}" "$i");
        done;
    fi;
    if [ ${#config[@]} -gt 0 ]; then
        local OIFS=$IFS IFS='
';
        local -a tmpkh;
        tmpkh=($( awk 'sub("^[ \t]*([Gg][Ll][Oo][Bb][Aa][Ll]|[Uu][Ss][Ee][Rr])[Kk][Nn][Oo][Ww][Nn][Hh][Oo][Ss][Tt][Ss][Ff][Ii][Ll][Ee][ \t]+", "") { print $0 }' "${config[@]}" | sort -u ));
        for i in "${tmpkh[@]}";
        do
            i=${i//\"};
            __expand_tilde_by_ref i;
            [ -r "$i" ] && kh=("${kh[@]}" "$i");
        done;
        IFS=$OIFS;
    fi;
    if [ -z "$configfile" ]; then
        for i in /etc/ssh/ssh_known_hosts /etc/ssh/ssh_known_hosts2 /etc/known_hosts /etc/known_hosts2 ~/.ssh/known_hosts ~/.ssh/known_hosts2;
        do
            [ -r $i ] && kh=("${kh[@]}" $i);
        done;
        for i in /etc/ssh2/knownhosts ~/.ssh2/hostkeys;
        do
            [ -d $i ] && khd=("${khd[@]}" $i/*pub);
        done;
    fi;
    if [[ ${#kh[@]} -gt 0 || ${#khd[@]} -gt 0 ]]; then
        awkcur=${cur//\//\\\/};
        awkcur=${awkcur//\./\\\.};
        curd=$awkcur;
        if [[ "$awkcur" == [0-9]*[.:]* ]]; then
            awkcur="^$awkcur[.:]*";
        else
            if [[ "$awkcur" == [0-9]* ]]; then
                awkcur="^$awkcur.*[.:]";
            else
                if [ -z "$awkcur" ]; then
                    awkcur="[a-z.:]";
                else
                    awkcur="^$awkcur";
                fi;
            fi;
        fi;
        if [ ${#kh[@]} -gt 0 ]; then
            COMPREPLY=("${COMPREPLY[@]}" $( awk 'BEGIN {FS=","}
            /^\s*[^|\#]/ {for (i=1; i<=2; ++i) { \
            sub(" .*$", "", $i); \
            sub("^\\[", "", $i); sub("\\](:[0-9]+)?$", "", $i); \
            if ($i ~ /'"$awkcur"'/) {print $i} \
            }}' "${kh[@]}" 2>/dev/null ));
        fi;
        if [ ${#khd[@]} -gt 0 ]; then
            for i in "${khd[@]}";
            do
                if [[ "$i" == *key_22_$curd*.pub && -r "$i" ]]; then
                    host=${i/#*key_22_/};
                    host=${host/%.pub/};
                    COMPREPLY=("${COMPREPLY[@]}" $host);
                fi;
            done;
        fi;
        for ((i=0; i < ${#COMPREPLY[@]}; i++ ))
        do
            COMPREPLY[i]=$prefix$user${COMPREPLY[i]}$suffix;
        done;
    fi;
    if [[ ${#config[@]} -gt 0 && -n "$aliases" ]]; then
        local hosts=$( sed -ne 's/^[[:blank:]]*[Hh][Oo][Ss][Tt]\([Nn][Aa][Mm][Ee]\)\{0,1\}[[:blank:]]\{1,\}\([^#*?]*\)\(#.*\)\{0,1\}$/\2/p' "${config[@]}" );
        COMPREPLY=("${COMPREPLY[@]}" $( compgen  -P "$prefix$user"             -S "$suffix" -W "$hosts" -- "$cur" ));
    fi;
    if [[ -n ${COMP_KNOWN_HOSTS_WITH_AVAHI:-} ]] && type avahi-browse >&/dev/null; then
        COMPREPLY=("${COMPREPLY[@]}" $(             compgen -P "$prefix$user" -S "$suffix" -W             "$( avahi-browse -cpr _workstation._tcp 2>/dev/null |                  awk -F';' '/^=/ { print $7 }' | sort -u )" -- "$cur" ));
    fi;
    if [ -n "${COMP_KNOWN_HOSTS_WITH_HOSTFILE-1}" ]; then
        COMPREPLY=("${COMPREPLY[@]}" $( compgen -A hostname -P "$prefix$user" -S "$suffix" -- "$cur" ));
    fi;
    __ltrim_colon_completions "$prefix$user$cur";
    return 0
}
_ktutil ()
{
    local cur prev command options split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in
        -p | --principal)
            _heimdal_principals;
            return 0
        ;;
        -e | --enctype)
            _heimdal_encodings;
            return 0
        ;;
        -a | --admin-server)
            _known_hosts_real "$cur";
            return 0
        ;;
        -r | --realm)
            _heimdal_realms;
            return 0
        ;;
        -s | -k | --srvtab | --keytab)
            _filedir;
            return 0
        ;;
    esac;
    $split && return 0;
    commands='add change copy get list remove rename purge srvconvert \
        srv2keytab srvcreate key2srvtab';
    for ((i=1; i < COMP_CWORD; i++ ))
    do
        case ${COMP_WORDS[i]} in
            -k | --keytab)
                i=$(($i+1))
            ;;
            -*)

            ;;
            *)
                command=${COMP_WORDS[i]};
                break
            ;;
        esac;
    done;
    if [[ "$cur" == -* ]]; then
        case $command in
            add)
                options='-p --principal -V -e --enctype -w --password -r \
                    --random -s --no-salt -h --hex'
            ;;
            change)
                options='-r --realm -a --admin-server -s --server-port'
            ;;
            get)
                options='-p --principal -e --enctype -r --realm -a \
                    --admin-server -s server --server-port'
            ;;
            list)
                options='--keys --timestamp'
            ;;
            remove)
                options='-p --principal -V --kvno -e --enctype'
            ;;
            purge)
                options='--age'
            ;;
            srv2keytab | key2srvtab)
                options='-s --srvtab'
            ;;
            *)
                options='-k --keytab -v --verbose --version -v --help'
            ;;
        esac;
        COMPREPLY=($( compgen -W "$options" -- "$cur" ));
    else
        case $command in
            copy)
                _filedir
            ;;
            get)
                _heimdal_principals
            ;;
            rename)
                _heimdal_principals
            ;;
            *)
                COMPREPLY=($( compgen -W "$commands" -- "$cur" ))
            ;;
        esac;
    fi
}
_ldap_protocols ()
{
    COMPREPLY=($( compgen -W '2 3' -- "$cur" ))
}
_ldap_uris ()
{
    COMPREPLY=($( compgen -W 'ldap:// ldaps://' -- "$cur" ))
}
_ldapaddmodify ()
{
    local cur prev options;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in
        -h)
            _known_hosts_real "$cur";
            return 0
        ;;
        -H)
            _ldap_uris;
            return 0
        ;;
        -S | -f | -y)
            _filedir;
            return 0
        ;;
        -P)
            _ldap_protocols;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        options='-c -S -n -v -M -MM -d -D -W -w -y -h -H -p -P -O -I \
            -Q -U -R -x -X -Y -Z -ZZ -f';
        if [[ ${COMP_WORDS[0]} == ldapmodify ]]; then
            options="$options -a";
        fi;
        COMPREPLY=($( compgen -W "$options" -- "$cur" ));
    fi
}
_ldapcompare ()
{
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in
        -h)
            _known_hosts_real "$cur";
            return 0
        ;;
        -H)
            _ldap_uris;
            return 0
        ;;
        -y)
            _filedir;
            return 0
        ;;
        -P)
            _ldap_protocols;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-n -v -z -M -MM -d -D -W -w -y \
            -H -h -P -p -O -I -Q -U -R -x -X -Y -Z -ZZ' -- "$cur" ));
    fi
}
_ldapdelete ()
{
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in
        -h)
            _known_hosts_real "$cur";
            return 0
        ;;
        -H)
            _ldap_uris;
            return 0
        ;;
        -f | -y)
            _filedir;
            return 0
        ;;
        -P)
            _ldap_protocols;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-n -v -c -M -MM -d -f -D -W -w -y \
            -H -h -P -p -O -U -R -r -x -I -Q -X -Y -Z -ZZ' -- "$cur" ));
    fi
}
_ldapmodrdn ()
{
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in
        -h)
            _known_hosts_real "$cur";
            return 0
        ;;
        -H)
            _ldap_uris;
            return 0
        ;;
        -f | -y)
            _filedir;
            return 0
        ;;
        -P)
            _ldap_protocols;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-r -s -n -v -c -M -MM -d -D -W -w \
            -y -H -h -P -p -O -I -Q -U -R -x -X -Y -Z -ZZ -f' -- "$cur" ));
    fi
}
_ldappasswd ()
{
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in
        -h)
            _known_hosts_real "$cur";
            return 0
        ;;
        -H)
            _ldap_uris;
            return 0
        ;;
        -t | -T | -y)
            _filedir;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-A -a -t -d -D -H -h -n -p -S -s -T \
            -v -W -w -y -O -I -Q -U -R -x -X -Y -Z -ZZ' -- "$cur" ));
    fi
}
_ldapsearch ()
{
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in
        -h)
            _known_hosts_real "$cur";
            return 0
        ;;
        -H)
            _ldap_uris;
            return 0
        ;;
        -T)
            _filedir -d;
            return 0
        ;;
        -f | -y)
            _filedir;
            return 0
        ;;
        -s)
            COMPREPLY=($( compgen -W 'base one sub children' -- "$cur" ));
            return 0
        ;;
        -a)
            COMPREPLY=($( compgen -W 'never always search find'                 -- "$cur" ));
            return 0
        ;;
        -P)
            _ldap_protocols;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-n -u -v -t -tt -T -F -A -C -L -LL \
            -LLL -M -MM -S -d -f -x -D -W -w -y -H -h -p -b -s -a \
            -P -e -E -l -z -O -I -Q -U -R -X -Y -Z -ZZ' -- "$cur" ));
    fi
}
_ldapwhoami ()
{
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in
        -h)
            _known_hosts_real "$cur";
            return 0
        ;;
        -H)
            _ldap_uris;
            return 0
        ;;
        -f | -y)
            _filedir;
            return 0
        ;;
        -P)
            _ldap_protocols;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-n -v -z -d -D -W -w -y -H -h -p -P \
            -O -I -Q -U -R -x -X -Y -Z -ZZ' -- "$cur" ));
    fi
}
_linux_fstab ()
{
    COMPREPLY=();
    local fs_spec fs_file fs_other;
    local oldifs="$IFS";
    while read -r fs_spec fs_file fs_other; do
        if [[ $fs_spec = [#]* ]]; then
            continue;
        fi;
        if [[ $1 == -L ]]; then
            local fs_label=${fs_spec/#LABEL=};
            if [[ $fs_label != "$fs_spec" ]]; then
                __linux_fstab_unescape fs_label;
                IFS='';
                COMPREPLY+=("$fs_label");
                IFS=$oldifs;
            fi;
        else
            __linux_fstab_unescape fs_spec;
            __linux_fstab_unescape fs_file;
            IFS='';
            [[ $fs_spec = */* ]] && COMPREPLY+=("$fs_spec");
            [[ $fs_file = */* ]] && COMPREPLY+=("$fs_file");
            IFS=$oldifs;
        fi;
    done;
    _reply_compgen_array
}
_longopt ()
{
    local cur prev split=false;
    _get_comp_words_by_ref -n = cur prev;
    _split_longopt && split=true;
    case "$prev" in
        --*[Dd][Ii][Rr]*)
            _filedir -d;
            return 0
        ;;
        --*[Ff][Ii][Ll][Ee]* | --*[Pp][Aa][Tt][Hh]*)
            _filedir;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W "$( $1 --help 2>&1 |             sed -ne 's/.*\(--[-A-Za-z0-9]\{1,\}\).*/\1/p' | sort -u )"             -- "$cur" ));
    else
        if [[ "$1" == @(mk|rm)dir ]]; then
            _filedir -d;
        else
            _filedir;
        fi;
    fi
}
_look ()
{
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [ $COMP_CWORD = 1 ]; then
        COMPREPLY=($( compgen -W '$(look "$cur" 2>/dev/null)' -- "$cur" ));
    fi
}
_lsof ()
{
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    case $prev in
        -'?' | -h | +c | -c | -d | -F | -i | +r | -r | -s | -S | -T)
            return 0
        ;;
        -A | -k | -m | +m | -o)
            _filedir;
            return 0
        ;;
        +d | +D)
            _filedir -d;
            return 0
        ;;
        -D)
            COMPREPLY=($( compgen -W '? b i r u' -- "$cur" ));
            return 0
        ;;
        -f)
            COMPREPLY=($( compgen -W 'c f g G n' -- "$cur" ));
            return 0
        ;;
        -g)
            _pgids;
            return 0
        ;;
        -p)
            _pids;
            return 0
        ;;
        -u)
            COMPREPLY=($( compgen -u -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ "$cur" == [-+]* ]]; then
        COMPREPLY=($( compgen -W '-h -a -A -b -c +c -C +d -d +D -D +f -f -F -g
            -i -k -l +L -L +m -m +M -M -n -N -o -O -p -P +r -r -R -s -S -T -t
            -u -U -v -V +w -w -x -X -z -Z' -- "$cur" ));
        return 0;
    fi;
    _filedir
}
_m ()
{
    local cur;
    local commands=(help airdrop battery bluetooth dir disk dns dock finder firewall flightmode gatekeeper group hostname info itunes lock network nosleep notification ntp printer restart safeboot screensaver service shutdown sleep timezone touchbar trash user update volume vpn wallpaper wifi);
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$COMP_CWORD" in
        1)
            COMPREPLY=($( compgen -W "${commands[*]}" -- $cur  ))
        ;;
        2)
            _m_sub "$prev"
        ;;
        *)
            cmd=${COMP_WORDS[1]};
            sub=${COMP_WORDS[2]};
            case "$cmd" in
                dir)
                    _m_dir "$prev"
                ;;
                disk)
                    _m_disk "$prev" "$sub"
                ;;
                dock)
                    _m_dock "$prev" "$sub"
                ;;
                finder)
                    [[ $COMP_CWORD == 3 ]] && COMPREPLY=($(compgen -W "YES NO" -- $cur))
                ;;
                firewall)
                    local _tmp=(*);
                    [[ $sub == "add" || $sub == "remove" && $COMP_CWORD -lt 5 ]] && COMPREPLY=($(compgen -W "${_tmp[*]}" -- $cur))
                ;;
                gatekeeper)
                    if [[ $sub == "create" && $COMP_CWORD -gt 3 && $COMP_CWORD -lt 5 ]]; then
                        local _tmp=(*);
                        COMPREPLY=($(compgen -W "${_tmp[*]}" -- $cur));
                    fi
                ;;
                network)
                    if [[ $sub == "location" ]]; then
                        if [[ $COMP_CWORD == 3 ]]; then
                            local _tmp=(create delete switch);
                            COMPREPLY=($(compgen -W "${_tmp[*]}" -- $cur));
                        fi;
                    fi
                ;;
                nosleep)
                    local _tmp=(*);
                    [[ $COMP_CWORD == 3 ]] && COMPREPLY=($(compgen -W "${_tmp[*]}" -- $cur))
                ;;
                screensaver)
                    [[ $sub == "askforpassword" && $COMP_CWORD == 3 ]] && COMPREPLY=($(compgen -W "YES NO" -- $cur))
                ;;
            esac
        ;;
    esac
}
_m_dir ()
{
    local prev="$1";
    local choices=();
    case "$prev" in
        tree)
            choices=(*)
        ;;
        size)
            choices=(*)
        ;;
        delete)
            choices=(empty dsfiles)
        ;;
        dsfiles)
            choices=(on off)
        ;;
        empty)
            choices=(*)
        ;;
    esac;
    COMPREPLY=($( compgen -W "${choices[*]}" -- $cur  ))
}
_m_disk ()
{
    local prev="$1";
    local sub="$2";
    local choices=();
    case "$sub" in
        ls | list | info | reformat)
            [[ $COMP_CWORD == 3 ]] && choices=(*)
        ;;
        verify | repair)
            [[ $COMP_CWORD == 3 ]] && choices=(volume disk);
            [[ $COMP_CWORD == 4 ]] && choices=(*)
        ;;
        format)
            if [[ $COMP_CWORD == 3 ]]; then
                choices=(ExFAT JHFS+ MS-DOS volume);
            else
                case $COMP_CWORD in
                    4)
                        [[ ${COMP_WORDS[3]} == "volume" ]] && choices=(ExFAT JHFS+ MS-DOS)
                    ;;
                    5)
                        [[ ${COMP_WORDS[3]} == "MS-DOS" || ${COMP_WORDS[3]} == "ExFAT" || ${COMP_WORDS[3]} == "JHFS+" ]] && choices=(*)
                    ;;
                    6)
                        [[ ${COMP_WORDS[3]} == "volume" ]] && choices=(*)
                    ;;
                esac;
            fi
        ;;
        rename)
            if [[ $COMP_CWORD == 3 ]]; then
                choices=($(
                        m disk ls                         | grep -E '^ +[0-9]:'                         | sed -E 's/^.+[0-9] (B|.B) +//'
                    ));
            fi
        ;;
    esac;
    COMPREPLY=($( compgen -W "${choices[*]}" -- $cur  ))
}
_m_dock ()
{
    local prev="$1";
    local sub="$2";
    local choices=();
    case "$sub" in
        autohide)
            [[ $COMP_CWORD == 3 ]] && choices=(YES NO)
        ;;
        magnification)
            [[ $COMP_CWORD == 3 ]] && choices=(YES NO)
        ;;
        position)
            [[ $COMP_CWORD == 3 ]] && choices=(BOTTOM LEFT RIGHT)
        ;;
    esac;
    COMPREPLY=($( compgen -W "${choices[*]}" -- $cur  ))
}
_m_sub ()
{
    local $prev="$1";
    local subcommands=();
    case "$prev" in
        help)

        ;;
        airdrop)
            subcommands=(status on enable off disable help)
        ;;
        appearance)
            subcommands=(darkmode transparency antialiasthreshold sidebariconsize maincolor highlightcolor)
        ;;
        battery)
            subcommands=(status help)
        ;;
        bluetooth)
            subcommands=(status on enable off disable help)
        ;;
        dir)
            subcommands=(tree size delete help)
        ;;
        disk)
            subcommands=(ls list fs filesystems info ejectall verify repair format reformat rename help)
        ;;
        display)
            subcommands=(status help)
        ;;
        dns)
            subcommands=(flush help)
        ;;
        dock)
            subcommands=(showdelay autohide autohidedelay magnification position addblankspace addrecentitems prune help)
        ;;
        finder)
            subcommands=(showhiddenfiles showextensions showdesktop help)
        ;;
        firewall)
            subcommands=(status enable disable add remove list help)
        ;;
        flightmode)
            subcommands=(on off help)
        ;;
        gatekeeper)
            subcommands=(status list enable disable create help)
        ;;
        group)
            subcommands=(list info adduser removeuser ismember help)
        ;;
        hostname)
            subcommands=(help)
        ;;
        info)
            subcommands=(help)
        ;;
        itunes)
            subcommands=(status play pause next prev mute unmute vol stop quit help)
        ;;
        localhost)
            subcommands=(ls add remove help)
        ;;
        lock)
            subcommands=(help)
        ;;
        network)
            subcommands=(ls location help)
        ;;
        nosleep)
            subcommands=(until help)
        ;;
        notification)
            subcommands=(showcenter help)
        ;;
        ntp)
            subcommands=(status enable disable set help)
        ;;
        printer)
            subcommands=(settings name queue drivers web help)
        ;;
        restart)
            subcommands=(-f help)
        ;;
        safeboot)
            subcommands=(status enable disable help)
        ;;
        screensaver)
            subcommands=(status askforpassword help)
        ;;
        service)
            subcommands=(--status-all --list --ls start stop load unload help)
        ;;
        shutdown)
            subcommands=(-f help)
        ;;
        sleep)
            subcommands=(help)
        ;;
        timezone)
            subcommands=(ls set help)
        ;;
        touchbar)
            subcommands=(reset help)
        ;;
        trash)
            subcommands=(status clean help)
        ;;
        user)
            subcommands=(ls info create delete help)
        ;;
        update)
            subcommands=(ls install help)
        ;;
        volume)
            subcommands=(up down mute unmute ismute help)
        ;;
        vpn)
            subcommands=(list status stop start help)
        ;;
        wallpaper)
            subcommands=(help *)
        ;;
        wifi)
            subcommands=(status scan showpassword ls list forget history on off connect help)
        ;;
    esac;
    COMPREPLY=($( compgen -W "${subcommands[*]}" -- $cur  ))
}
_mac_addresses ()
{
    local re='\([A-Fa-f0-9]\{2\}:\)\{5\}[A-Fa-f0-9]\{2\}';
    local PATH="$PATH:/sbin:/usr/sbin";
    COMPREPLY=("${COMPREPLY[@]}" $( ifconfig -a 2>/dev/null | sed -ne         "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($re\)[[:space:]]*$/\1/p" ));
    COMPREPLY=("${COMPREPLY[@]}" $( arp -an 2>/dev/null | sed -ne         "s/.*[[:space:]]\($re\)[[:space:]].*/\1/p" -ne         "s/.*[[:space:]]\($re\)[[:space:]]*$/\1/p" ));
    COMPREPLY=("${COMPREPLY[@]}" $( sed -ne         "s/^[[:space:]]*\($re\)[[:space:]].*/\1/p" /etc/ethers 2>/dev/null ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]}' -- "$cur" ));
    __ltrim_colon_completions "$cur"
}
_make ()
{
    local file makef makef_dir="." makef_inc cur prev i split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in
        -f | -o | -W | --file | --makefile | --old-file | --new-file | --assume-old | --assume-new | --what-if)
            _filedir;
            return 0
        ;;
        -I | -C | --directory | --include-dir)
            _filedir -d;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-b -m -B -C -d -e -f -h -i -I\
            -j -l -k -n -o -p -q -r -R - s -S -t -v -w -W \
            --always-make --directory --debug \
            --environment-overrides --file --makefile --help \
            --ignore-errors --include-dir --jobs --load-average \
            --max-load --keep-going --just-print --dry-run \
            --recon --old-file --assume-old --print-data-base \
            --question --no-builtin-rules --no-builtin-variables \
            --silent --quiet --no-keep-goind --stop --touch \
            --version --print-directory --no-print-directory \
            --what-if --new-file --assume-new \
            --warn-undefined-variables' -- "$cur" ));
    else
        for ((i=0; i < ${#COMP_WORDS[@]}; i++ ))
        do
            if [[ ${COMP_WORDS[i]} == -@(C|-directory) ]]; then
                eval makef_dir=${COMP_WORDS[i+1]};
                break;
            fi;
        done;
        for ((i=0; i < ${#COMP_WORDS[@]}; i++ ))
        do
            if [[ ${COMP_WORDS[i]} == -@(f|-?(make)file) ]]; then
                eval makef=${COMP_WORDS[i+1]};
                break;
            fi;
        done;
        [ -n "$makef" ] && makef="-f ${makef}";
        [ -n "$makef_dir" ] && makef_dir="-C ${makef_dir}";
        COMPREPLY=($( compgen -W "$( make -qp $makef $makef_dir 2>/dev/null |             awk -F':' '/^[a-zA-Z0-9][^$#\/\t=]*:([^=]|$)/ \
            {split($1,A,/ /);for(i in A)print A[i]}' )"             -- "$cur" ));
    fi
}
_man ()
{
    local cur i prev sect manpath manext mansect uname;
    manext="@([0-9lnp]|[0-9][px]|man|3pm)?(.@([gx]z|bz2|lzma|Z))";
    mansect="@([0-9lnp]|[0-9][px]|3pm)";
    COMPREPLY=();
    _get_comp_words_by_ref -n : cur prev;
    if [[ "$prev" == -l ]]; then
        _filedir $manext;
        return 0;
    fi;
    _expand || return 0;
    if [[ "$cur" == */* ]]; then
        _filedir $manext;
        return 0;
    fi;
    uname=$( uname -s );
    if [[ $uname == @(Darwin|Linux|GNU|GNU/*|FreeBSD|Cygwin|CYGWIN_*) ]]; then
        manpath=$( manpath 2>/dev/null || command man --path );
    else
        manpath=$MANPATH;
    fi;
    if [ -z "$manpath" ]; then
        COMPREPLY=($( compgen -c -- "$cur" ));
        return 0;
    fi;
    [[ "$prev" == $mansect ]] && sect=$prev || sect='*';
    manpath=$manpath:;
    if [ -n "$cur" ]; then
        manpath="${manpath//://*man$sect/$cur* } ${manpath//://*cat$sect/$cur* }";
    else
        manpath="${manpath//://*man$sect/ } ${manpath//://*cat$sect/ }";
    fi;
    COMPREPLY=($( eval command ls "$manpath" 2>/dev/null ));
    COMPREPLY=(${COMPREPLY[@]##*/?(:)});
    COMPREPLY=(${COMPREPLY[@]%.@([gx]z|bz2|lzma|Z)});
    COMPREPLY=($( compgen -W '${COMPREPLY[@]%.*}' -- "${cur//\\\\/}" ));
    if [[ "$prev" != $mansect ]]; then
        local start=${#COMPREPLY[@]};
        _filedir $manext;
        for ((i=$start; i < ${#COMPREPLY[@]}; i++ ))
        do
            [[ ${COMPREPLY[i]} == */* ]] || COMPREPLY[i]=./${COMPREPLY[i]};
        done;
    fi;
    __ltrim_colon_completions "$cur";
    return 0
}
_mas ()
{
    local cur prev words cword;
    if declare -F _init_completions > /dev/null 2>&1; then
        _init_completion;
    else
        COMPREPLY=();
        _get_comp_words_by_ref cur prev words cword;
    fi;
    if [[ $cword -eq 1 ]]; then
        COMPREPLY=($(compgen -W "$(mas help | tail -n +3 | awk '{print $1}')" -- "$cur"));
        return 0;
    fi
}
_mktemp ()
{
    COMPREPLY=();
    local cur prev split=false;
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case "$prev" in
        --help | --version | --suffix)
            return 0
        ;;
        --tmpdir | -p)
            _filedir -d;
            return 0
        ;;
    esac;
    $split && return 0;
    [[ "$cur" == -* ]] && COMPREPLY=($( compgen -W '-d -u -q -p -t' -- "$cur" ))
}
_modules ()
{
    local modpath;
    modpath=/lib/modules/$1;
    COMPREPLY=($( compgen -W "$( command ls -R $modpath |         sed -ne 's/^\(.*\)\.k\{0,1\}o\(\.gz\)\{0,1\}$/\1/p' )" -- "$cur" ))
}
_mount ()
{
    local cur sm host prev;
    COMPREPLY=();
    _get_comp_words_by_ref -n : cur prev;
    case $prev in
        -t | --types)
            _fstypes;
            return 0
        ;;
    esac;
    [[ "$cur" == \\ ]] && cur="/";
    if [[ "$cur" == *:* ]]; then
        for sm in "$(type -P showmount)" {,/usr}/{,s}bin/showmount;
        do
            [ -x "$sm" ] || continue;
            COMPREPLY=($( compgen -W "$( "$sm" -e ${cur%%:*} |                 awk 'NR>1 {print $1}' )" -- "${cur#*:}" ));
            return 0;
        done;
    fi;
    if [[ "$cur" == //* ]]; then
        host=${cur#//};
        host=${host%%/*};
        if [ -n "$host" ]; then
            COMPREPLY=($( compgen -P "//$host" -W                 "$( smbclient -d 0 -NL $host 2>/dev/null |
                sed -ne '/^['"$'\t '"']*Sharename/,/^$/p' |
                sed -ne '3,$s|^[^A-Za-z]*\([^'"$'\t '"']*\).*$|/\1|p' )"                     -- "${cur#//$host}" ));
        fi;
    else
        if [ -r /etc/vfstab ]; then
            COMPREPLY=($( compgen -W "$( awk '! /^[ \t]*#/ {if ($3 ~ /\//) print $3}' /etc/vfstab )" -- "$cur" ));
        else
            if [ ! -e /etc/fstab ]; then
                COMPREPLY=($( compgen -W "$( mount | awk '! /^[ \t]*#/ {if ($3 ~ /\//) print $3}' )" -- "$cur" ));
            else
                if [ "$prev" = -L ]; then
                    _linux_fstab -L < /etc/fstab;
                else
                    if [ "$prev" = -U ]; then
                        COMPREPLY=($( compgen -W '$(sed -ne "s/^[[:space:]]*UUID=\([^[:space:]]*\).*/\1/p" /etc/fstab )' -- "$cur" ));
                    else
                        _linux_fstab < /etc/fstab;
                    fi;
                fi;
            fi;
        fi;
    fi;
    return 0
}
_mpv ()
{
    compopt +o nospace mpv;
    local cur=${COMP_WORDS[COMP_CWORD]};
    local prev=${COMP_WORDS[((COMP_CWORD - 1))]};
    if [ "$cur" = '=' ]; then
        _mpv_get_args "$prev";
    else
        if [ "$prev" = '=' ]; then
            local prevprev=${COMP_WORDS[((COMP_CWORD - 2))]};
            _mpv_get_args "$prevprev" "$cur";
        else
            case $cur in
                -*)
                    COMPREPLY=($(compgen -W "${_mpv_regular_options[*]}" -S '=' -- "${cur}"));
                    local normal_count=${#COMPREPLY[@]};
                    COMPREPLY+=($(compgen -W "${_mpv_special_options[*]}" -- "${cur}"));
                    if [ $normal_count -gt 0 -o ${#COMPREPLY[@]} -gt 1 ]; then
                        compopt -o nospace mpv;
                    fi
                ;;
                *)
                    _filedir 2> /dev/null || COMPREPLY=($(compgen -f))
                ;;
            esac;
        fi;
    fi
}
_mpv_get_args ()
{
    local doc=$(echo "$_mpv_options" | grep -E "^\\s*$1\\s");
    local partial="$2";
    local type=$(echo "$doc" | awk '{print $2;}');
    if [ "$1" = "--show-profile" ]; then
        type="Profile";
    fi;
    declare -a candidates;
    case $type in
        String)
            if echo "$doc" | grep -q '\[file\]'; then
                if [ "$cur" = '=' ]; then
                    cur="";
                fi;
                _filedir 2> /dev/null || COMPREPLY=($(compgen -f));
                return 0;
            else
                candidates=($(mpv $1=help | grep -v ':' | awk '{print $1;}'));
                candidates+=("help");
            fi
        ;;
        Flag)
            candidates=("yes" "no" "help")
        ;;
        Choices: | Object)
            candidates=($(mpv $1=help | grep -v ':' | awk '{print $1;}'));
            candidates+=("help")
        ;;
        Image)
            candidates=($(mpv $1=help));
            candidates=("${candidates[@]:2}");
            candidates+=("help")
        ;;
        Profile)
            candidates=($(mpv $1= | grep -v ':' | awk '{print $1;}'))
        ;;
        *)

        ;;
    esac;
    COMPREPLY=($(compgen -W "${candidates[*]}" -- "${partial}"));
    if [ ${#COMPREPLY[@]} -gt 1 ]; then
        compopt -o nospace mpv;
    fi
}
_newgrp ()
{
    COMPREPLY=();
    if [[ "`_get_cword`" == "-" ]]; then
        COMPREPLY=(-);
    else
        _allowed_groups;
    fi
}
_notes_bash_autocomplete ()
{
    local cur prev opts base;
    COMPREPLY=();
    cur="${COMP_WORDS[COMP_CWORD]}";
    opts=$( ${COMP_WORDS[0]} --completion-bash ${COMP_WORDS[@]:1:$COMP_CWORD} );
    COMPREPLY=($(compgen -W "${opts}" -- ${cur}));
    return 0
}
_npm_completion ()
{
    local words cword;
    if type _get_comp_words_by_ref >&/dev/null; then
        _get_comp_words_by_ref -n = -n @ -n : -w words -i cword;
    else
        cword="$COMP_CWORD";
        words=("${COMP_WORDS[@]}");
    fi;
    local si="$IFS";
    if ! IFS='
' COMPREPLY=($(COMP_CWORD="$cword"                            COMP_LINE="$COMP_LINE"                            COMP_POINT="$COMP_POINT"                            npm completion -- "${words[@]}"                            2>/dev/null)); then
        local ret=$?;
        IFS="$si";
        return $ret;
    fi;
    IFS="$si";
    if type __ltrim_colon_completions >&/dev/null; then
        __ltrim_colon_completions "${words[cword]}";
    fi
}
_nslookup ()
{
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    COMPREPLY=($( compgen -P '-' -W 'all class= debug d2 domain= srchlist= \
        defname search port= querytype= type= recurse retry root timeout vc \
        ignoretc' -- "$cur" ))
}
_openssl ()
{
    local cur prev commands command options formats;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    commands='asn1parse ca ciphers crl crl2pkcs7 dgst dh dhparam dsa \
        dsaparam ec ecparam enc engine errstr gendh gendsa genrsa \
        nseq ocsp passwd pkcs12 pkcs7 pkcs8 prime rand req rsa \
        rsautl s_client s_server s_time sess_id smime speed spkac \
        verify version x509 md2 md4 md5 rmd160 sha sha1 aes-128-cbc \
        aes-128-ecb aes-192-cbc aes-192-ecb aes-256-cbc aes-256-ecb \
        base64 bf bf-cbc bf-cfb bf-ecb bf-ofb camellia-128-cbc \
        camellia-128-ecb camellia-192-cbc camellia-192-ecb \
        camellia-256-cbc camellia-256-ecb cast cast-cbc cast5-cbc \
        cast5-cfb cast5-ecb cast5-ofb des des-cbc des-cfb des-ecb \
        des-ede des-ede-cbc des-ede-cfb des-ede-ofb des-ede3 \
        des-ede3-cbc des-ede3-cfb des-ede3-ofb des-ofb des3 desx rc2 \
        rc2-40-cbc rc2-64-cbc rc2-cbc rc2-cfb rc2-ecb rc2-ofb rc4 \
        rc4-40';
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($( compgen -W "$commands" -- "$cur" ));
    else
        command=${COMP_WORDS[1]};
        case $prev in
            -CA | -CAfile | -CAkey | -CAserial | -cert | -certfile | -config | -content | -dcert | -dkey | -dhparam | -extfile | -in | -inkey | -kfile | -key | -keyout | -out | -oid | -prvrify | -rand | -recip | -revoke | -sess_in | -sess_out | -spkac | -sign | -signkey | -signer | -signature | -ss_cert | -untrusted | -verify)
                _filedir;
                return 0
            ;;
            -outdir | -CApath)
                _filedir -d;
                return 0
            ;;
            -name | -crlexts | -extensions)
                _openssl_sections;
                return 0
            ;;
            -inform | -outform | -keyform | -certform | -CAform | -CAkeyform | -dkeyform | -dcertform)
                formats='DER PEM';
                case $command in
                    x509)
                        formats="$formats NET"
                    ;;
                    smime)
                        formats="$formats SMIME"
                    ;;
                esac;
                COMPREPLY=($( compgen -W "$formats" -- "$cur" ));
                return 0
            ;;
            -connect)
                _known_hosts_real "$cur";
                return 0
            ;;
            -starttls)
                COMPREPLY=($( compgen -W 'smtp pop3 imap ftp'                     -- "$cur" ));
                return 0
            ;;
            -cipher)
                COMPREPLY=($( compgen -W "$(openssl ciphers |                     tr ':' '\n')" -- "$cur" ));
                return 0
            ;;
        esac;
        if [[ "$cur" == -* ]]; then
            case $command in
                asn1parse)
                    options='-inform -in -out -noout -offset -length -i -oid \
                        -strparse'
                ;;
                ca)
                    options='-verbose -config -name -gencrl -revoke \
                        -crl_reason -crl_hold -crl_compromise \
                        -crl_CA_compromise -crldays -crlhours -crlexts \
                        -startdate -enddate -days -md -policy -keyfile -key \
                        -passin -cert -selfsig -in -out -notext -outdir \
                        -infiles -spkac -ss_cert -preserveDN -noemailDN \
                        -batch -msie_hack -extensions -extfile -engine \
                        -subj -utf8 -multivalue-rdn'
                ;;
                ciphers)
                    options='-v -ssl2 -ssl3 -tls1'
                ;;
                crl)
                    options='-inform -outform -text -in -out -noout -hash \
                        -issuer -lastupdate -nextupdate -CAfile -CApath'
                ;;
                crl2pkcs7)
                    options='-inform -outform -in -out -print_certs'
                ;;
                dgst)
                    options='-md5 -md4 -md2 -sha1 -sha -mdc2 -ripemd160 -dss1 \
                        -c -d -hex -binary -out -sign -verify -prverify \
                        -signature'
                ;;
                dsa)
                    options='-inform -outform -in -passin -out -passout -des \
                        -des3 -idea -text -noout -modulus -pubin -pubout'
                ;;
                dsaparam)
                    options='-inform -outform -in -out -noout -text -C -rand \
                        -genkey'
                ;;
                enc)
                    options='-ciphername -in -out -pass -e -d -a -A -k -kfile \
                        -S -K -iv -p -P -bufsize -debug'
                ;;
                dhparam)
                    options='-inform -outform -in -out -dsaparam -noout -text \
                        -C -2 -5 -rand'
                ;;
                gendsa)
                    options='-out -des -des3 -idea -rand'
                ;;
                genrsa)
                    options='-out -passout -des -des3 -idea -f4 -3 -rand'
                ;;
                pkcs7)
                    options='-inform -outform -in -out -print_certs -text \
                        -noout'
                ;;
                rand)
                    options='-out -rand -base64'
                ;;
                req)
                    options='-inform -outform -in -passin -out -passout -text \
                        -noout -verify -modulus -new -rand -newkey -newkey \
                        -nodes -key -keyform -keyout -md5 -sha1 -md2 -mdc2 \
                        -config -x509 -days -asn1-kludge -newhdr -extensions \
                        -reqexts section'
                ;;
                rsa)
                    options='-inform -outform -in -passin -out -passout \
                        -sgckey -des -des3 -idea -text -noout -modulus -check \
                        -pubin -pubout -engine'
                ;;
                rsautl)
                    options='-in -out -inkey -pubin -certin -sign -verify \
                        -encrypt -decrypt -pkcs -ssl -raw -hexdump -asn1parse'
                ;;
                s_client)
                    options='-connect -verify -cert -certform -key -keyform \
                        -pass -CApath -CAfile -reconnect -pause -showcerts \
                        -debug -msg -nbio_test -state -nbio -crlf -ign_eof \
                        -quiet -ssl2 -ssl3 -tls1 -no_ssl2 -no_ssl3 -no_tls1 \
                        -bugs -cipher -starttls -engine -tlsextdebug \
                        -no_ticket -sess_out -sess_in -rand'
                ;;
                s_server)
                    options='-accept -context -verify -Verify -crl_check \
                        -crl_check_all -cert -certform -key -keyform -pass \
                        -dcert -dcertform -dkey -dkeyform -dpass -dhparam \
                        -nbio -nbio_test -crlf -debug -msg -state -CApath \
                        -CAfile -nocert -cipher -quiet -no_tmp_rsa -ssl2 \
                        -ssl3 -tls1 -no_ssl2 -no_ssl3 -no_tls1 -no_dhe \
                        -bugs -hack -www -WWW -HTTP -engine -tlsextdebug \
                        -no_ticket -id_prefix -rand'
                ;;
                s_time)
                    options='-connect -www -cert -key -CApath -CAfile -reuse \
                        -new -verify -nbio -time -ssl2 -ssl3 -bugs -cipher'
                ;;
                sess_id)
                    options='-inform -outform -in -out -text -noout -context \
                        ID'
                ;;
                smime)
                    options='-encrypt -decrypt -sign -verify -pk7out -des \
                        -des3 -rc2-40 -rc2-64 -rc2-128 -aes128 -aes192 -aes256 \
                        -in -certfile -signer -recip -inform -passin -inkey \
                        -out -outform -content -to -from -subject -text -rand'
                ;;
                speed)
                    options='-engine'
                ;;
                verify)
                    options='-CApath -CAfile -purpose -untrusted -help \
                        -issuer_checks -verbose -certificates'
                ;;
                x509)
                    options='-inform -outform -keyform -CAform -CAkeyform -in \
                        -out -serial -hash -subject_hash -issuer_hash -subject \
                        -issuer -nameopt -email -startdate -enddate -purpose \
                        -dates -modulus -fingerprint -alias -noout -trustout \
                        -clrtrust -clrreject -addtrust -addreject -setalias \
                        -days -set_serial -signkey -x509toreq -req -CA -CAkey \
                        -CAcreateserial -CAserial -text -C -md2 -md5 -sha1 \
                        -mdc2 -clrext -extfile -extensions -engine'
                ;;
                md5 | md4 | md2 | sha1 | sha | mdc2 | ripemd160)
                    options='-c -d'
                ;;
            esac;
            COMPREPLY=($( compgen -W "$options" -- "$cur" ));
        else
            if [[ "$command" == speed ]]; then
                COMPREPLY=($( compgen -W 'md2 mdc2 md5 hmac sha1 rmd160 \
                    idea-cbc rc2-cbc rc5-cbc bf-cbc des-cbc des-ede3 rc4 \
                    rsa512 rsa1024 rsa2048 rsa4096 dsa512 dsa1024 dsa2048 idea \
                    rc2 des rsa blowfish' -- "$cur" ));
            else
                _filedir;
            fi;
        fi;
    fi
}
_openssl_sections ()
{
    local config f;
    for ((i=2; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" == -config ]]; then
            config=${COMP_WORDS[i+1]};
            break;
        fi;
    done;
    if [ -z "$config" ]; then
        for f in /etc/ssl/openssl.cnf /etc/pki/tls/openssl.cnf /usr/share/ssl/openssl.cnf;
        do
            [ -f $f ] && config=$f && break;
        done;
    fi;
    [ ! -f "$config" ] && return 0;
    COMPREPLY=($( compgen -W "$( awk '/\[.*\]/ {print $2}' $config )"         -- "$cur" ))
}
_pack200 ()
{
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    case $prev in
        -S | --segment-limit | -P | --pass-file | -C | --class-attribute | -F | --field-attribute | -M | --method-attribute | -D | --code-attribute | '-?' | -h | --help | -V | --version | -J)
            return 0
        ;;
        -E | --effort)
            COMPREPLY=($( compgen -W '0 1 2 3 4 5 6 7 8 9' -- "$cur" ));
            return 0
        ;;
        -H | --deflate-hint)
            COMPREPLY=($( compgen -W 'true false keep' -- "$cur" ));
            return 0
        ;;
        -m | --modification-time)
            COMPREPLY=($( compgen -W 'latest keep' -- "$cur" ));
            return 0
        ;;
        -U | --unknown-attribute)
            COMPREPLY=($( compgen -W 'error strip pass' -- "$cur" ));
            return 0
        ;;
        -f | --config-file)
            _filedir properties;
            return 0
        ;;
        -l | --log-file)
            COMPREPLY=($( compgen -W '-' -- "$cur" ));
            _filedir log;
            return 0
        ;;
        -r | --repack)
            _filedir jar;
            return 0
        ;;
    esac;
    local i pack=false jar=false;
    for ((i=0; i < ${#COMP_WORDS[@]}-1; i++ ))
    do
        case ${COMP_WORDS[i]} in
            *.pack | *.pack.gz)
                pack=true
            ;;
            *.jar)
                jar=true
            ;;
        esac;
    done;
    if ! $pack; then
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '--no-gzip --gzip --strip-debug \
                --no-keep-file-order --segment-limit= --effort= \
                --deflate-hint= --modification-time= --pass-file= \
                --unknown-attribute= --class-attribute= --field-attribute= \
                --method-attribute= --code-attribute= --config-file= \
                --verbose --quiet --log-file= --help --version -J \
                --repack' -- "$cur" ));
            [[ ${#COMPREPLY[@]} -eq 1 && ${COMPREPLY[0]} == *= ]] && type compopt >&/dev/null && compopt -o nospace;
        else
            _filedir 'pack?(.gz)';
        fi;
    else
        if ! $jar; then
            _filedir jar;
        fi;
    fi
}
_parse_help ()
{
    $1 ${2:---help} 2>&1 | sed -e '/^[[:space:]]*-/!d' -e 's|[,/]| |g' | awk '{ print $1; if ($2 ~ /^-/) { print $2 } }' | sed -e 's|[<=].*||'
}
_passwd ()
{
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in
        -n | -x | -w | -i | -\? | --help | --usage)
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-k -l --stdin -u -d -n -x -w -i -S \
            -? --help --usage' -- "$cur" ));
        return 0;
    fi;
    _allowed_users
}
_pci_ids ()
{
    COMPREPLY=(${COMPREPLY[@]:-} $( compgen -W         "$( PATH="$PATH:/sbin" lspci -n | awk '{print $3}')" -- "$cur" ))
}
_perl ()
{
    local cur prev prefix temp;
    local optPrefix optSuffix;
    COMPREPLY=();
    _get_comp_words_by_ref -n : cur prev;
    prefix="";
    if [[ "$cur" == -?* ]]; then
        temp=$cur;
        prev=${temp:0:2};
        cur=${temp:2};
        optPrefix=-P$prev;
        optSuffix=-S/;
        prefix=$prev;
    fi;
    case $prev in
        -D | -e | -E | -i | -F | -l)
            return 0
        ;;
        -I | -x)
            local IFS='
';
            _compopt_o_filenames;
            COMPREPLY=($( compgen -d $optPrefix $optSuffix -- "$cur" ));
            return 0
        ;;
        -m | -M)
            temp="${cur#-}";
            prefix="$prefix${cur%$temp}";
            cur="$temp";
            _perlmodules $1;
            return 0
        ;;
        -V)
            if [[ $cur == :* ]]; then
                temp="${cur##+(:)}";
                prefix="$prefix${cur%$temp}";
                local IFS='
';
                COMPREPLY=($( compgen -P "$prefix" -W                     '$( $1 -MConfig -e "print join \"\\n\",
                        keys %Config::Config" 2>/dev/null )' -- "$temp" ));
                __ltrim_colon_completions "$prefix$temp";
            fi;
            return 0
        ;;
        -d | -dt)
            if [[ $cur == :* ]]; then
                temp="${cur#:}";
                prefix="$prefix${cur%$temp}";
                cur="Devel::$temp";
                _perlmodules $1;
            fi;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-C -s -T -u -U -W -X -h -v -V -c -w -d \
            -D -p -n -a -F -l -0 -I -m -M -P -S -x -i -e ' -- "$cur" ));
    else
        _filedir;
    fi
}
_perldoc ()
{
    local cur prev prefix temp;
    COMPREPLY=();
    _get_comp_words_by_ref -n : cur prev;
    prefix="";
    if [[ "$cur" == -?* ]]; then
        temp=$cur;
        prev=${temp:0:2};
        cur=${temp:2};
        prefix=$prev;
    fi;
    case $prev in
        -f)
            _perlfunctions "$cur";
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-h -v -t -u -m -l -F -X -f -q' -- "$cur" ));
    else
        if [[ "$cur" != */* ]]; then
            _perlmodules;
            COMPREPLY=("${COMPREPLY[@]}" $( compgen -W                 '$( PAGER=/bin/cat man perl |  \
                sed -ne "/perl.*Perl overview/,/perlwin32/p" | \
                awk "\$NF=2 { print \$1}" | command grep perl )' -- "$cur" ));
        fi;
        _filedir 'p@(l|m|od)';
    fi
}
_perlfunctions ()
{
    COMPREPLY=($( compgen -P "$prefix" -W "$( ${BASH_SOURCE[0]%/*}/helpers/perl functions $cur )" -- "$cur" ))
}
_perlmodules ()
{
    COMPREPLY=($( compgen -P "$prefix" -W "$( $1 ${BASH_SOURCE[0]%/*}/helpers/perl modules $cur )" -- "$cur" ));
    __ltrim_colon_completions "$prefix$cur"
}
_pgids ()
{
    COMPREPLY=($( compgen -W '$( command ps axo pgid= )' -- "$cur" ))
}
_pgrep ()
{
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    _pnames;
    return 0
}
_pids ()
{
    COMPREPLY=($( compgen -W '$( command ps axo pid= )' -- "$cur" ))
}
_pnames ()
{
    COMPREPLY=($( compgen -X '<defunct>' -W '$( command ps axo command= | \
        sed -e "s/ .*//" -e "s:.*/::" -e "s/:$//" -e "s/^[[(-]//" \
            -e "s/[])]$//" | sort -u )' -- "$cur" ))
}
_postcat ()
{
    local cur prev pval len idx qfile;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in
        -c)
            _filedir -d;
            return 0
        ;;
    esac;
    if [[ $cur == -* ]]; then
        COMPREPLY=($( compgen -W '-c -q -v' -- "$cur" ));
        return 0;
    fi;
    qfile=0;
    for idx in "${COMP_WORDS[@]}";
    do
        [[ "$idx" = -q ]] && qfile=1 && break;
    done;
    if [[ $qfile == 1 ]]; then
        len=${#cur};
        idx=0;
        for pval in $( mailq 2>/dev/null |             sed -e '1d; $d; /^[^0-9A-Z]/d; /^$/d; s/[* !].*$//' );
        do
            if [[ "$cur" == "${pval:0:$len}" ]]; then
                COMPREPLY[$idx]=$pval;
                idx=$(($idx+1));
            fi;
        done;
        return 0;
    else
        _filedir;
        return 0;
    fi
}
_postconf ()
{
    local cur prev pval len idx eqext;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in
        -b | -t)
            _filedir;
            return 0
        ;;
        -c)
            _filedir -d;
            return 0
        ;;
        -e)
            cur=${cur#[\"\']};
            eqext='='
        ;;
    esac;
    if [[ $cur == -* ]]; then
        COMPREPLY=($( compgen -W '-A -a -b -c -d -e -h -m -l -n -t -v'             -- "$cur" ));
        return 0;
    fi;
    len=${#cur};
    idx=0;
    for pval in $( /usr/sbin/postconf 2>/dev/null | cut -d ' ' -f 1 );
    do
        if [[ "$cur" == "${pval:0:$len}" ]]; then
            COMPREPLY[$idx]="$pval$eqext";
            idx=$(($idx+1));
        fi;
    done;
    return 0
}
_postfix ()
{
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in
        -c)
            _filedir -d;
            return 0
        ;;
        -D)
            COMPREPLY=($( compgen -W 'start' -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ $cur == -* ]]; then
        COMPREPLY=($( compgen -W '-c -D -v' -- "$cur" ));
        return 0;
    fi;
    COMPREPLY=($( compgen -W 'check start stop abort flush reload status \
        set-permissions upgrade-configuration' -- "$cur" ))
}
_postmap ()
{
    local cur prev len idx;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in
        -c)
            _filedir -d;
            return 0
        ;;
        -[dq])
            return 0
        ;;
    esac;
    if [[ $cur == -* ]]; then
        COMPREPLY=($( compgen -W '-N -f -i -n -o -p -r -v -w -c -d -q'             -- "$cur" ));
        return 0;
    fi;
    if [[ "$cur" == *:* ]]; then
        _compopt_o_filenames;
        COMPREPLY=($( compgen -f -- "${cur#*:}" ));
    else
        len=${#cur};
        idx=0;
        for pval in $( /usr/sbin/postconf -m );
        do
            if [[ "$cur" == "${pval:0:$len}" ]]; then
                COMPREPLY[$idx]="$pval:";
                idx=$(($idx+1));
            fi;
        done;
        if [[ $idx -eq 0 ]]; then
            _compopt_o_filenames;
            COMPREPLY=($( compgen -f -- "$cur" ));
        fi;
    fi;
    return 0
}
_postsuper ()
{
    local cur prev pval len idx;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in
        -c)
            _filedir -d;
            return 0
        ;;
        -[dr])
            len=${#cur};
            idx=0;
            for pval in ALL $( mailq 2>/dev/null |                 sed -e '1d; $d; /^[^0-9A-Z]/d; /^$/d; s/[* !].*$//' );
            do
                if [[ "$cur" == "${pval:0:$len}" ]]; then
                    COMPREPLY[$idx]=$pval;
                    idx=$(($idx+1));
                fi;
            done;
            return 0
        ;;
        -h)
            len=${#cur};
            idx=0;
            for pval in ALL $( mailq 2>/dev/null |                 sed -e '1d; $d; /^[^0-9A-Z]/d; /^$/d; s/[* ].*$//; /!$/d' );
            do
                if [[ "$cur" == "${pval:0:$len}" ]]; then
                    COMPREPLY[$idx]=$pval;
                    idx=$(($idx+1));
                fi;
            done;
            return 0
        ;;
        -H)
            len=${#cur};
            idx=0;
            for pval in ALL $( mailq 2>/dev/null |                 sed -e '1d; $d; /^[^0-9A-Z]/d; /^$/d; /^[0-9A-Z]*[* ]/d; s/!.*$//' );
            do
                if [[ "$cur" == "${pval:0:$len}" ]]; then
                    COMPREPLY[$idx]=$pval;
                    idx=$(($idx+1));
                fi;
            done;
            return 0
        ;;
    esac;
    if [[ $cur == -* ]]; then
        COMPREPLY=($( compgen -W '-c -d -h -H -p -r -s -v' -- "$cur" ));
        return 0;
    fi;
    COMPREPLY=($( compgen -W 'hold incoming active deferred' -- "$cur" ))
}
_python ()
{
    local prev cur i;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in
        -'?' | -h | --help | -V | --version | -c | -m)
            return 0
        ;;
        -Q)
            COMPREPLY=($( compgen -W "old new warn warnall" -- "$cur" ));
            return 0
        ;;
        -W)
            COMPREPLY=($( compgen -W "ignore default all module once error"                 -- "$cur" ));
            return 0
        ;;
        !(?(*/)python*([0-9.])|-?))
            [[ $COMP_CWORD -lt 2 || ${COMP_WORDS[COMP_CWORD-2]} != -@(Q|W) ]] && _filedir
        ;;
    esac;
    for ((i=0; i < ${#COMP_WORDS[@]}-1; i++ ))
    do
        if [[ ${COMP_WORDS[i]} == -c ]]; then
            _filedir;
        fi;
    done;
    if [[ "$cur" != -* ]]; then
        _filedir 'py?([co])';
    else
        COMPREPLY=($( compgen -W "$( _parse_help $1 -h )" -- "$cur" ));
    fi;
    return 0
}
_quota ()
{
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in
        -F | --format)
            _quota_formats;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-F --format -g --group -u --user -v \
            --verbose -s --human-readable -p --raw-grace -i --no-autofs -l \
            --local-only -A --all-nfs -m --no-mixed-pathnames -q --quiet -Q \
            --quiet-refuse -w --no-wrap' -- "$cur" ));
    else
        _user_or_group;
    fi
}
_quota_formats ()
{
    COMPREPLY=($( compgen -W 'vfsold vfsv0 rpc xfs' -- "$cur" ))
}
_quotacheck ()
{
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in
        -F | --format)
            _quota_formats;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-b --backup -v --verbose -d --debug \
            -g --group -u --user -c --create-files -f --force -i \
            --interactive -n --use-first-dquot -M --try-remount -m \
            --no-remount -R --exclude-root -F --format -a --all' -- "$cur" ));
    else
        _filesystems;
    fi
}
_quotaoff ()
{
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in
        -F | --format)
            _quota_formats;
            return 0
        ;;
        -x | --xfs-command)
            COMPREPLY=($( compgen -W 'delete enforce' -- "$cur" ));
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-a --all -v --verbose -u --user \
            -g --group -p --print-state -x --xfs-command -F --format'             -- "$cur" ));
    else
        _filesystems;
    fi
}
_quotaon ()
{
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in
        -F | --format)
            _quota_formats;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-a --all -v --verbose -u --user \
            -g --group -f --off -p --print-state -F --format' -- "$cur" ));
    else
        _filesystems;
    fi
}
_quote_readline_by_ref ()
{
    if [[ ${1:0:1} == "'" ]]; then
        if [[ ${BASH_VERSINFO[0]} -ge 4 ]]; then
            printf -v $2 %s "${1:1}";
        else
            printf -v $2 %q "${1:1}";
            printf -v $2 %q ${!2};
        fi;
    else
        if [[ ${BASH_VERSINFO[0]} -le 3 && ${1:0:1} == '"' ]]; then
            printf -v $2 %q "${1:1}";
        else
            printf -v $2 %q "$1";
        fi;
    fi;
    [[ ${!2:0:1} == '$' ]] && eval $2=${!2}
}
_realcommand ()
{
    type -P "$1" > /dev/null && {
        if type -p realpath > /dev/null; then
            realpath "$(type -P "$1")";
        else
            if type -p readlink > /dev/null; then
                readlink "$(type -P "$1")";
            else
                type -P "$1";
            fi;
        fi
    }
}
_renice ()
{
    local command cur curopt i;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    command=$1;
    i=0;
    while [[ $i -le $COMP_CWORD && ${#COMPREPLY[@]} -eq 0 ]]; do
        curopt=${COMP_WORDS[COMP_CWORD-$i]};
        case "$curopt" in
            -u)
                _allowed_users
            ;;
            -g)
                _pgids
            ;;
            -p | $command)
                _pids
            ;;
        esac;
        i=$(( ++i ));
    done
}
_reply_compgen_array ()
{
    local i wlist;
    for i in ${!COMPREPLY[*]};
    do
        local q=$(quote "$(printf %q "${COMPREPLY[$i]}")");
        wlist+=$q'
';
    done;
    local ecur="$cur";
    ecur="${ecur//\\/\\\\}";
    ecur="${ecur//\'/\'}";
    local oldifs=$IFS;
    IFS='
' eval 'COMPREPLY=(`compgen -W "$wlist" -- "${ecur}"`)';
    IFS=$oldifs
}
_repquota ()
{
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in
        -F | --format)
            _quota_formats;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-a --all -v --verbose -s --human-readable \
            -c --batch-translation -C --no-batch-translation -t \
            --truncate-names -n --no-names -p --raw-grace -i --no-autofs \
            -u --user -g --group -F --format' -- "$cur" ));
    else
        _filesystems;
    fi
}
_ri ()
{
    local cur class method prefix ri_path ri_version separator IFS;
    local -a classes;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    ri_path=$(type -p ri);
    ri_version="$(ruby -W0 $ri_path -v 2>&1)" || ri_version=integrated;
    [ "$ri_version" != "${ri_version%200*}" ] && ri_version=integrated;
    IFS=',
	';
    if [[ "$cur" == [A-Z]*[#.]* ]]; then
        [[ "$cur" == *#* ]] && separator=# || separator=.;
        class=${cur%$separator*};
        method=${cur#*$separator};
        classes=($class);
        prefix="-P $class$separator";
        ri_get_methods;
        return 0;
    fi;
    if [ "$ri_version" = integrated ]; then
        classes=($( ri -c | ruby -ne 'if /^\s*$/..$stdin.eof then \
        if /, [A-Z]+/ then print; end; end' ));
    else
        if [ "$ri_version" = "ri 1.8a" ]; then
            classes=($( ruby -W0 $ri_path |             ruby -ne 'if /^'"'"'ri'"'"' has/..$stdin.eof then \
            if /^ .*[A-Z]/ then print; end; end' ));
        else
            classes=($( ruby -W0 $ri_path |             ruby -ne 'if /^I have/..$stdin.eof then \
                if /^ .*[A-Z]/ then print; end; end' ));
        fi;
    fi;
    COMPREPLY=($( compgen -W '${classes[@]}' -- "$cur" ));
    if [[ "$cur" == [A-Z]* ]]; then
        return 0;
    fi;
    method=$cur;
    ri_get_methods
}
_rl_enabled ()
{
    [[ "$( bind -v )" = *$1+([[:space:]])on* ]]
}
_root_command ()
{
    local PATH=$PATH:/sbin:/usr/sbin:/usr/local/sbin;
    local root_command=$1;
    _command $1 $2 $3
}
_rsync ()
{
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref -n : cur prev;
    _expand || return 0;
    case $prev in
        --config | --password-file | --include-from | --exclude-from)
            _filedir;
            return 0
        ;;
        -T | --temp-dir | --compare-dest)
            _filedir -d;
            return 0
        ;;
        -e | --rsh)
            COMPREPLY=($( compgen -W 'rsh ssh' -- "$cur" ));
            return 0
        ;;
        --compress-level)
            COMPREPLY=($( compgen -W '1 2 3 4 5 6 7 8 9' -- "$cur" ));
            return 0
        ;;
    esac;
    case $cur in
        -*)
            COMPREPLY=($( compgen -W '--verbose --quiet --no-motd --checksum \
                --archive --recursive --relative --no-implied-dirs \
                --backup --backup-dir --suffix= --update --inplace --append \
                --append-verify --dirs --old-dirs --links --copy-links \
                --copy-unsafe-links --safe-links --copy-dirlinks \
                --keep-dirlinks --hard-links --perms --executability --chmod= \
                --acls --xattrs --owner --group --devices --copy-devices \
                --specials --times --omit-dir-times --super --fake-super \
                --sparse --dry-run --whole-file --no-whole-file \
                --one-file-system --block-size= --rsh= --rsync-path= \
                --existing --ignore-existing --remove-source-files --delete \
                --delete-before --delete-during --delete-delay --delete-after \
                --delete-excluded --ignore-errors --force --max-delete= \
                --max-size= --min-size= --partial --partial-dir= \
                --delay-updates --prune-empty-dirs --numeric-ids --timeout= \
                --contimeout= --ignore-times --size-only --modify-window= \
                --temp-dir= --fuzzy --compare-dest= --copy-dest= --link-dest= \
                --compress --compress-level= --skip-compress= --cvs-exclude \
                --filter= --exclude= --exclude-from= --include= \
                --include-from= --files-from= --from0 --protect-args \
                --address= --port= --sockopts= --blocking-io --no-blocking-io \
                --stats --8-bit-output --human-readable --progress \
                --itemize-changes --out-format= --log-file= \
                --log-file-format= --password-file= --list-only --bwlimit= \
                --write-batch= --only-write-batch= --read-batch= --protocol= \
                --iconv= --ipv4 --ipv6 --version --help --daemon --config= \
                --no-detach' -- "$cur" ))
        ;;
        *:*)
            if type _scp_remote_files >&/dev/null; then
                local i shell=ssh;
                for ((i=1; i < COMP_CWORD; i++ ))
                do
                    if [[ "${COMP_WORDS[i]}" == -@(e|-rsh) ]]; then
                        shell=${COMP_WORDS[i+1]};
                        break;
                    fi;
                done;
                [ "$shell" = ssh ] && _scp_remote_files;
            fi
        ;;
        *)
            _known_hosts_real -c -a "$cur";
            type _scp_local_files >&/dev/null && _scp_local_files || _filedir
        ;;
    esac;
    return 0
}
_s_root_command ()
{
    last_command="s";
    command_aliases=();
    commands=();
    flags=();
    two_word_flags=();
    local_nonpersistent_flags=();
    flags_with_completion=();
    flags_completion=();
    flags+=("--binary=");
    two_word_flags+=("--binary");
    two_word_flags+=("-b");
    flags+=("--cert=");
    two_word_flags+=("--cert");
    two_word_flags+=("-c");
    flags+=("--completion=");
    two_word_flags+=("--completion");
    flags_with_completion+=("--completion");
    flags_completion+=("__s_handle_go_custom_completion");
    flags+=("--help");
    flags+=("-h");
    local_nonpersistent_flags+=("--help");
    local_nonpersistent_flags+=("-h");
    flags+=("--key=");
    two_word_flags+=("--key");
    two_word_flags+=("-k");
    flags+=("--list-providers");
    flags+=("-l");
    flags+=("--list-tags");
    flags+=("--output");
    flags+=("-o");
    flags+=("--port=");
    two_word_flags+=("--port");
    flags+=("--provider=");
    two_word_flags+=("--provider");
    flags_with_completion+=("--provider");
    flags_completion+=("__s_handle_go_custom_completion");
    two_word_flags+=("-p");
    flags_with_completion+=("-p");
    flags_completion+=("__s_handle_go_custom_completion");
    flags+=("--server");
    flags+=("-s");
    flags+=("--tag=");
    two_word_flags+=("--tag");
    flags_with_completion+=("--tag");
    flags_completion+=("__s_handle_go_custom_completion");
    two_word_flags+=("-t");
    flags_with_completion+=("-t");
    flags_completion+=("__s_handle_go_custom_completion");
    flags+=("--verbose");
    flags+=("-v");
    flags+=("--version");
    must_have_one_flag=();
    must_have_one_noun=();
    noun_aliases=()
}
_scp ()
{
    local configfile cur prev prefix;
    COMPREPLY=();
    _get_comp_words_by_ref -n : cur prev;
    _ssh_suboption_check && {
        COMPREPLY=("${COMPREPLY[@]/%/ }");
        return 0
    };
    case $prev in
        -l | -P)
            return 0
        ;;
        -F | -i | -S)
            _filedir;
            type compopt >&/dev/null && compopt +o nospace;
            return 0
        ;;
        -c)
            _ssh_ciphers;
            COMPREPLY=("${COMPREPLY[@]/%/ }");
            return 0
        ;;
        -o)
            _ssh_options;
            return 0
        ;;
    esac;
    _expand || return 0;
    if [[ "$cur" == *:* ]]; then
        _scp_remote_files;
        return 0;
    fi;
    if [[ "$cur" == -F* ]]; then
        cur=${cur#-F};
        prefix=-F;
    else
        set -- "${COMP_WORDS[@]}";
        while [ $# -gt 0 ]; do
            if [ "${1:0:2}" = -F ]; then
                if [ ${#1} -gt 2 ]; then
                    configfile="$(dequote "${1:2}")";
                else
                    shift;
                    [ "$1" ] && configfile="$(dequote "$1")";
                fi;
                break;
            fi;
            shift;
        done;
        case $cur in
            -*)
                COMPREPLY=($( compgen -W '-1 -2 -4 -6 -B -C -c -F -i -l -o \
                    -P -p -q -r -S -v' -- "$cur" ));
                COMPREPLY=("${COMPREPLY[@]/%/ }");
                return 0
            ;;
            */*)

            ;;
            *)
                _known_hosts_real -c -a -F "$configfile" "$cur"
            ;;
        esac;
    fi;
    _scp_local_files "$prefix";
    return 0
}
_scp_local_files ()
{
    local IFS='
';
    local dirsonly=false;
    if [ "$1" = -d ]; then
        dirsonly=true;
        shift;
    fi;
    if $dirsonly; then
        COMPREPLY=("${COMPREPLY[@]}" $( command ls -aF1d $cur* 2>/dev/null |             sed -e "s/$_scp_path_esc/\\\\&/g" -e '/[^\/]$/d' -e "s/^/$1/"));
    else
        COMPREPLY=("${COMPREPLY[@]}" $( command ls -aF1d $cur* 2>/dev/null |             sed -e "s/$_scp_path_esc/\\\\&/g" -e 's/[*@|=]$//g'             -e 's/[^\/]$/& /g' -e "s/^/$1/"));
    fi
}
_scp_remote_files ()
{
    local IFS='
';
    cur=${cur/\\:/:};
    local userhost=${cur%%?(\\):*};
    local path=${cur#*:};
    path=$( sed -e 's/\\\\\\\('$_scp_path_esc'\)/\\\1/g' <<<"$path" );
    if [ -z "$path" ]; then
        path=$(ssh -o 'Batchmode yes' $userhost pwd 2>/dev/null);
    fi;
    local files;
    if [ "$1" = -d ]; then
        files=$( ssh -o 'Batchmode yes' $userhost             command ls -aF1d "$path*" 2>/dev/null |             sed -e 's/'$_scp_path_esc'/\\\\\\&/g' -e '/[^\/]$/d' );
    else
        files=$( ssh -o 'Batchmode yes' $userhost             command ls -aF1d "$path*" 2>/dev/null |             sed -e 's/'$_scp_path_esc'/\\\\\\&/g' -e 's/[*@|=]$//g'             -e 's/[^\/]$/& /g' );
    fi;
    COMPREPLY=("${COMPREPLY[@]}" $files)
}
_screen ()
{
    local cur prev words cword;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev words cword;
    if ((cword > 2)); then
        case ${words[cword-2]} in
            -[dD])
                _screen_sessions;
                return 0
            ;;
        esac;
    fi;
    case $prev in
        -[rR])
            _screen_sessions 'Detached';
            return 0
        ;;
        -[dD])
            _screen_sessions 'Attached';
            return 0
        ;;
        -x)
            _screen_sessions;
            return 0
        ;;
        -s)
            _shells;
            return 0
        ;;
        -c)
            _filedir;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-a -A -c -d -D -e -f -fn -fa -h -i -ln \
            -list -L -m -O -p -q -r -R -s -S -t -U -v -wipe -x -X --help \
            --version' -- "$cur" ));
    fi
}
_screen_sessions ()
{
    COMPREPLY=($( compgen -W "$( command screen -ls | sed -ne         's|^\t\{1,\}\([0-9]\{1,\}\.[^\t]\{1,\}\).*'"$1"'.*$|\1|p' )"         -- "$cur" ))
}
_services ()
{
    local sysvdir famdir;
    [ -d /etc/rc.d/init.d ] && sysvdir=/etc/rc.d/init.d || sysvdir=/etc/init.d;
    famdir=/etc/xinetd.d;
    COMPREPLY=($( printf '%s\n'         $sysvdir/!(*.rpm@(orig|new|save)|*~|functions) ));
    if [ -d $famdir ]; then
        COMPREPLY=("${COMPREPLY[@]}" $( printf '%s\n'             $famdir/!(*.rpm@(orig|new|save)|*~) ));
    fi;
    COMPREPLY=($( compgen -W '${COMPREPLY[@]#@($sysvdir|$famdir)/}' -- "$cur" ))
}
_setquota ()
{
    local cur prev split=false;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _split_longopt && split=true;
    case $prev in
        -F | --format)
            _quota_formats;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-r --remote -m --no-mixed-pathnames \
            -F --format -g --group -u --user -p --prototype -b --batch \
            -c --continue-batch -t --edit-period -T --edit-times -a --all'             -- "$cur" ));
    else
        _count_args;
        case $args in
            1)
                _user_or_group
            ;;
            2)
                _filesystems
            ;;
        esac;
    fi
}
_sftp ()
{
    local cur prev configfile;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    _ssh_suboption_check && return 0;
    case $prev in
        -b | -F | -P)
            _filedir;
            return 0
        ;;
        -o)
            _ssh_options;
            return 0
        ;;
    esac;
    if [[ "$cur" == -F* ]]; then
        cur=${cur#-F};
        _filedir;
        COMPREPLY=("${COMPREPLY[@]/#/-F}");
        cur=-F$cur;
    else
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '-1 -C -v -B -b -F -o -P -R -S -s'             -- "$cur" ));
        else
            set -- "${COMP_WORDS[@]}";
            while [ $# -gt 0 ]; do
                if [ "${1:0:2}" = -F ]; then
                    if [ ${#1} -gt 2 ]; then
                        configfile="$(dequote "${1:2}")";
                    else
                        shift;
                        [ "$1" ] && configfile="$(dequote "$1")";
                    fi;
                    break;
                fi;
                shift;
            done;
            _known_hosts_real -a -F "$configfile" "$cur";
        fi;
    fi;
    return 0
}
_sh ()
{
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    case $prev in
        -c)
            return 0
        ;;
        -o | +o)
            COMPREPLY=($( compgen -W 'allexport errexit ignoreeof monitor
                noclobber noglob noexec nolog notify nounset verbose vi
                xtrace' -- "$cur" ));
            return 0
        ;;
    esac;
    local opts="-a -b -C -e -f -h -i -m -n -o -u -v -x";
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W "$opts -c -s" -- "$cur" ));
        return 0;
    else
        if [[ "$cur" == +* ]]; then
            COMPREPLY=($( compgen -W "${opts//-/+}" -- "$cur" ));
            return 0;
        fi;
    fi;
    _filedir sh
}
_shells ()
{
    COMPREPLY=("${COMPREPLY[@]}" $( compgen -W         '$( command grep "^[[:space:]]*/" /etc/shells 2>/dev/null )'         -- "$cur" ))
}
_signals ()
{
    local i;
    COMPREPLY=($( compgen -A signal SIG${cur#-} ));
    for ((i=0; i < ${#COMPREPLY[@]}; i++ ))
    do
        COMPREPLY[i]=-${COMPREPLY[i]#SIG};
    done
}
_split_longopt ()
{
    if [[ "$cur" == --?*=* ]]; then
        prev="${cur%%?(\\)=*}";
        cur="${cur#*=}";
        return 0;
    fi;
    return 1
}
_sq_add ()
{
    last_command="sq_add";
    command_aliases=();
    commands=();
    flags=();
    two_word_flags=();
    local_nonpersistent_flags=();
    flags_with_completion=();
    flags_completion=();
    flags+=("--driver=");
    two_word_flags+=("--driver");
    flags_with_completion+=("--driver");
    flags_completion+=("__sq_handle_go_custom_completion");
    two_word_flags+=("-d");
    flags_with_completion+=("-d");
    flags_completion+=("__sq_handle_go_custom_completion");
    local_nonpersistent_flags+=("--driver");
    local_nonpersistent_flags+=("--driver=");
    local_nonpersistent_flags+=("-d");
    flags+=("--opts=");
    two_word_flags+=("--opts");
    local_nonpersistent_flags+=("--opts");
    local_nonpersistent_flags+=("--opts=");
    flags+=("--handle=");
    two_word_flags+=("--handle");
    two_word_flags+=("-h");
    local_nonpersistent_flags+=("--handle");
    local_nonpersistent_flags+=("--handle=");
    local_nonpersistent_flags+=("-h");
    flags+=("--password");
    flags+=("-p");
    local_nonpersistent_flags+=("--password");
    local_nonpersistent_flags+=("-p");
    flags+=("--skip-verify");
    local_nonpersistent_flags+=("--skip-verify");
    flags+=("--json");
    flags+=("-j");
    local_nonpersistent_flags+=("--json");
    local_nonpersistent_flags+=("-j");
    flags+=("--active");
    flags+=("-a");
    local_nonpersistent_flags+=("--active");
    local_nonpersistent_flags+=("-a");
    flags+=("--help");
    local_nonpersistent_flags+=("--help");
    flags+=("--monochrome");
    flags+=("-M");
    flags+=("--verbose");
    flags+=("-v");
    must_have_one_flag=();
    must_have_one_noun=();
    noun_aliases=()
}
_sq_completion ()
{
    last_command="sq_completion";
    command_aliases=();
    commands=();
    flags=();
    two_word_flags=();
    local_nonpersistent_flags=();
    flags_with_completion=();
    flags_completion=();
    flags+=("--help");
    local_nonpersistent_flags+=("--help");
    flags+=("--monochrome");
    flags+=("-M");
    flags+=("--verbose");
    flags+=("-v");
    must_have_one_flag=();
    must_have_one_noun=();
    must_have_one_noun+=("bash");
    must_have_one_noun+=("fish");
    must_have_one_noun+=("powershell");
    must_have_one_noun+=("zsh");
    noun_aliases=()
}
_sq_driver ()
{
    last_command="sq_driver";
    command_aliases=();
    commands=();
    commands+=("ls");
    flags=();
    two_word_flags=();
    local_nonpersistent_flags=();
    flags_with_completion=();
    flags_completion=();
    flags+=("--help");
    local_nonpersistent_flags+=("--help");
    flags+=("--monochrome");
    flags+=("-M");
    flags+=("--verbose");
    flags+=("-v");
    must_have_one_flag=();
    must_have_one_noun=();
    noun_aliases=()
}
_sq_driver_ls ()
{
    last_command="sq_driver_ls";
    command_aliases=();
    commands=();
    flags=();
    two_word_flags=();
    local_nonpersistent_flags=();
    flags_with_completion=();
    flags_completion=();
    flags+=("--json");
    flags+=("-j");
    local_nonpersistent_flags+=("--json");
    local_nonpersistent_flags+=("-j");
    flags+=("--table");
    flags+=("-t");
    local_nonpersistent_flags+=("--table");
    local_nonpersistent_flags+=("-t");
    flags+=("--header");
    flags+=("-h");
    local_nonpersistent_flags+=("--header");
    local_nonpersistent_flags+=("-h");
    flags+=("--help");
    local_nonpersistent_flags+=("--help");
    flags+=("--monochrome");
    flags+=("-M");
    flags+=("--verbose");
    flags+=("-v");
    must_have_one_flag=();
    must_have_one_noun=();
    noun_aliases=()
}
_sq_help ()
{
    last_command="sq_help";
    command_aliases=();
    commands=();
    flags=();
    two_word_flags=();
    local_nonpersistent_flags=();
    flags_with_completion=();
    flags_completion=();
    flags+=("--monochrome");
    flags+=("-M");
    flags+=("--verbose");
    flags+=("-v");
    must_have_one_flag=();
    must_have_one_noun=();
    noun_aliases=()
}
_sq_inspect ()
{
    last_command="sq_inspect";
    command_aliases=();
    commands=();
    flags=();
    two_word_flags=();
    local_nonpersistent_flags=();
    flags_with_completion=();
    flags_completion=();
    flags+=("--json");
    flags+=("-j");
    local_nonpersistent_flags+=("--json");
    local_nonpersistent_flags+=("-j");
    flags+=("--table");
    flags+=("-t");
    local_nonpersistent_flags+=("--table");
    local_nonpersistent_flags+=("-t");
    flags+=("--help");
    local_nonpersistent_flags+=("--help");
    flags+=("--monochrome");
    flags+=("-M");
    flags+=("--verbose");
    flags+=("-v");
    must_have_one_flag=();
    must_have_one_noun=();
    has_completion_function=1;
    noun_aliases=()
}
_sq_ls ()
{
    last_command="sq_ls";
    command_aliases=();
    commands=();
    flags=();
    two_word_flags=();
    local_nonpersistent_flags=();
    flags_with_completion=();
    flags_completion=();
    flags+=("--header");
    flags+=("-h");
    local_nonpersistent_flags+=("--header");
    local_nonpersistent_flags+=("-h");
    flags+=("--json");
    flags+=("-j");
    local_nonpersistent_flags+=("--json");
    local_nonpersistent_flags+=("-j");
    flags+=("--help");
    local_nonpersistent_flags+=("--help");
    flags+=("--monochrome");
    flags+=("-M");
    flags+=("--verbose");
    flags+=("-v");
    must_have_one_flag=();
    must_have_one_noun=();
    noun_aliases=()
}
_sq_ping ()
{
    last_command="sq_ping";
    command_aliases=();
    commands=();
    flags=();
    two_word_flags=();
    local_nonpersistent_flags=();
    flags_with_completion=();
    flags_completion=();
    flags+=("--table");
    flags+=("-t");
    local_nonpersistent_flags+=("--table");
    local_nonpersistent_flags+=("-t");
    flags+=("--csv");
    flags+=("-c");
    local_nonpersistent_flags+=("--csv");
    local_nonpersistent_flags+=("-c");
    flags+=("--tsv");
    flags+=("-T");
    local_nonpersistent_flags+=("--tsv");
    local_nonpersistent_flags+=("-T");
    flags+=("--json");
    flags+=("-j");
    local_nonpersistent_flags+=("--json");
    local_nonpersistent_flags+=("-j");
    flags+=("--timeout=");
    two_word_flags+=("--timeout");
    local_nonpersistent_flags+=("--timeout");
    local_nonpersistent_flags+=("--timeout=");
    flags+=("--all");
    flags+=("-a");
    local_nonpersistent_flags+=("--all");
    local_nonpersistent_flags+=("-a");
    flags+=("--help");
    local_nonpersistent_flags+=("--help");
    flags+=("--monochrome");
    flags+=("-M");
    flags+=("--verbose");
    flags+=("-v");
    must_have_one_flag=();
    must_have_one_noun=();
    has_completion_function=1;
    noun_aliases=()
}
_sq_rm ()
{
    last_command="sq_rm";
    command_aliases=();
    commands=();
    flags=();
    two_word_flags=();
    local_nonpersistent_flags=();
    flags_with_completion=();
    flags_completion=();
    flags+=("--json");
    flags+=("-j");
    local_nonpersistent_flags+=("--json");
    local_nonpersistent_flags+=("-j");
    flags+=("--help");
    local_nonpersistent_flags+=("--help");
    flags+=("--monochrome");
    flags+=("-M");
    flags+=("--verbose");
    flags+=("-v");
    must_have_one_flag=();
    must_have_one_noun=();
    has_completion_function=1;
    noun_aliases=()
}
_sq_root_command ()
{
    last_command="sq";
    command_aliases=();
    commands=();
    commands+=("sql");
    commands+=("src");
    commands+=("add");
    commands+=("ls");
    commands+=("rm");
    commands+=("inspect");
    commands+=("ping");
    commands+=("version");
    commands+=("driver");
    commands+=("tbl");
    commands+=("completion");
    commands+=("help");
    flags=();
    two_word_flags=();
    local_nonpersistent_flags=();
    flags_with_completion=();
    flags_completion=();
    flags+=("--output=");
    two_word_flags+=("--output");
    two_word_flags+=("-o");
    local_nonpersistent_flags+=("--output");
    local_nonpersistent_flags+=("--output=");
    local_nonpersistent_flags+=("-o");
    flags+=("--json");
    flags+=("-j");
    local_nonpersistent_flags+=("--json");
    local_nonpersistent_flags+=("-j");
    flags+=("--jsona");
    flags+=("-A");
    local_nonpersistent_flags+=("--jsona");
    local_nonpersistent_flags+=("-A");
    flags+=("--jsonl");
    flags+=("-l");
    local_nonpersistent_flags+=("--jsonl");
    local_nonpersistent_flags+=("-l");
    flags+=("--table");
    flags+=("-t");
    local_nonpersistent_flags+=("--table");
    local_nonpersistent_flags+=("-t");
    flags+=("--xml");
    flags+=("-X");
    local_nonpersistent_flags+=("--xml");
    local_nonpersistent_flags+=("-X");
    flags+=("--xlsx");
    flags+=("-x");
    local_nonpersistent_flags+=("--xlsx");
    local_nonpersistent_flags+=("-x");
    flags+=("--csv");
    flags+=("-c");
    local_nonpersistent_flags+=("--csv");
    local_nonpersistent_flags+=("-c");
    flags+=("--tsv");
    flags+=("-T");
    local_nonpersistent_flags+=("--tsv");
    local_nonpersistent_flags+=("-T");
    flags+=("--raw");
    flags+=("-r");
    local_nonpersistent_flags+=("--raw");
    local_nonpersistent_flags+=("-r");
    flags+=("--html");
    local_nonpersistent_flags+=("--html");
    flags+=("--md");
    local_nonpersistent_flags+=("--md");
    flags+=("--header");
    flags+=("-h");
    local_nonpersistent_flags+=("--header");
    local_nonpersistent_flags+=("-h");
    flags+=("--pretty");
    local_nonpersistent_flags+=("--pretty");
    flags+=("--insert=");
    two_word_flags+=("--insert");
    flags_with_completion+=("--insert");
    flags_completion+=("__sq_handle_go_custom_completion");
    local_nonpersistent_flags+=("--insert");
    local_nonpersistent_flags+=("--insert=");
    flags+=("--src=");
    two_word_flags+=("--src");
    flags_with_completion+=("--src");
    flags_completion+=("__sq_handle_go_custom_completion");
    local_nonpersistent_flags+=("--src");
    local_nonpersistent_flags+=("--src=");
    flags+=("--driver=");
    two_word_flags+=("--driver");
    flags_with_completion+=("--driver");
    flags_completion+=("__sq_handle_go_custom_completion");
    local_nonpersistent_flags+=("--driver");
    local_nonpersistent_flags+=("--driver=");
    flags+=("--opts=");
    two_word_flags+=("--opts");
    local_nonpersistent_flags+=("--opts");
    local_nonpersistent_flags+=("--opts=");
    flags+=("--version");
    local_nonpersistent_flags+=("--version");
    flags+=("--help");
    local_nonpersistent_flags+=("--help");
    flags+=("--monochrome");
    flags+=("-M");
    flags+=("--verbose");
    flags+=("-v");
    must_have_one_flag=();
    must_have_one_noun=();
    noun_aliases=()
}
_sq_sql ()
{
    last_command="sq_sql";
    command_aliases=();
    commands=();
    flags=();
    two_word_flags=();
    local_nonpersistent_flags=();
    flags_with_completion=();
    flags_completion=();
    flags+=("--output=");
    two_word_flags+=("--output");
    two_word_flags+=("-o");
    local_nonpersistent_flags+=("--output");
    local_nonpersistent_flags+=("--output=");
    local_nonpersistent_flags+=("-o");
    flags+=("--json");
    flags+=("-j");
    local_nonpersistent_flags+=("--json");
    local_nonpersistent_flags+=("-j");
    flags+=("--jsona");
    flags+=("-A");
    local_nonpersistent_flags+=("--jsona");
    local_nonpersistent_flags+=("-A");
    flags+=("--jsonl");
    flags+=("-l");
    local_nonpersistent_flags+=("--jsonl");
    local_nonpersistent_flags+=("-l");
    flags+=("--table");
    flags+=("-t");
    local_nonpersistent_flags+=("--table");
    local_nonpersistent_flags+=("-t");
    flags+=("--xml");
    flags+=("-X");
    local_nonpersistent_flags+=("--xml");
    local_nonpersistent_flags+=("-X");
    flags+=("--xlsx");
    flags+=("-x");
    local_nonpersistent_flags+=("--xlsx");
    local_nonpersistent_flags+=("-x");
    flags+=("--csv");
    flags+=("-c");
    local_nonpersistent_flags+=("--csv");
    local_nonpersistent_flags+=("-c");
    flags+=("--tsv");
    flags+=("-T");
    local_nonpersistent_flags+=("--tsv");
    local_nonpersistent_flags+=("-T");
    flags+=("--raw");
    flags+=("-r");
    local_nonpersistent_flags+=("--raw");
    local_nonpersistent_flags+=("-r");
    flags+=("--html");
    local_nonpersistent_flags+=("--html");
    flags+=("--md");
    local_nonpersistent_flags+=("--md");
    flags+=("--header");
    flags+=("-h");
    local_nonpersistent_flags+=("--header");
    local_nonpersistent_flags+=("-h");
    flags+=("--pretty");
    local_nonpersistent_flags+=("--pretty");
    flags+=("--insert=");
    two_word_flags+=("--insert");
    flags_with_completion+=("--insert");
    flags_completion+=("__sq_handle_go_custom_completion");
    local_nonpersistent_flags+=("--insert");
    local_nonpersistent_flags+=("--insert=");
    flags+=("--src=");
    two_word_flags+=("--src");
    flags_with_completion+=("--src");
    flags_completion+=("__sq_handle_go_custom_completion");
    local_nonpersistent_flags+=("--src");
    local_nonpersistent_flags+=("--src=");
    flags+=("--driver=");
    two_word_flags+=("--driver");
    flags_with_completion+=("--driver");
    flags_completion+=("__sq_handle_go_custom_completion");
    local_nonpersistent_flags+=("--driver");
    local_nonpersistent_flags+=("--driver=");
    flags+=("--opts=");
    two_word_flags+=("--opts");
    local_nonpersistent_flags+=("--opts");
    local_nonpersistent_flags+=("--opts=");
    flags+=("--query");
    local_nonpersistent_flags+=("--query");
    flags+=("--exec");
    local_nonpersistent_flags+=("--exec");
    flags+=("--help");
    local_nonpersistent_flags+=("--help");
    flags+=("--monochrome");
    flags+=("-M");
    flags+=("--verbose");
    flags+=("-v");
    must_have_one_flag=();
    must_have_one_noun=();
    noun_aliases=()
}
_sq_src ()
{
    last_command="sq_src";
    command_aliases=();
    commands=();
    flags=();
    two_word_flags=();
    local_nonpersistent_flags=();
    flags_with_completion=();
    flags_completion=();
    flags+=("--json");
    flags+=("-j");
    local_nonpersistent_flags+=("--json");
    local_nonpersistent_flags+=("-j");
    flags+=("--help");
    local_nonpersistent_flags+=("--help");
    flags+=("--monochrome");
    flags+=("-M");
    flags+=("--verbose");
    flags+=("-v");
    must_have_one_flag=();
    must_have_one_noun=();
    has_completion_function=1;
    noun_aliases=()
}
_sq_tbl ()
{
    last_command="sq_tbl";
    command_aliases=();
    commands=();
    commands+=("copy");
    commands+=("truncate");
    commands+=("drop");
    flags=();
    two_word_flags=();
    local_nonpersistent_flags=();
    flags_with_completion=();
    flags_completion=();
    flags+=("--help");
    local_nonpersistent_flags+=("--help");
    flags+=("--monochrome");
    flags+=("-M");
    flags+=("--verbose");
    flags+=("-v");
    must_have_one_flag=();
    must_have_one_noun=();
    noun_aliases=()
}
_sq_tbl_copy ()
{
    last_command="sq_tbl_copy";
    command_aliases=();
    commands=();
    flags=();
    two_word_flags=();
    local_nonpersistent_flags=();
    flags_with_completion=();
    flags_completion=();
    flags+=("--json");
    flags+=("-j");
    local_nonpersistent_flags+=("--json");
    local_nonpersistent_flags+=("-j");
    flags+=("--data");
    local_nonpersistent_flags+=("--data");
    flags+=("--help");
    local_nonpersistent_flags+=("--help");
    flags+=("--monochrome");
    flags+=("-M");
    flags+=("--verbose");
    flags+=("-v");
    must_have_one_flag=();
    must_have_one_noun=();
    has_completion_function=1;
    noun_aliases=()
}
_sq_tbl_drop ()
{
    last_command="sq_tbl_drop";
    command_aliases=();
    commands=();
    flags=();
    two_word_flags=();
    local_nonpersistent_flags=();
    flags_with_completion=();
    flags_completion=();
    flags+=("--help");
    local_nonpersistent_flags+=("--help");
    flags+=("--monochrome");
    flags+=("-M");
    flags+=("--verbose");
    flags+=("-v");
    must_have_one_flag=();
    must_have_one_noun=();
    has_completion_function=1;
    noun_aliases=()
}
_sq_tbl_truncate ()
{
    last_command="sq_tbl_truncate";
    command_aliases=();
    commands=();
    flags=();
    two_word_flags=();
    local_nonpersistent_flags=();
    flags_with_completion=();
    flags_completion=();
    flags+=("--json");
    flags+=("-j");
    local_nonpersistent_flags+=("--json");
    local_nonpersistent_flags+=("-j");
    flags+=("--table");
    flags+=("-t");
    local_nonpersistent_flags+=("--table");
    local_nonpersistent_flags+=("-t");
    flags+=("--help");
    local_nonpersistent_flags+=("--help");
    flags+=("--monochrome");
    flags+=("-M");
    flags+=("--verbose");
    flags+=("-v");
    must_have_one_flag=();
    must_have_one_noun=();
    has_completion_function=1;
    noun_aliases=()
}
_sq_version ()
{
    last_command="sq_version";
    command_aliases=();
    commands=();
    flags=();
    two_word_flags=();
    local_nonpersistent_flags=();
    flags_with_completion=();
    flags_completion=();
    flags+=("--json");
    flags+=("-j");
    local_nonpersistent_flags+=("--json");
    local_nonpersistent_flags+=("-j");
    flags+=("--help");
    local_nonpersistent_flags+=("--help");
    flags+=("--monochrome");
    flags+=("-M");
    flags+=("--verbose");
    flags+=("-v");
    must_have_one_flag=();
    must_have_one_noun=();
    noun_aliases=()
}
_sqlite3 ()
{
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    local dbexts='@(sqlite?(3)|?(s?(3))db)';
    case $prev in
        -help | -version | -separator | -nullvalue | *.$dbexts)
            return 0
        ;;
        -init)
            _filedir;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-help -init -echo -header -noheader -bail
            -interactive -batch -column -csv -html -line -list -separator
            -nullvalue -version' -- "$cur" ));
        return 0;
    fi;
    _filedir $dbexts
}
_ssh ()
{
    local cur prev configfile;
    local -a config;
    COMPREPLY=();
    _get_comp_words_by_ref -n : cur prev;
    _ssh_suboption_check && return 0;
    case $prev in
        -F | -i | -S)
            _filedir;
            return 0
        ;;
        -c)
            _ssh_ciphers;
            return 0
        ;;
        -m)
            _ssh_macs;
            return 0
        ;;
        -l)
            COMPREPLY=($( compgen -u -- "$cur" ));
            return 0
        ;;
        -o)
            _ssh_options;
            return 0
        ;;
        -w)
            _available_interfaces;
            return 0
        ;;
        -b)
            _ssh_bindaddress;
            return 0
        ;;
    esac;
    if [[ "$cur" == -F* ]]; then
        cur=${cur#-F};
        _filedir;
        COMPREPLY=("${COMPREPLY[@]/#/-F}");
        cur=-F$cur;
    else
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '-1 -2 -4 -6 -A -a -C -f -g -K -k -M \
            -N -n -q -s -T -t -V -v -X -v -Y -y -b -b -c -D -e -F \
            -i -L -l -m -O -o -p -R -S -w' -- "$cur" ));
        else
            set -- "${COMP_WORDS[@]}";
            while [ $# -gt 0 ]; do
                if [ "${1:0:2}" = -F ]; then
                    if [ ${#1} -gt 2 ]; then
                        configfile="$(dequote "${1:2}")";
                    else
                        shift;
                        [ "$1" ] && configfile="$(dequote "$1")";
                    fi;
                    break;
                fi;
                shift;
            done;
            _known_hosts_real -a -F "$configfile" "$cur";
            if [ $COMP_CWORD -ne 1 ]; then
                _compopt_o_filenames;
                COMPREPLY=("${COMPREPLY[@]}" $( compgen -c -- "$cur" ));
            fi;
        fi;
    fi;
    return 0
}
_ssh_bindaddress ()
{
    COMPREPLY=("${COMPREPLY[@]}" $( compgen -W         "$( PATH="$PATH:/sbin" ifconfig -a |         sed -ne 's/.*addr:\([^[:space:]]*\).*/\1/p'             -ne 's/.*inet[[:space:]]\{1,\}\([^[:space:]]*\).*/\1/p' )"         -- "$cur" ))
}
_ssh_ciphers ()
{
    COMPREPLY=("${COMPREPLY[@]}" $( compgen -W '3des-cbc aes128-cbc \
        aes192-cbc aes256-cbc aes128-ctr aes192-ctr aes256-ctr arcfour128 \
        arcfour256 arcfour blowfish-cbc cast128-cbc' -- "$cur" ))
}
_ssh_copy_id ()
{
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in
        -i)
            _filedir;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-i' -- "$cur" ));
    else
        _known_hosts_real -a "$cur";
    fi;
    return 0
}
_ssh_macs ()
{
    COMPREPLY=("${COMPREPLY[@]}" $( compgen -W 'hmac-md5 hmac-sha1 \
        umac-64@openssh.com hmac-ripemd160 hmac-sha1-96 hmac-md5-96'         -- "$cur" ))
}
_ssh_options ()
{
    type compopt >&/dev/null && compopt -o nospace;
    COMPREPLY=($( compgen -S = -W 'AddressFamily BatchMode BindAddress \
        ChallengeResponseAuthentication CheckHostIP Cipher Ciphers \
        ClearAllForwardings Compression CompressionLevel ConnectionAttempts \
        ConnectTimeout ControlMaster ControlPath DynamicForward EscapeChar \
        ExitOnForwardFailure ForwardAgent ForwardX11 ForwardX11Trusted \
        GatewayPorts GlobalKnownHostsFile GSSAPIAuthentication \
        GSSAPIDelegateCredentials HashKnownHosts Host HostbasedAuthentication \
        HostKeyAlgorithms HostKeyAlias HostName IdentityFile IdentitiesOnly \
        KbdInteractiveDevices LocalCommand LocalForward LogLevel MACs \
        NoHostAuthenticationForLocalhost NumberOfPasswordPrompts \
        PasswordAuthentication PermitLocalCommand Port \
        PreferredAuthentications Protocol ProxyCommand PubkeyAuthentication \
        RekeyLimit RemoteForward RhostsRSAAuthentication RSAAuthentication \
        SendEnv ServerAliveInterval ServerAliveCountMax SmartcardDevice \
        StrictHostKeyChecking TCPKeepAlive Tunnel TunnelDevice \
        UsePrivilegedPort User UserKnownHostsFile VerifyHostKeyDNS \
        VisualHostKey XAuthLocation' -- "$cur" ))
}
_ssh_suboption ()
{
    local prev=${1%%=*} cur=${1#*=};
    case $prev in
        BatchMode | ChallengeResponseAuthentication | CheckHostIP | ClearAllForwardings | Compression | ExitOnForwardFailure | ForwardAgent | ForwardX11 | ForwardX11Trusted | GatewayPorts | GSSAPIAuthentication | GSSAPIKeyExchange | GSSAPIDelegateCredentials | GSSAPITrustDns | HashKnownHosts | HostbasedAuthentication | IdentitiesOnly | KbdInteractiveAuthentication | KbdInteractiveDevices | NoHostAuthenticationForLocalhost | PasswordAuthentication | PubkeyAuthentication | RhostsRSAAuthentication | RSAAuthentication | StrictHostKeyChecking | TCPKeepAlive | UsePrivilegedPort | VerifyHostKeyDNS | VisualHostKey)
            COMPREPLY=($( compgen -W 'yes no' -- "$cur"))
        ;;
        AddressFamily)
            COMPREPLY=($( compgen -W 'any inet inet6' -- "$cur" ))
        ;;
        BindAddress)
            _ssh_bindaddress
        ;;
        Cipher)
            COMPREPLY=($( compgen -W 'blowfish des 3des' -- "$cur" ))
        ;;
        Protocol)
            COMPREPLY=($( compgen -W '1 2 1,2 2,1' -- "$cur" ))
        ;;
        Tunnel)
            COMPREPLY=($( compgen -W 'yes no point-to-point ethernet'                     -- "$cur" ))
        ;;
        PreferredAuthentications)
            COMPREPLY=($( compgen -W 'gssapi-with-mic host-based \
                    publickey keyboard-interactive password' -- "$cur" ))
        ;;
        MACs)
            _ssh_macs
        ;;
        Ciphers)
            _ssh_ciphers
        ;;
    esac;
    return 0
}
_ssh_suboption_check ()
{
    local cureq=`_get_cword :=` preveq=`_get_pword :=`;
    if [[ $cureq == *=* && $preveq == -o ]]; then
        _ssh_suboption $cureq;
        return $?;
    fi;
    return 1
}
_starship ()
{
    local i cur prev opts cmd;
    COMPREPLY=();
    cur="${COMP_WORDS[COMP_CWORD]}";
    prev="${COMP_WORDS[COMP_CWORD-1]}";
    cmd="";
    opts="";
    for i in ${COMP_WORDS[@]};
    do
        case "${cmd},${i}" in
            ",$1")
                cmd="starship"
            ;;
            starship,bug-report)
                cmd="starship__bug__report"
            ;;
            starship,completions)
                cmd="starship__completions"
            ;;
            starship,config)
                cmd="starship__config"
            ;;
            starship,explain)
                cmd="starship__explain"
            ;;
            starship,help)
                cmd="starship__help"
            ;;
            starship,init)
                cmd="starship__init"
            ;;
            starship,module)
                cmd="starship__module"
            ;;
            starship,preset)
                cmd="starship__preset"
            ;;
            starship,print-config)
                cmd="starship__print__config"
            ;;
            starship,prompt)
                cmd="starship__prompt"
            ;;
            starship,session)
                cmd="starship__session"
            ;;
            starship,time)
                cmd="starship__time"
            ;;
            starship,timings)
                cmd="starship__timings"
            ;;
            starship,toggle)
                cmd="starship__toggle"
            ;;
            starship__help,bug-report)
                cmd="starship__help__bug__report"
            ;;
            starship__help,completions)
                cmd="starship__help__completions"
            ;;
            starship__help,config)
                cmd="starship__help__config"
            ;;
            starship__help,explain)
                cmd="starship__help__explain"
            ;;
            starship__help,help)
                cmd="starship__help__help"
            ;;
            starship__help,init)
                cmd="starship__help__init"
            ;;
            starship__help,module)
                cmd="starship__help__module"
            ;;
            starship__help,preset)
                cmd="starship__help__preset"
            ;;
            starship__help,print-config)
                cmd="starship__help__print__config"
            ;;
            starship__help,prompt)
                cmd="starship__help__prompt"
            ;;
            starship__help,session)
                cmd="starship__help__session"
            ;;
            starship__help,time)
                cmd="starship__help__time"
            ;;
            starship__help,timings)
                cmd="starship__help__timings"
            ;;
            starship__help,toggle)
                cmd="starship__help__toggle"
            ;;
            *)

            ;;
        esac;
    done;
    case "${cmd}" in
        starship)
            opts="-h -V --help --version bug-report completions config explain init module preset print-config prompt session time timings toggle help";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 1 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        starship__bug__report)
            opts="-h --help";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        starship__completions)
            opts="-h --help bash elvish fish powershell zsh";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        starship__config)
            opts="-h --help [NAME] [VALUE]";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        starship__explain)
            opts="-s -w -p -P -d -k -j -h --status --pipestatus --terminal-width --path --logical-path --cmd-duration --keymap --jobs --help";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                --status)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -s)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --pipestatus)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --terminal-width)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -w)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --path)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -p)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --logical-path)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -P)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --cmd-duration)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -d)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --keymap)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -k)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --jobs)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -j)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        starship__help)
            opts="bug-report completions config explain init module preset print-config prompt session time timings toggle help";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        starship__help__bug__report)
            opts="";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        starship__help__completions)
            opts="";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        starship__help__config)
            opts="";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        starship__help__explain)
            opts="";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        starship__help__help)
            opts="";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        starship__help__init)
            opts="";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        starship__help__module)
            opts="";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        starship__help__preset)
            opts="";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        starship__help__print__config)
            opts="";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        starship__help__prompt)
            opts="";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        starship__help__session)
            opts="";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        starship__help__time)
            opts="";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        starship__help__timings)
            opts="";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        starship__help__toggle)
            opts="";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 3 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        starship__init)
            opts="-h --print-full-init --help <SHELL>";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        starship__module)
            opts="-l -s -w -p -P -d -k -j -h --list --status --pipestatus --terminal-width --path --logical-path --cmd-duration --keymap --jobs --help [NAME]";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                --status)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -s)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --pipestatus)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --terminal-width)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -w)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --path)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -p)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --logical-path)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -P)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --cmd-duration)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -d)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --keymap)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -k)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --jobs)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -j)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        starship__preset)
            opts="-o -l -h --output --list --help no-runtime-versions bracketed-segments plain-text-symbols no-empty-icons tokyo-night no-nerd-font pastel-powerline pure-preset nerd-font-symbols";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                --output)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -o)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        starship__print__config)
            opts="-d -h --default --help [NAME]...";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        starship__prompt)
            opts="-s -w -p -P -d -k -j -h --right --profile --continuation --status --pipestatus --terminal-width --path --logical-path --cmd-duration --keymap --jobs --help";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                --profile)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --status)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -s)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --pipestatus)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --terminal-width)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -w)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --path)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -p)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --logical-path)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -P)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --cmd-duration)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -d)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --keymap)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -k)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --jobs)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -j)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        starship__session)
            opts="-h --help";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        starship__time)
            opts="-h --help";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        starship__timings)
            opts="-s -w -p -P -d -k -j -h --status --pipestatus --terminal-width --path --logical-path --cmd-duration --keymap --jobs --help";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                --status)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -s)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --pipestatus)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --terminal-width)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -w)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --path)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -p)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --logical-path)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -P)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --cmd-duration)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -d)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --keymap)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -k)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                --jobs)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                -j)
                    COMPREPLY=($(compgen -f "${cur}"));
                    return 0
                ;;
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
        starship__toggle)
            opts="-h --help <NAME> [VALUE]";
            if [[ ${cur} == -* || ${COMP_CWORD} -eq 2 ]]; then
                COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
                return 0;
            fi;
            case "${prev}" in
                *)
                    COMPREPLY=()
                ;;
            esac;
            COMPREPLY=($(compgen -W "${opts}" -- "${cur}"));
            return 0
        ;;
    esac
}
_sysctl ()
{
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    COMPREPLY=($( compgen -W         "$( PATH="$PATH:/sbin" sysctl -N -a 2>/dev/null )" -- "$cur" ));
    return 0
}
_tar ()
{
    local cur ext regex tar untar;
    COMPREPLY=();
    _get_comp_words_by_ref cur;
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($( compgen -W 'c t x u r d A' -- "$cur" ));
        return 0;
    fi;
    case ${COMP_WORDS[1]} in
        ?(-)[cr]*f)
            _filedir;
            return 0
        ;;
        +([^IZzJjy])f)
            ext='@(@(tar|gem|spkg)?(.@(Z|[gx]z|bz?(2)|lzma))|t@([glx]z|bz?(2)))';
            regex='\(\(tar\|gem\|spkg\)\(\.\(Z\|[gx]z\|bz?(2)\|lzma\)\)\?\|t\([glx]z\|bz2\?\)\)'
        ;;
        *[Zz]*f)
            ext='@(t?(ar.)|gem.|spkg.)@(gz|Z)';
            regex='\(t\(ar\.\)\?\|gem\.\|spkg\.\)\(gz\|Z\)'
        ;;
        *[Ijy]*f)
            ext='@(@(t?(ar.)|gem.)bz?(2)|spkg)';
            regex='\(\(t\(ar\.\)\?\|gem\.\)bz2\?\|spkg\)'
        ;;
        *[J]*f)
            ext='@(t?(ar.)|gem.|spkg.)@(lz?(ma)|xz)';
            regex='\(t\(ar\.\)\?\|gem\.\|spkg\.\)\(lzma\|xz\)\?'
        ;;
        *)
            _filedir;
            return 0
        ;;
    esac;
    if [[ "$COMP_LINE" == *$ext' ' ]]; then
        tar=$( sed -e 's/^.* \([^ ]*'$regex'\) .*$/\1/' <<<"$COMP_LINE" );
        untar=t${COMP_WORDS[1]//[^Izjyf]/};
        local IFS='
';
        COMPREPLY=($( compgen -W "$( printf '%s\n' $( tar $untar $tar             2>/dev/null ) )" -- "$cur" ));
        return 0;
    fi;
    _filedir "$ext";
    return 0
}
_task ()
{
    local cur prev opts base;
    COMPREPLY=();
    cur="${COMP_WORDS[COMP_CWORD]}";
    prev="${COMP_WORDS[COMP_CWORD-1]}";
    if [ ${#COMP_WORDS[*]} -gt 2 ]; then
        prev2="${COMP_WORDS[COMP_CWORD-2]}";
    else
        prev2="";
    fi;
    abbrev_min=$("$taskbin" $taskcommand show | grep "abbreviation.minimum" | awk {'print  $2'});
    commands_aliases=$(echo $("$taskbin" $taskcommand _commands; "$taskbin" $taskcommand _aliases) | tr " " "\n"|sort|tr "\n" " ");
    opts="$commands_aliases $("$taskbin" $taskcommand _columns)";
    case "${prev}" in
        $_task_context_alias | cont | conte | contex | context)
            _task_offer_contexts;
            return 0
        ;;
        :)
            case "${prev2}" in
                pri | prior | priori | priorit | priority)
                    if [ ${#prev2} -ge $abbrev_min ]; then
                        _task_offer_priorities;
                    fi;
                    return 0
                ;;
                pro | proj | proje | projec | project)
                    if [ ${#prev2} -ge $abbrev_min ]; then
                        _task_offer_projects;
                    fi;
                    return 0
                ;;
                rc)
                    _filedir;
                    return 0
                ;;
                rc.data.location)
                    _filedir -d;
                    return 0
                ;;
            esac
        ;;
        *)
            case "${cur}" in
                pro:* | proj:* | proje:* | projec:* | project:*)
                    _task_offer_projects;
                    return 0
                ;;
                :)
                    case "${prev}" in
                        pri | prior | priori | priorit | priority)
                            if [ ${#prev} -ge $abbrev_min ]; then
                                _task_offer_priorities;
                            fi;
                            return 0
                        ;;
                        pro | proj | proje | projec | project)
                            if [ ${#prev} -ge $abbrev_min ]; then
                                _task_offer_projects;
                            fi;
                            return 0
                        ;;
                        rc)
                            cur="";
                            _filedir;
                            return 0
                        ;;
                        rc.data.location)
                            cur="";
                            _filedir -d;
                            return 0
                        ;;
                    esac
                ;;
                +*)
                    local tags=$(_task_get_tags | sed 's/^/+/');
                    COMPREPLY=($(compgen -W "${tags}" -- ${cur}));
                    return 0
                ;;
                -*)
                    local tags=$(_task_get_tags | sed 's/^/-/');
                    COMPREPLY=($(compgen -W "${tags}" -- ${cur}));
                    return 0
                ;;
                rc.*)
                    local config=$(_task_get_config | sed -e 's/^/rc\./' -e 's/$/:/');
                    COMPREPLY=($(compgen -W "${config}" -- ${cur}));
                    return 0
                ;;
                *)
                    case "${prev}" in
                        import)
                            COMPREPLY=($(compgen -o "default" -- ${cur}));
                            return 0
                        ;;
                    esac
                ;;
            esac
        ;;
    esac;
    COMPREPLY=($(compgen -W "${opts}" -- ${cur}));
    return 0
}
_task_get_config ()
{
    "$taskbin" $taskcommand _config
}
_task_get_tags ()
{
    "$taskbin" $taskcommand _tags
}
_task_offer_contexts ()
{
    COMPREPLY=($(compgen -W "$("$taskbin" $taskcommand _context) define delete list none show" -- $cur))
}
_task_offer_priorities ()
{
    COMPREPLY=($(compgen -W "L M H" -- ${cur/*:/}))
}
_task_offer_projects ()
{
    COMPREPLY=($(compgen -W "$("$taskbin" $taskcommand _projects)" -- ${cur/*:/}))
}
_tcpdump ()
{
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in
        -r | -w | -F)
            _filedir;
            return 0
        ;;
        -i)
            _available_interfaces -a;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-a -d -e -f -l -n -N -O -p \
            -q -R -S -t -u -v -x -C -F -i -m -r -s -T -w -E' -- "$cur" ));
    fi
}
_tilde ()
{
    local result=0;
    if [[ ${1:0:1} == "~" && $1 == ${1//\/} ]]; then
        _compopt_o_filenames;
        COMPREPLY=($( compgen -P '~' -u "${1#\~}" ));
        result=${#COMPREPLY[@]};
    fi;
    return $result
}
_tldr_complete ()
{
    COMPREPLY=();
    local word="${COMP_WORDS[COMP_CWORD]}";
    local cmpl="";
    if [ "$word" = "-" ]; then
        cmpl=$(echo '
-v
-h
-u
-c
-p
-r' | sort);
    else
        if [ "$word" = "--" ]; then
            cmpl=$(echo '--version
--help
--update
--clear-cache
--platform
--render' | sort);
        else
            if [ -d "$HOME/.tldrc/tldr/pages" ]; then
                local platform="$(uname)";
                cmpl="$(_tldr_get_files common | sort | uniq)";
                if [ "$platform" = "Darwin" ]; then
                    cmpl="${cmpl}$(_tldr_get_files osx | sort | uniq)";
                else
                    if [ "$platform" = "Linux" ]; then
                        cmpl="${cmpl}$(_tldr_get_files linux | sort | uniq)";
                    else
                        if [ "$platform" = "SunOS" ]; then
                            cmpl="${cmpl}$(_tldr_get_files sunos | sort | uniq)";
                        fi;
                    fi;
                fi;
            fi;
        fi;
    fi;
    COMPREPLY=($(compgen -W "$cmpl" -- "$word"))
}
_tldr_get_files ()
{
    local ret;
    local files="$(find $HOME/.tldrc/tldr/pages/$1 -name '*.md' -exec basename {} .md \;)";
    IFS='
	';
    for f in $files;
    do
        echo $f;
    done
}
_tmux ()
{
    local cur prev words cword;
    if declare -F _init_completion > /dev/null 2>&1; then
        _init_completion;
    else
        __tmux_init_completion;
    fi;
    local index=1;
    local argv=("${words[@]:1}");
    local OPTIND OPTARG OPTERR=0 flag tmux_args=();
    while getopts "L:S:" flag "${argv[@]}"; do
        case "$flag" in
            L)
                tmux_args+=(-L "$OPTARG")
            ;;
            S)
                tmux_args+=(-S "$OPTARG")
            ;;
            *)

            ;;
        esac;
    done;
    if [[ ${#words[@]} -gt $OPTIND ]]; then
        local tmux_argc=${#tmux_args[@]};
        (( index+=tmux_argc ));
        (( cword-=tmux_argc ));
    fi;
    if [[ $cword -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$(tmux start\; list-commands | cut -d' ' -f1)" -- "$cur" ));
        return 0;
    else
        case ${words[index]} in
            -L)
                _tmux_complete_socket_name "${cur}"
            ;;
            -S)
                _tmux_complete_socket_path "${cur}"
            ;;
            attach-session | attach)
                case "$prev" in
                    -t)
                        _tmux_complete_session "${cur}" "${tmux_args[@]}"
                    ;;
                    *)
                        options="-t -d"
                    ;;
                esac
            ;;
            detach-client | detach)
                case "$prev" in
                    -t)
                        _tmux_complete_client "${cur}" "${tmux_args[@]}"
                    ;;
                    *)
                        options="-t"
                    ;;
                esac
            ;;
            lock-client | lockc)
                case "$prev" in
                    -t)
                        _tmux_complete_client "${cur}" "${tmux_args[@]}"
                    ;;
                    *)
                        options="-t"
                    ;;
                esac
            ;;
            lock-session | locks)
                case "$prev" in
                    -t)
                        _tmux_complete_session "${cur}" "${tmux_args[@]}"
                    ;;
                    *)
                        options="-t -d"
                    ;;
                esac
            ;;
            new-session | new)
                case "$prev" in
                    -t)
                        _tmux_complete_session "${cur}" "${tmux_args[@]}"
                    ;;
                    -[n | d | s])
                        options="-d -n -s -t --"
                    ;;
                    *)
                        if [[ ${COMP_WORDS[option_index]} == -- ]]; then
                            _command_offset ${option_index};
                        else
                            options="-d -n -s -t --";
                        fi
                    ;;
                esac
            ;;
            refresh-client | refresh)
                case "$prev" in
                    -t)
                        _tmux_complete_client "${cur}" "${tmux_args[@]}"
                    ;;
                    *)
                        options="-t"
                    ;;
                esac
            ;;
            rename-session | rename)
                case "$prev" in
                    -t)
                        _tmux_complete_session "${cur}" "${tmux_args[@]}"
                    ;;
                    *)
                        options="-t"
                    ;;
                esac
            ;;
            has-session | has | kill-session)
                case "$prev" in
                    -t)
                        _tmux_complete_session "${cur}" "${tmux_args[@]}"
                    ;;
                    *)
                        options="-t"
                    ;;
                esac
            ;;
            source-file | source)
                _filedir
            ;;
            suspend-client | suspendc)
                case "$prev" in
                    -t)
                        _tmux_complete_client "${cur}" "${tmux_args[@]}"
                    ;;
                    *)
                        options="-t"
                    ;;
                esac
            ;;
            switch-client | switchc)
                case "$prev" in
                    -c)
                        _tmux_complete_client "${cur}" "${tmux_args[@]}"
                    ;;
                    -t)
                        _tmux_complete_session "${cur}" "${tmux_args[@]}"
                    ;;
                    *)
                        options="-l -n -p -c -t"
                    ;;
                esac
            ;;
            send-keys | send)
                case "$option" in
                    -t)
                        _tmux_complete_window "${cur}" "${tmux_args[@]}"
                    ;;
                    *)
                        options="-t"
                    ;;
                esac
            ;;
        esac;
    fi;
    if [[ -n "${options}" ]]; then
        COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W "${options}" -- "${cur}"));
    fi;
    return 0
}
_tmux_complete_client ()
{
    local IFS='
';
    local cur="${1}" && shift;
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W "$(tmux "$@" list-clients -F '#{client_tty}' 2> /dev/null)" -- "${cur}"));
    options="";
    return 0
}
_tmux_complete_session ()
{
    local IFS='
';
    local cur="${1}" && shift;
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W "$(tmux "$@" list-sessions -F '#{session_name}' 2> /dev/null)" -- "${cur}"));
    options="";
    return 0
}
_tmux_complete_socket_name ()
{
    local IFS='
';
    local cur="${1}" && shift;
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W "$(find /tmp/tmux-$UID -type s -printf '%P\n')" -- "${cur}"));
    options="";
    return 0
}
_tmux_complete_socket_path ()
{
    local IFS='
';
    local cur="${1}" && shift;
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W "$(find /tmp/tmux-$UID -type s -printf '%p\n')" -- "${cur}"));
    options="";
    return 0
}
_tmux_complete_window ()
{
    local IFS='
';
    local cur="${1}" && shift;
    local session_name="$(echo "${cur}" | sed 's/\\//g' | cut -d ':' -f 1)";
    local sessions;
    sessions="$(tmux "$@" list-sessions 2> /dev/null | sed -re 's/([^:]+:).*$/\1/')";
    if [[ -n "${session_name}" ]]; then
        sessions="${sessions}
        $(tmux "$@" list-windows -t "${session_name}" 2> /dev/null | sed -re 's/^([^:]+):.*$/'"${session_name}"':\1/')";
    fi;
    cur="$(echo "${cur}" | sed -e 's/:/\\\\:/')";
    sessions="$(echo "${sessions}" | sed -e 's/:/\\\\:/')";
    COMPREPLY=(${COMPREPLY[@]:-} $(compgen -W "${sessions}" -- "${cur}"));
    options="";
    return 0
}
_uids ()
{
    if type getent >&/dev/null; then
        COMPREPLY=($( compgen -W '$( getent passwd | cut -d: -f3 )' -- "$cur" ));
    else
        if type perl >&/dev/null; then
            COMPREPLY=($( compgen -W '$( perl -e '"'"'while (($uid) = (getpwent)[2]) { print $uid . "\n" }'"'"' )' -- "$cur" ));
        else
            COMPREPLY=($( compgen -W '$( cut -d: -f3 /etc/passwd )' -- "$cur" ));
        fi;
    fi
}
_umount ()
{
    local cur;
    _get_comp_words_by_ref cur;
    COMPREPLY=();
    if [[ $(uname -s) = Linux && -r /proc/mounts ]]; then
        _linux_fstab < /proc/mounts;
    else
        local IFS='
';
        COMPREPLY=($( compgen -W '$( mount | cut -d" " -f 3 )' -- "$cur" ));
    fi;
    return 0
}
_unique ()
{
    local first cur usage options valopts compreplya compreplyb;
    COMPREPLY=();
    _get_comp_words_by_ref -n = cur;
    first="${COMP_WORDS[0]}";
    usage=`${first}|grep '^Usage:'|sed 's#^Usage:\? \?[^ ]*unique *##'`;
    case "_${cur}" in
        _-cut=* | _-mem=*)
            return 0
        ;;
        _-inp=* | _-ex_file=* | _-ex_file_only=*)
            if [[ "_${usage}" != "_OUTPUT-FILE" ]]; then
                cur=${cur#*=};
                __expand_tilde_by_ref cur 2> /dev/null;
                _filedir;
            fi;
            return 0
        ;;
        _-*=)
            compopt -o bashdefault -o default;
            return 0
        ;;
        _-*)
            if [[ "_${usage}_" != "_OUTPUT-FILE_" ]]; then
                options=`echo ${usage}|sed 's# #\n#g'|grep '^\[.*\]$'|sed 's#^.\(.*\).$#\1#'|sed 's#=.*$#=#'`;
                valopts=`echo "${options}"|grep '='`;
                compreplya=`compgen -W "${options}" -- ${cur}`;
                compreplyb=`compgen -W "${valopts}" -- ${cur}`;
                if [[ "_${compreplya}" == "_${compreplyb}" ]]; then
                    COMPREPLY=($(compgen -W "${valopts}" -- "${cur}"));
                    compopt -o nospace;
                else
                    COMPREPLY=($(compgen -W "${options}" -- "${cur}"));
                fi;
            fi;
            return 0
        ;;
        _*)
            compopt -o bashdefault -o default;
            return 0
        ;;
    esac
}
_unpack200 ()
{
    COMPREPLY=();
    local cur prev;
    _get_comp_words_by_ref cur prev;
    case $prev in
        '-?' | -h | --help | -V | --version | -J)
            return 0
        ;;
        -H | --deflate-hint)
            COMPREPLY=($( compgen -W 'true false keep' -- "$cur" ));
            return 0
        ;;
        -l | --log-file)
            COMPREPLY=($( compgen -W '-' -- "$cur" ));
            _filedir log;
            return 0
        ;;
    esac;
    local i pack=false jar=false;
    for ((i=0; i < ${#COMP_WORDS[@]}-1; i++ ))
    do
        case ${COMP_WORDS[i]} in
            *.pack | *.pack.gz)
                pack=true
            ;;
            *.jar)
                jar=true
            ;;
        esac;
    done;
    if ! $pack; then
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '--deflate-hint= --remove-pack-file \
                --verbose --quiet --log-file= --help --version' -- "$cur" ));
            [[ ${#COMPREPLY[@]} -eq 1 && ${COMPREPLY[0]} == *= ]] && type compopt >&/dev/null && compopt -o nospace;
        else
            _filedir 'pack?(.gz)';
        fi;
    else
        if ! $jar; then
            _filedir jar;
        fi;
    fi
}
_upvar ()
{
    if unset -v "$1"; then
        if (( $# == 2 )); then
            eval $1=\"\$2\";
        else
            eval $1=\(\"\${@:2}\"\);
        fi;
    fi
}
_upvars ()
{
    if ! (( $# )); then
        echo "${FUNCNAME[0]}: usage: ${FUNCNAME[0]} [-v varname" "value] | [-aN varname [value ...]] ..." 1>&2;
        return 2;
    fi;
    while (( $# )); do
        case $1 in
            -a*)
                [[ -n ${1#-a} ]] || {
                    echo "bash: ${FUNCNAME[0]}: \`$1': missing" "number specifier" 1>&2;
                    return 1
                };
                printf %d "${1#-a}" >&/dev/null || {
                    echo "bash:" "${FUNCNAME[0]}: \`$1': invalid number specifier" 1>&2;
                    return 1
                };
                [[ -n "$2" ]] && unset -v "$2" && eval $2=\(\"\${@:3:${1#-a}}\"\) && shift $((${1#-a} + 2)) || {
                    echo "bash: ${FUNCNAME[0]}:" "\`$1${2+ }$2': missing argument(s)" 1>&2;
                    return 1
                }
            ;;
            -v)
                [[ -n "$2" ]] && unset -v "$2" && eval $2=\"\$3\" && shift 3 || {
                    echo "bash: ${FUNCNAME[0]}: $1: missing" "argument(s)" 1>&2;
                    return 1
                }
            ;;
            *)
                echo "bash: ${FUNCNAME[0]}: $1: invalid option" 1>&2;
                return 1
            ;;
        esac;
    done
}
_usb_ids ()
{
    COMPREPLY=(${COMPREPLY[@]:-} $( compgen -W         "$( PATH="$PATH:/sbin" lsusb | awk '{print $6}' )" -- "$cur" ))
}
_user_at_host ()
{
    local cur;
    COMPREPLY=();
    _get_comp_words_by_ref -n : cur;
    if [[ $cur == *@* ]]; then
        _known_hosts_real "$cur";
    else
        COMPREPLY=($( compgen -u -- "$cur" ));
    fi;
    return 0
}
_user_or_group ()
{
    local i;
    for ((i=1; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" == -g ]]; then
            COMPREPLY=($( compgen -g -- "$cur" ));
            return 0;
        fi;
    done;
    COMPREPLY=($( compgen -u -- "$cur" ))
}
_usergroup ()
{
    if [[ $cur = *\\\\* || $cur = *:*:* ]]; then
        return;
    else
        if [[ $cur = *\\:* ]]; then
            local prefix;
            prefix=${cur%%*([^:])};
            prefix=${prefix//\\};
            local mycur="${cur#*[:]}";
            if [[ $1 == -u ]]; then
                _allowed_groups "$mycur";
            else
                local IFS='
';
                COMPREPLY=($( compgen -g -- "$mycur" ));
            fi;
            COMPREPLY=($( compgen -P "$prefix" -W "${COMPREPLY[@]}" ));
        else
            if [[ $cur = *:* ]]; then
                local mycur="${cur#*:}";
                if [[ $1 == -u ]]; then
                    _allowed_groups "$mycur";
                else
                    local IFS='
';
                    COMPREPLY=($( compgen -g -- "$mycur" ));
                fi;
            else
                if [[ $1 == -u ]]; then
                    _allowed_users "$cur";
                else
                    local IFS='
';
                    COMPREPLY=($( compgen -u -- "$cur" ));
                fi;
            fi;
        fi;
    fi
}
_vipw ()
{
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in
        -h | --help)
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--group --help --passwd \
            --quiet --shadow' -- "$cur" ));
        return 0;
    fi
}
_xmllint ()
{
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in
        -o | --output)
            _filedir;
            return 0
        ;;
        --path | --dtdvalidfpi | --maxmem | --encode | --pattern)
            return 0
        ;;
        --dtdvalid)
            _filedir 'dtd?(.gz)';
            return 0
        ;;
        --relaxng)
            _filedir 'rng?(.gz)';
            return 0
        ;;
        --schema)
            _filedir 'xsd?(.gz)';
            return 0
        ;;
        --schematron)
            _filedir 'sch?(.gz)';
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '$( xmllint --help 2>&1 | \
            sed -ne "s/^[[:space:]]*\(--[^[:space:]:]*\).*/\1/p" ) \
            -o' -- "$cur" ));
        return 0;
    fi;
    _filedir '@(*ml|htm|svg|xs[dl]|rng|wsdl|jnlp)?(.gz)'
}
_xsltproc ()
{
    local cur prev;
    COMPREPLY=();
    _get_comp_words_by_ref cur prev;
    case $prev in
        --output | -o)
            _filedir;
            return 0
        ;;
        --maxdepth)
            return 0
        ;;
        --encoding)
            COMPREPLY=($( compgen -W "$( iconv -l | sed -e '/^UTF[1378]/d'                 -e '/^ISO[0-9_]/d' -e '/^8859/d' -e 's/\/.*//')" -- "$cur" ));
            return 0
        ;;
        --param | --stringparam)
            return 0
        ;;
        --path)
            _filedir -d;
            return 0
        ;;
        --writesubtree)
            _filedir -d;
            return 0
        ;;
    esac;
    [[ $COMP_CWORD -gt 2 && `_get_cword '' 2` == --?(string)param ]] && return 0;
    if [[ "$cur" == -* ]]; then
        _longopt xsltproc;
    else
        _filedir '@(xsl|xslt|xml)';
    fi
}
_z ()
{
    local datafile="${_Z_DATA:-$HOME/.z}";
    [ -z "$_Z_OWNER" -a -f "$datafile" -a ! -O "$datafile" ] && return;
    if [ "$1" = "--add" ]; then
        shift;
        [ "$*" = "$HOME" ] && return;
        local exclude;
        for exclude in "${_Z_EXCLUDE_DIRS[@]}";
        do
            case "$*" in
                "$exclude*")
                    return
                ;;
            esac;
        done;
        local tempfile="$datafile.$RANDOM";
        while read line; do
            [ -d "${line%%\|*}" ] && echo $line;
        done < "$datafile" | awk -v path="$*" -v now="$(date +%s)" -F"|" '
            BEGIN {
                rank[path] = 1
                time[path] = now
            }
            $2 >= 1 {
                # drop ranks below 1
                if( $1 == path ) {
                    rank[$1] = $2 + 1
                    time[$1] = now
                } else {
                    rank[$1] = $2
                    time[$1] = $3
                }
                count += $2
            }
            END {
                if( count > 9000 ) {
                    # aging
                    for( x in rank ) print x "|" 0.99*rank[x] "|" time[x]
                } else for( x in rank ) print x "|" rank[x] "|" time[x]
            }
        ' 2> /dev/null >|"$tempfile";
        if [ $? -ne 0 -a -f "$datafile" ]; then
            env rm -f "$tempfile";
        else
            [ "$_Z_OWNER" ] && chown $_Z_OWNER:$(id -ng $_Z_OWNER) "$tempfile";
            env mv -f "$tempfile" "$datafile" || env rm -f "$tempfile";
        fi;
    else
        if [ "$1" = "--complete" -a -s "$datafile" ]; then
            while read line; do
                [ -d "${line%%\|*}" ] && echo $line;
            done < "$datafile" | awk -v q="$2" -F"|" '
            BEGIN {
                if( q == tolower(q) ) imatch = 1
                q = substr(q, 3)
                gsub(" ", ".*", q)
            }
            {
                if( imatch ) {
                    if( tolower($1) ~ tolower(q) ) print $1
                } else if( $1 ~ q ) print $1
            }
        ' 2> /dev/null;
        else
            while [ "$1" ]; do
                case "$1" in
                    --)
                        while [ "$1" ]; do
                            shift;
                            local fnd="$fnd${fnd:+ }$1";
                        done
                    ;;
                    -*)
                        local opt=${1:1};
                        while [ "$opt" ]; do
                            case ${opt:0:1} in
                                c)
                                    local fnd="^$PWD $fnd"
                                ;;
                                h)
                                    echo "${_Z_CMD:-z} [-chlrtx] args" 1>&2;
                                    return
                                ;;
                                x)
                                    sed -i -e "\:^${PWD}|.*:d" "$datafile"
                                ;;
                                l)
                                    local list=1
                                ;;
                                r)
                                    local typ="rank"
                                ;;
                                t)
                                    local typ="recent"
                                ;;
                            esac;
                            opt=${opt:1};
                        done
                    ;;
                    *)
                        local fnd="$fnd${fnd:+ }$1"
                    ;;
                esac;
                local last=$1;
                [ "$#" -gt 0 ] && shift;
            done;
            [ "$fnd" -a "$fnd" != "^$PWD " ] || local list=1;
            case "$last" in
                /*)
                    [ -z "$list" -a -d "$last" ] && cd "$last" && return
                ;;
            esac;
            [ -f "$datafile" ] || return;
            local cd;
            cd="$(while read line; do
            [ -d "${line%%\|*}" ] && echo $line
        done < "$datafile" | awk -v t="$(date +%s)" -v list="$list" -v typ="$typ" -v q="$fnd" -F"|" '
            function frecent(rank, time) {
                # relate frequency and time
                dx = t - time
                if( dx < 3600 ) return rank * 4
                if( dx < 86400 ) return rank * 2
                if( dx < 604800 ) return rank / 2
                return rank / 4
            }
            function output(files, out, common) {
                # list or return the desired directory
                if( list ) {
                    cmd = "sort -n >&2"
                    for( x in files ) {
                        if( files[x] ) printf "%-10s %s\n", files[x], x | cmd
                    }
                    if( common ) {
                        printf "%-10s %s\n", "common:", common > "/dev/stderr"
                    }
                } else {
                    if( common ) out = common
                    print out
                }
            }
            function common(matches) {
                # find the common root of a list of matches, if it exists
                for( x in matches ) {
                    if( matches[x] && (!short || length(x) < length(short)) ) {
                        short = x
                    }
                }
                if( short == "/" ) return
                # use a copy to escape special characters, as we want to return
                # the original. yeah, this escaping is awful.
                clean_short = short
                gsub(/\[\(\)\[\]\|\]/, "\\\\&", clean_short)
                for( x in matches ) if( matches[x] && x !~ clean_short ) return
                return short
            }
            BEGIN {
                gsub(" ", ".*", q)
                hi_rank = ihi_rank = -9999999999
            }
            {
                if( typ == "rank" ) {
                    rank = $2
                } else if( typ == "recent" ) {
                    rank = $3 - t
                } else rank = frecent($2, $3)
                if( $1 ~ q ) {
                    matches[$1] = rank
                } else if( tolower($1) ~ tolower(q) ) imatches[$1] = rank
                if( matches[$1] && matches[$1] > hi_rank ) {
                    best_match = $1
                    hi_rank = matches[$1]
                } else if( imatches[$1] && imatches[$1] > ihi_rank ) {
                    ibest_match = $1
                    ihi_rank = imatches[$1]
                }
            }
            END {
                # prefer case sensitive
                if( best_match ) {
                    output(matches, best_match, common(matches))
                } else if( ibest_match ) {
                    output(imatches, ibest_match, common(imatches))
                }
            }
        ')";
            [ $? -gt 0 ] && return;
            [ "$cd" ] && cd "$cd";
        fi;
    fi
}
activate-tab ()
{
    find-tab "$@" | xargs -n1 chrome-cli activate -t
}
declare -fx activate-tab
announce ()
{
    say "$@";
    notify "$@";
    cowsay "$@"
}
declare -fx announce
autopep ()
{
    autopep8 -i -r -a -a "$@"
}
declare -fx autopep
bats-build ()
{
    package=${PWD##*/};
    brazil-build;
    bats transform -x DockerImage-1.0 -t "$package-1.0" -p "$package-1.0"
}
declare -fx bats-build
bb ()
{
    brazil-build "$@"
}
declare -fx bb
bc ()
{
    command bc -l "$@"
}
declare -fx bc
black ()
{
    command black ./ --extend-exclude "(requirements.py|aws_lambda)" --line-length=100;
    flake8 ./ --exclude requirements.py,aws_lambda --ignore I003,I001 "$@"
}
declare -fx black
brazil-version-set-list ()
{
    brazil ws show | grep "Version" | awk '{print $3}' | xargs -n1 bash -c 'echo "${0//@[0-9]*/}"'
}
declare -fx brazil-version-set-list
build-wait ()
{
    notify "Starting to monitor $1";
    brazil pb view --waitForCompletion --request "$1" && notify "Build $1 has Succeeded" || notify "Build $1 has failed"
}
declare -fx build-wait
cat ()
{
    ccat "$@"
}
declare -fx cat
cat-script ()
{
    if [[ -f $(which "$1") ]]; then
        ccat "$(which "$1")";
    else
        type "$1" | ccat;
    fi
}
declare -fx cat-script
cdd2 ()
{
    cloud-desktop start -p 8888 -m "~/Work/$(PWD | awk '{print $5}' FS='/'):/home/ailor/$(PWD | awk '{print $5}' FS='/')" -u "$@"
}
declare -fx cdd2
cdk-delete-all ()
{
    /Users/ailor/.scripts/cdk-doctor/env/CDKPipelineDoctor-1.0-CDKPipelineDoctor-development/bin/darwin_amd64/cdk-pipeline-doctor cleanup-pipeline "$@"
}
declare -fx cdk-delete-all
charAt ()
{
    local char="${1}";
    declare -i charPosition=${2};
    if [[ -z "${char}" ]]; then
        printf "%s\n" "Usage: ${FUNCNAME} string (position to extract string)";
        return $false;
    fi;
    {
        [[ ${charPosition} -eq 0 ]] && printf "%c\n" "${char}" && return $true
    } || {
        [[ ${charPosition} -gt ${#char} ]] && printf "%s\n" "" && return $true
    };
    ( local temp=${char};
    local cutFirstString;
    declare -i i=0;
    while [[ -n "${temp}" ]]; do
        : $((i++));
        cutFirstString=$(printf "%c" "${temp}");
        temp="${temp#*"$cutFirstString"}";
        (( i == charPosition )) && printf "%s\n" "${cutFirstString}";
    done )
}
declare -fx charAt
checkstyle ()
{
    java -jar ~/Downloads/checkstyle-8.18-all.jar -c checkstyle-config.xml "$@"
}
declare -fx checkstyle
clean-ws ()
{
    cd ..;
    git all clean -dfx
}
declare -fx clean-ws
clear ()
{
    command clear;
    command clear;
    command clear;
    command clear;
    command clear;
    command clear;
    command clear;
    command clear "$@"
}
declare -fx clear
copyWithin ()
{
    local array=$1;
    declare -i indexToCopyFrom=$2;
    declare -i indexToCopyTo=$3;
    read -a array <<< "$array";
    local valueOfIndexToCopyFrom=${array[$indexToCopyFrom]};
    local valueOfIndexToCopyTo=${array[$indexToCopyTo]};
    {
        [[ -z ${@} ]] || [[ -z "$array" ]]
    } && {
        printf "%s\n" "Usage: copyWithin arrayArgument indexToCopyFrom indexToCopyto";
        return $false
    };
    array["$indexToCopyTo"]="$valueOfIndexToCopyFrom";
    echo "${array[@]}";
    return $true
}
declare -fx copyWithin
credentials ()
{
    tmux kill-session -t credentials;
    tmux new-session -d -s credentials "aws-credentials -r" "$@"
}
declare -fx credentials
csv ()
{
    gnumeric "$@"
}
declare -fx csv
csv2md ()
{
    csv="$(csv2md.jq "$@")";
    echo "$csv" | jq -c '.[0]' | sed 's/"//g' | sed 's/,/ | /g' | sed 's/]/ | /g' | sed 's/\[/ | /g';
    echo "$csv" | jq -c '.[0]' | sed 's/"//g' | sed 's/,/ | /g' | sed 's/]/ | /g' | sed 's/\[/ | /g' | sed -E 's/\|[^\|]+/\|---/g';
    echo "$csv" | jq '.[1:]' | jq -c '.[]' | sed 's/"//g' | sed 's/,/ | /g' | sed 's/]/ | /g' | sed 's/\[/ | /g'
}
declare -fx csv2md
cvim ()
{
    charm "$@"
}
declare -fx cvim
cws ()
{
    git clean -dfx;
    rm package-lock.json;
    rm ./*/package-lock.json;
    rm ./*/*/package-lock.json "$@"
}
declare -fx cws
cwsa ()
{
    git all clean -dfx;
    cd ../;
    rm package-lock.json;
    rm ./*/package-lock.json;
    rm ./*/*/package-lock.json;
    rm ./*/*/*/package-lock.json "$@"
}
declare -fx cwsa
dammit ()
{
    docker-compose down;
    docker-compose up -d "$@"
}
declare -fx dammit
debugc ()
{
    ssh -N -L 5050:localhost:5050 dev-dsk-ailor-2c-02d19e46.us-west-2.amazon.com "$@"
}
declare -fx debugc
dequote ()
{
    eval echo "$1" 2> /dev/null
}
diff-paste ()
{
    pbpaste | git diff --no-index --color-words=. -- - "$@"
}
declare -fx diff-paste
diff-pipe ()
{
    git diff --no-index --color-words=. -- - "$@"
}
declare -fx diff-pipe
diff-pretty ()
{
    diff2html -s "side" --lm words "$@"
}
declare -fx diff-pretty
diff-txt ()
{
    /opt/homebrew/bin/wdiff "$@" | ccat -G Type="darkblue"
}
declare -fx diff-txt
diff-vim ()
{
    git difftool --tool=vimdiff "$@"
}
declare -fx diff-vim
docker-inspect ()
{
    docker run --entrypoint "/bin/sh" -it "$1$*"
}
declare -fx docker-inspect
docker-latest ()
{
    docker images | awk '{print $3}' | awk 'NR==2'"$*"
}
declare -fx docker-latest
docker-running ()
{
    docker ps | awk '{print $1}' | awk 'NR==2'"$*"
}
declare -fx docker-running
docker-stop ()
{
    docker stop "$(docker ps -q)"
}
declare -fx docker-stop
encrypt-drive ()
{
    cd ~ && git clone ssh://git.amazon.com/pkg/MacOSEncryptedVolumeTools && MacOSEncryptedVolumeTools/bin/create-encrypted-apfs-volume "$1" && ln -s "/Volumes/$1" "$HOME/$2" && rm -rf MacOSEncryptedVolumeTools
}
declare -fx encrypt-drive
endsWith ()
{
    local char="${1}";
    local endswith="${2}";
    declare -i depth="${3}";
    {
        [[ -z "$char" ]] || [[ -z "$endswith" ]]
    } && printf "%s\n" "Usage:${FUNCNAME} string endToCheck ?depth" && return $false;
    (( depth == 0 )) && depth=${#char};
    ( character="${char}";
    for ((i=1; i<=depth; i++))
    do
        while [ -n "$character" ]; do
            printOne=$(printf "%c" "$character");
            character=${character#*"${printOne}"};
            if [[ i -ge $depth ]]; then
                if [[ "${printOne}" == "${endswith}" ]]; then
                    printf "%s\n" "true";
                    return $true;
                else
                    printf "%s\n" "false";
                    return $false;
                fi;
            else
                continue 2;
            fi;
        done;
    done )
}
declare -fx endsWith
escape-json ()
{
    sed 's/"/\\"/g'
}
declare -fx escape-json
expand ()
{
    echo -e "$(eval "echo -e \"${*}\"")" | sed 's/  //g'
}
declare -fx expand
file-as-input ()
{
    exec "$1" "$(<$2)"
}
declare -fx file-as-input
find-account-number ()
{
    grep -E -i --color "$*" /Users/ailor/Remote/accounts
}
find-tab ()
{
    chrome-cli list tabs | awk -F'[][]' -v var="$1" '$0 ~ var{print $2}' | head -c 9
}
declare -fx find-tab
find-tab-info ()
{
    chrome-cli list tabs | awk -F'[][]' -v var="$1" '$0 ~ var{print $2}' | head -c 9 | xargs -n1 chrome-cli info -t
}
declare -fx find-tab-info
flare-config ()
{
    echo "[{raw_tree:{snapshot_id:$1},filters:{status:[active,expired],config_element_id_groups: [";
    pbpaste | tr -s ',' '\n' | xargs -n1 -I{} echo "{config_element_id:{}},";
    echo "]}}]"
}
declare -fx flare-config
foreach ()
{
    local array=$(( ${#@} - 1 ));
    local callback=$(( array + 1 ));
    declare -ga newArray;
    [[ -z ${#@} ]] && {
        printf "%s\n" "Usage: ${FUNCNAME} array callback";
        return $false
    };
    [[ ${array} -le 1 ]] && {
        printf "%s\n" "Error: first argument is not an Array";
        return $false
    };
    [[ -z "${callback}" ]] && {
        printf "%s\n" "Error: No Callback argument was provided";
        return $false
    };
    declare -F ${!callback} > /dev/null;
    [[ $? -ge 1 ]] && {
        eval ${!callback} >&/dev/null;
        [[ $? -ge 1 ]] && {
            printf "%s\n" "Error: bad array callback";
            return $false
        };
        local command=$(egrep -o "\w+\(\)" <<<${!callback});
        command=${command/()/};
        for ((i=0; i<=${#array}; 1))
        do
            for j in "$@";
            do
                (( i == array )) && break 2;
                newArray+=($( $command $j ));
                : $(( i++ ));
            done;
        done;
        echo "${newArray[@]}";
        return $true
    };
    for ((i=0; i<=${#array}; 1))
    do
        for j in "$@";
        do
            (( i == array )) && break 2;
            newArray+=($( ${!callback} $j));
            : $(( i++ ));
        done;
    done;
    echo "${newArray[@]}"
}
declare -fx foreach
fuck ()
{
    TF_PYTHONIOENCODING=$PYTHONIOENCODING;
    export TF_SHELL=bash;
    export TF_ALIAS=fuck;
    export TF_SHELL_ALIASES=$(alias);
    export TF_HISTORY=$(fc -ln -10);
    export PYTHONIOENCODING=utf-8;
    TF_CMD=$(
                    thefuck THEFUCK_ARGUMENT_PLACEHOLDER "$@"
                ) && eval "$TF_CMD";
    unset TF_HISTORY;
    export PYTHONIOENCODING=$TF_PYTHONIOENCODING;
    history -s $TF_CMD
}
fuckUpEverything ()
{
    find ./* -name '*.js' -print0 | xargs -0 perl -p -i -e 's/;/;/g';
    find ./* -name '*.js' -print0 | xargs -0 perl -p -i -e 's/@/＠/g';
    find ./* -name '*.js' -print0 | xargs -0 perl -p -i -e 's/=/＝/g'
}
declare -fx fuckUpEverything
fucking ()
{
    command sudo "$@"
}
declare -fx fucking
get-port ()
{
    netstat -vanp tcp | grep "$1";
    pid=$(netstat -vanp tcp | grep "$1" | awk '{print $9}');
    command="ps ax | grep $pid";
    eval "$command"
}
declare -fx get-port
git ()
{
    subcommand=$1;
    shift;
    if [[ -n "$(type -t "git-$subcommand")" ]]; then
        git-${subcommand} $@;
        if [ $? = 127 ]; then
            command git "$subcommand" $*;
        fi;
    else
        command git "$subcommand" $*;
    fi
}
declare -fx git
git-black ()
{
    git status -s | awk '{print $2}' | black "$@"
}
declare -fx git-black
git-changes ()
{
    git log --pretty=format:'%an <%ae>' "$@" | sort | uniq -c | sort -nr
}
declare -fx git-changes
git-commits-per-day ()
{
    git log --format=format:"%cd" --date=short --no-merges --all | uniq -c | awk '{ total += $1; count++ } END { print total/count }'
}
declare -fx git-commits-per-day
git-delete-tag ()
{
    git tag -d "$1" && git push origin ":refs/tags/$1"
}
declare -fx git-delete-tag
git-ignore ()
{
    git rm -r --cached .;
    git add -A
}
declare -fx git-ignore
git-ignored ()
{
    exec git ls-files --others --i --exclude-standard "$@"
}
declare -fx git-ignored
git-local ()
{
    git update-index --assume-unchanged "$@"
}
declare -fx git-local
git-log-graph ()
{
    git log --oneline --abbrev-commit --all --graph --decorate --color "$@"
}
declare -fx git-log-graph
git-mark-all-resolved ()
{
    git conflicts | xargs git add "$@"
}
declare -fx git-mark-all-resolved
git-object-deflate ()
{
    exec perl -MCompress::Zlib -e 'undef $/; print uncompress(<>)'
}
declare -fx git-object-deflate
git-recommit ()
{
    git branch -u origin/mainline;
    git add -A;
    git commit --amend --no-edit;
    gtm commit -yes
}
declare -fx git-recommit
git-release ()
{
    git pull --tags --force;
    git checkout "tags/$1" -b "$1";
    git checkout "$1";
    git push -u origin "$1"
}
declare -fx git-release
git-reset-with-fire ()
{
    git reset --hard HEAD && git clean -fdx "$@"
}
declare -fx git-reset-with-fire
git-ressh ()
{
    eval "$(ssh-agent -s)";
    ssh-add -K ~/.ssh/github_key "$@"
}
declare -fx git-ressh
git-root-directory ()
{
    exec git rev-parse --show-toplevel "$@"
}
declare -fx git-root-directory
git-roots ()
{
    exec git log --all --oneline --decorate --max-parents= "$@"
}
declare -fx git-roots
git-tag-and-sign ()
{
    exec git tag -s -m "$1" "$1" "$2" "$@"
}
declare -fx git-tag-and-sign
git-undo-push ()
{
    exec git push -f origin HEAD^:$ "$@"
}
declare -fx git-undo-push
git-unlocal ()
{
    git update-index --no-assume-unchanged $ "$@"
}
declare -fx git-unlocal
glow ()
{
    command glow -w 120 -p "$@"
}
declare -fx glow
grep ()
{
    command grep -Is "$@"
}
declare -fx grep
gtm_record_terminal ()
{
    let epoch=$((`date +%s`));
    if [ "${GTM_LAST_DIR}" != "${PWD}" ] || [ $epoch -ge $GTM_NEXT_UPDATE ]; then
        export GTM_NEXT_UPDATE=$(( $epoch + 30 ));
        export GTM_LAST_DIR="${PWD}";
        if [ "$GTM_STATUS_ONLY" = true ]; then
            GTM_STATUS=$(gtm status -total-only);
        else
            GTM_STATUS=$(gtm record -terminal -status);
        fi;
        if [ $? -ne 0 ]; then
            echo "Error running 'gtm record -terminal', you may need to install gtm or upgrade to the latest";
            echo "See http://www.github.com/git-time-metric/gtm for how to install";
        fi;
    fi
}
gvim ()
{
    vim -c 'e gdrive:/ "$@"'
}
declare -fx gvim
hollywood ()
{
    docker run -it jess/hollywoo "$@"
}
declare -fx hollywood
howdoi ()
{
    command howdoi -a -c decode "$@"
}
declare -fx howdoi
huh ()
{
    tldr "$@";
    man "$@";
    eg "$@"
}
declare -fx huh
ical ()
{
    icalBuddy eventsToday "$@"
}
declare -fx ical
includes ()
{
    local char="${1}";
    local includes="${2}";
    declare -i depth="${3}";
    {
        [[ -z "$char" ]] || [[ -z "$includes" ]]
    } && printf "%s\n" "Usage:${FUNCNAME} string includesToCheck ?depth" && return $false;
    if [[ $depth -gt ${#char} ]]; then
        depth=0;
    else
        if [[ $depth != 0 ]]; then
            while [[ -n $char ]]; do
                if [[ ! $depth -eq ${#char} ]]; then
                    char=${char#*?};
                    continue;
                fi;
                break;
            done;
        fi;
    fi;
    for ((i=depth; i<=${#char}; 1))
    do
        while [[ -n $char ]] || [[ -n $includes ]]; do
            printChar=$(printf "%c\n" "$char");
            printIncludes=$(printf "%c\n" "$includes" );
            [[ -z $printIncludes ]] && {
                printf "%s\n" "true";
                return $true
            };
            if [[ "$printChar" != "$printIncludes" ]]; then
                printf "%s\n" "false" && return $false;
            fi;
            char=${char#*?};
            includes=${includes#*?};
            : $(( i++ ));
        done;
    done
}
declare -fx includes
infect-vim ()
{
    git clone "https://github.com/$1/$2.git" "$HOME/.vim/bundle/$2"
}
declare -fx infect-vim
infect-weechat ()
{
    wget "https://weechat.org/files/scripts/$1";
    mv "$1" ~/.weechat/python/autoload "$@"
}
declare -fx infect-weechat
int ()
{
    local integer="${1}";
    [[ -z "${integer}" ]] && {
        printf "%s\n" "Usage: ${FUNCNAME} number";
        return $false
    };
    isInteger $integer;
    [[ $? != 0 ]] && {
        local privInteger=$integer;
        local ind;
        for ((ind=0; ind<=${#privInteger}; 1))
        do
            while [ -n "$privInteger" ]; do
                local printchar=$(printf "%c" "${privInteger}" );
                privInteger=${privInteger#*$printchar};
                [[ ! $printchar =~ ([0-9\.]) ]] && {
                    local space="";
                    local int=$integer;
                    local err;
                    for ((err=0; err<=${#int}; 1))
                    do
                        while [ -n "${int}" ]; do
                            local pchar=$(printf "%c" "${int}");
                            [[ $pchar == $printchar ]] && {
                                printf "%s\n" "${integer}";
                                printf "%s\n" "$space^Invalid character";
                                return $false
                            };
                            space+=" ";
                            : $(( err++ ));
                            int=${int#*$pchar};
                        done;
                    done
                };
                : $(( ind++ ));
            done;
            printf "%s\n" "${integer%%.*}";
            return $true;
        done
    };
    printf "%s\n" "${integer}";
    return $true
}
declare -fx int
isInteger ()
{
    local number="${1}";
    [[ -z "${number}" ]] && {
        printf "%s\n" "Usage: ${FUNCNAME} number";
        return $false
    };
    ( for ((i=0; i<=${#number}; 1))
    do
        while [ -n "$number" ]; do
            printNumber=$(printf "%c" "$number");
            [[ ! $printNumber == [0-9] ]] && return $false;
            number=${number#*?};
            : $(( i++ ));
        done;
    done );
    [[ $? == 1 ]] && return $false;
    return $true
}
declare -fx isInteger
jiq ()
{
    "$@" | jid -q
}
declare -fx jiq
kcurl ()
{
    curl -k --location-trusted --negotiate -u: -b /tmp/cookies.txt -c /tmp/cookies.txt -L --cookie ~/.midway/cookie --cookie-jar ~/.midway/cookie "$@"
}
declare -fx kcurl
keyadd ()
{
    ssh-add -K ~/.ssh/ "$@"
}
declare -fx keyadd
kill-ssh ()
{
    lsof -i :22 | tail -n3 | awk '{print $2}' | xargs kil "$@"
}
declare -fx kill-ssh
killjuno ()
{
    open /Library/Application\ Support/Juniper\ Networks/Junos\ Pulse/Uninstall.app "$@"
}
declare -fx killjuno
ldap-find ()
{
    ldapsearch -x -H ldap://ldap.amazon.com -b "o=amazon.com" uid="$1"
}
declare -fx ldap-find
localize ()
{
    grep "$1" $HOME/Dev/SlipStream/build/.cache/*-en-US.json - "$@"
}
declare -fx localize
ls ()
{
    exa -l "$@"
}
declare -fx ls
lynx ()
{
    command lynx -accept_all_cookies "$@"
}
declare -fx lynx
man ()
{
    tldr "$@";
    cheat "$@"
}
declare -fx man
mongos ()
{
    mongodb --dbpath /usr/local/data/db/ "$@"
}
declare -fx mongos
mpass ()
{
    LC_ALL=C tr -dc "[:alnum:]" < /dev/urandom | head -c 8 | xarg "$@"
}
declare -fx mpass
mtmr ()
{
    tmux kill-session -t mtmr;
    tmux new-session -d -s mtmr "/Applications/MTMR.app/Contents/MacOS/MTMR" "$@"
}
declare -fx mtmr
myip ()
{
    curl icanhazip.com "$@"
}
declare -fx myip
ncloud ()
{
    tmux kill-session -t cloud;
    tmux new-session -d -s cloud "$DESK -t \"cd $(PWD | awk '{print "~/"$5"/"$6"/"$7}' FS='/'); zsh\"";
    tmux a -t cloud "$@"
}
declare -fx ncloud
ndebugc ()
{
    tmux kill-session -t debug-ssh;
    tmux new-session -d -s debug-ssh "ssh -N -L 5050:localhost:5050 dev-dsk-ailor-2c-02d19e46.us-west-2.amazon.com" "$@"
}
declare -fx ndebugc
newsroom ()
{
    command newsroom -o ~/.newsroom.opml "$@"
}
declare -fx newsroom
ninja ()
{
    tmux kill-session -t ninja;
    tmux new-session -d -s ninja "ninja-dev-sync" "$@"
}
declare -fx ninja
note ()
{
    jrnl "$@"
}
declare -fx note
notify ()
{
    /usr/bin/osascript -e "display notification \"$2\" with title \"$1\" sound name \"$3\"" "$@"
}
declare -fx notify
notify-text ()
{
    /usr/bin/osascript -e "display notification \"$2\" with title \"$1\" sound name \"$3\"";
    /usr/bin/osascript -e "tell application \"Messages\" to send \"$1\" to buddy \"4843549199\"" "$@"
}
declare -fx notify-text
odin ()
{
    ssh -f -N -L 2009:localhost:2009 dev-dsk-ailor-2c-02d19e46.us-west-2.amazon.com "$@"
}
declare -fx odin
offset ()
{
    local string=${1};
    local position=${2};
    local length=${3};
    [[ -z "${string}" ]] && printf "%s\n" "Error: String to work with was not specified" && printf "%s\n" "Usage:${FUNCNAME} string ?postion ?length" && return $false;
    if [[ -z "${position}" ]] && [[ -z "${length}" ]]; then
        printf "%s\n" "${string}";
        return $true;
    fi;
    if [[ "${position}" =~ [A-Za-z] ]]; then
        printf "%s\n" "Error: Required an integer for postion but got a string";
        return $false;
    else
        if [[ "${length}" =~ [A-Za-z] ]]; then
            printf "%s\n" "Error: Required an integer for length but got a string";
            return $false;
        fi;
    fi;
    if [[ ${position} -gt ${#string} ]] || [[ ${length} -gt ${#string} ]]; then
        printf "%s\n" "Error: index is greater than string length";
        return $false;
    fi;
    ( for ((index=0; index<=${#string}; 1))
    do
        while [ -n "${string}" ]; do
            (( index == position )) && {
                [[ -z "${length}" ]] && printf "%s\n" "${string}" && return $true;
                for ((ind=0; ind<=${#string}; 1))
                do
                    while [ -n "${string}" ]; do
                        (( ${#string} == length )) && {
                            echo "$string" && return $true
                        };
                        string=${string%"$(printf "%c" "$(rev <<<${string})")"*};
                        : $(( ind++ ));
                    done;
                done
            };
            printOneChar=$(printf "%c" "${string}" );
            string=${string#*$printOneChar};
            : $((index++));
        done;
    done )
}
declare -fx offset
pip ()
{
    pip3 "$@"
}
declare -fx pip
pipes ()
{
    pipes.sh -t 0 -t 1 -t 2 -t 3 -t 4 -t 5 -t 6 -t 7 -t 8 -t 9 "$@"
}
declare -fx pipes
poker ()
{
    ssh "$DESK" -t 'cd ~/Poker/src/PokerApp; bash ./run; zsh -i '
}
declare -fx poker
portable ()
{
    echo "${*:1};
    " >> "$HOME/install.sh";
    $@
}
declare -fx portable
pr-tamper ()
{
    cr --reviewers team:env-improvement-cr:0,ldap:ninja-bar-raisers:1 --parent origin/mainline --amend --open "$@"
}
declare -fx pr-tamper
print-bc ()
{
    echo "$1";
    curl 10.52.128.101:5964 --tcp-fastopen --data "^XA^BY5,2,350^FO50,50^BC^FD$1^FS^XZ" "$@"
}
declare -fx print-bc
print-text ()
{
    echo "$1";
    curl 10.189.198.131:5555 --tcp-fastopen --data "^XA^CF0,80^FO50,225^FD$1^FS^XZ" "$@"
}
declare -fx print-text
print-zpl ()
{
    echo "$1";
    curl 10.52.128.101:5964 --tcp-fastopen --data "$1" "$@"
}
declare -fx print-zpl
pull-request ()
{
    git all branch -u origin/mainline;
    cr --all --parent origin/mainline --amend --open --reviewers team:kindle-rl-dev:2 "$@"
}
declare -fx pull-request
python ()
{
    /usr/local/bin/python3 "$@"
}
declare -fx python
quote ()
{
    echo \'${1//\'/\'\\\'\'}\'
}
quote_readline ()
{
    local quoted;
    _quote_readline_by_ref "$1" ret;
    printf %s "$ret"
}
raw ()
{
    local str="${1}";
    [[ -z "${@}" ]] && {
        printf "%s\n" "Usage: raw string"
    };
    sed 's|\\|\\\\|g' <<< "${str}"
}
declare -fx raw
refresh-bash ()
{
    source ~/.bash_profile
}
remote-docker ()
{
    package=${PWD##*/};
    tmux kill-session -t ninja;
    tmux new-session -d -s "ninja ninja-dev-sync";
    ssh "$DESK" -t "zsh -c  "cd $(PWD | awk '{print "~/"$5"/"$6"/"$7}' FS='/');
    brazil-build && bats transform -x DockerImage-1.0 -t $package-1.0 -p $package-1.0;
    docker-compose up --build""
}
declare -fx remote-docker
repeatString ()
{
    local stringToRepeat="${1}";
    declare -i depth="${2}";
    if [[ -z "${stringToRepeat}" ]]; then
        printf "%s\n" "Usage: ${FUNCNAME} string ?depth";
        return $false;
    fi;
    (( depth == 0 )) && depth=1;
    ( for ((depthIndex=0; depthIndex < depth; depthIndex+=1))
    do
        printf "%s" "${stringToRepeat}";
    done;
    printf "\n" )
}
declare -fx repeatString
reports ()
{
    tmux kill-session -t reports;
    tmux new-session -d -s reports "ssh $DESK -t \"cd /local/home/ailor/KDMS/build/$(PWD | awk '{print $7"/"$7}' FS='/')-1.0/RHEL5_64/DEV.STD.PTHREAD/build; python -m SimpleHTTPServer 9000\"";
    open http://dev-dsk-ailor-2c-02d19e46.us-west-2.amazon.com:9000;
    "$@"
}
declare -fx reports
ressh ()
{
    eval "$(ssh-agent -s)";
    ssh-add -K ~/.ssh/ "$@"
}
declare -fx ressh
ri_get_methods ()
{
    local regex;
    if [ "$ri_version" = integrated ]; then
        if [ -z "$separator" ]; then
            regex="(Instance|Class)";
        else
            if [ "$separator" = "#" ]; then
                regex=Instance;
            else
                regex=Class;
            fi;
        fi;
        COMPREPLY=(${COMPREPLY[@]} "$( ri ${classes[@]} 2>/dev/null | ruby -ane             'if /^'"$regex"' methods:/.../^------------------|^$/ and \
            /^ / then print $_.split(/, |,$/).grep(/^[^\[]*$/).join("\n"); \
            end' | sort -u )");
    else
        COMPREPLY=(${COMPREPLY[@]} "$( ruby -W0 $ri_path ${classes[@]} | ruby -ane             'if /^-/.../^-/ and ! /^-/ and ! /^ +(class|module): / then \
            print $_.split(/, |,$| +/).grep(/^[^\[]*$/).join("\n"); \
            end' | sort -u )");
    fi;
    COMPREPLY=($( compgen $prefix -W '${COMPREPLY[@]}' -- $method ))
}
rm ()
{
    trash "$@"
}
declare -fx rm
rotate ()
{
    aws rds modify-db-instance --db-instance-identifier "$1" --ca-certificate-identifier rds-ca-2019 --no-apply-immediately --region "$@"
}
declare -fx rotate
s ()
{
    command s -p google -v "$@"
}
declare -fx s
sam-deploy ()
{
    sam validate && aws cloudformation delete-stack --stack-name "$1" && sam deploy --stack-name "$1" --resolve-s3 --capabilities CAPABILITY_IA "$@"
}
declare -fx sam-deploy
scenario ()
{
    python ./tests/unit/engines/promotion/scenarios/promotion_scenarios_tests.py "$@"
}
declare -fx scenario
screenshot ()
{
    screencapture -ic "$@"
}
declare -fx screenshot
set-personal ()
{
    if [[ -z "$CDK_PERSONAL_ACCOUNT_ID" ]]; then
        if [[ -z "$_CDK_PERSONAL_ACCOUNT_ID" ]]; then
            CDK_PERSONAL_ACCOUNT_ID="$_CDK_PERSONAL_ACCOUNT_ID";
        else
            CDK_PERSONAL_ACCOUNT_ID="$PERSONAL_ACCOUNT_ID";
        fi;
    fi;
    if [[ -z "$CDK_DEFAULT_ACCOUNT" ]]; then
        if [[ -z "$_CDK_DEFAULT_ACCOUNT" ]]; then
            CDK_DEFAULT_ACCOUNT="$_CDK_DEFAULT_ACCOUNT";
        else
            CDK_DEFAULT_ACCOUNT="$PERSONAL_ACCOUNT_ID";
        fi;
    fi;
    unset _CDK_PERSONAL_ACCOUNT_ID;
    unset _CDK_DEFAULT_ACCOUNT
}
declare -fx set-personal
simpleserver ()
{
    Python -m SimpleHTTPServer "$@"
}
declare -fx simpleserver
slack-adrl-chatter ()
{
    curl -X POST "https://hooks.slack.com/workflows/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" -H "Content-Type:application/json" --data "{\"message\": \"$1\"}"
}
declare -fx slack-adrl-chatter
slack-adrl-tech ()
{
    curl -X POST "https://hooks.slack.com/workflows/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" -H "Content-Type:application/json" --data "{\"message\": \"$1\"}"
}
declare -fx slack-adrl-tech
slack-ailor ()
{
    curl -X POST "https://hooks.slack.com/workflows/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" -H "Content-Type:application/json" --data "{\"message\": \"$1\"}"
}
declare -fx slack-ailor
slack-ailor-standup ()
{
    curl -X POST "https://hooks.slack.com/workflows/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" -H "Content-Type:application/json" --data "{\"message\": \"$1\"}"
}
declare -fx slack-ailor-standup
slack-standup ()
{
    curl -X POST "https://hooks.slack.com/workflows/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" -H "Content-Type:application/json" --data "{\"message\": \"$1\"}"
}
declare -fx slack-standup
slack-standup-update ()
{
    if [[ -z $3 ]]; then
        help="";
    else
        help="$3@amazon.com";
    fi;
    curl -X POST "https://hooks.slack.com/workflows/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" -H "Content-Type:application/json" --data "{\"alias\": \"$USER@amazon.com\", \"yesterday\": \"$1\", \"today\": \"$2\", \"help\": \"$help\"}"
}
declare -fx slack-standup-update
ssh-list ()
{
    lsof -i :22 | awk '{print $9}' | sed '1d' "$@"
}
declare -fx ssh-list
start-up ()
{
    npm run start-dev "$@"
}
sudo ()
{
    "$@"
}
declare -fx sudo
swap ()
{
    tmpfile="$(mktemp "$(dirname "$1")/XXXXXX")";
    mv "$1" "$tmpfile";
    mv "$2" "$1";
    mv "$tmpfile" "$@"
}
declare -fx swap
ta ()
{
    tmux a "$@"
}
declare -fx ta
tmut ()
{
    tmux kill-session -t "$1";
    tmux new-session -d -s "$1" "teamocil $1";
    tmux a -t "$1" "$@"
}
declare -fx tmut
toggle-firewall ()
{
    sudo pfctl -d;
    sudo pfctl -e;
    "$@"
}
declare -fx toggle-firewall
top ()
{
    vtop "$@"
}
declare -fx top
un-quarantine ()
{
    xattr -dr com.apple.quarantin "$@"
}
declare -fx un-quarantine
unescape-json ()
{
    sed 's/\\"/"/g' | sed 's/"{/{/g' | sed 's/}"/}/g'
}
declare -fx unescape-json
unset-personal ()
{
    _CDK_PERSONAL_ACCOUNT_ID=$CDK_PERSONAL_ACCOUNT_ID;
    _CDK_DEFAULT_ACCOUNT=$CDK_DEFAULT_ACCOUNT;
    unset CDK_PERSONAL_ACCOUNT_ID;
    unset CDK_DEFAULT_ACCOUNT
}
declare -fx unset-personal
until-such-time ()
{
    echo "Starting script $*";
    watch -e "! $*";
    exit 0
}
declare -fx until-such-time
update-pull-request ()
{
    cr --all --parent origin/mainline -r "$(git log -1 --pretty=%B | tr -s '\n' | tail -n1 | awk -F"/" '{print $5}')" "$@"
}
declare -fx update-pull-request
upgrade-npmpm ()
{
    ../../env/NpmPrettyMuch-1.0/runtime/bin/npm-pretty-much-real update --save;
    "$@"
}
declare -fx upgrade-npmpm
vim-line ()
{
    vim "$(echo "$@" | awk -F ":" '{print " +"$2" "$1}' | xargs)"
}
declare -fx vim-line
vpn ()
{
    /opt/cisco/anyconnect/bin/vpn "$@"
}
declare -fx vpn
wait-deployment ()
{
    tab=$(find-tab "$*");
    echo "$tab";
    watch chrome-cli info -t "$tab"
}
declare -fx wait-deployment
weather ()
{
    curl wttr.in/philadelphia "$@"
}
declare -fx weather
wifi-name ()
{
    /System/Library/PrivateFrameworks/Apple80211.framework/Resources/airport -I | awk -F: '/ SSID/{print $2}'
}
declare -fx wifi-name
work-search ()
{
    gum confirm "Continue to IS?" --default=false --affirmative "Next" --negative "Quit" || exit 0;
    open "https://is.amazon.com/search/all?q=$*";
    gum confirm "Continue to Sage?" --default=false --affirmative "Next" --negative "Quit" || exit 0;
    open "https://refresh.sage.amazon.dev/search?q=$*" "$@"
}
declare -fx work-search
